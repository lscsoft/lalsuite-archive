diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/bh_qnmode.c ./bh_qnmode.c
19a20,118
> /**
>  * @defgroup lalsim_bh_qnmode lalsim-bh-qnmode
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Computes the quasi-normal modes of a black hole
>  *
>  * ### Synopsis
>  *
>  *     lalsim-bh-qnmode [-h] [-L] [-M Msolar] [-a a] -l l -m m -s s
>  *
>  * ### Description
>  *
>  * The `lalsim-bh-qnmode` utility prints the eigenvalues of a black hole
>  * quasinormal mode with spin weight @p s (use -2 for gravitational quasinormal
>  * modes) and mode numbers @p l and @p m for given black hole dimensionless
>  * spin if the spin @p a is specified using the argument `-a`; or prints a
>  * table of mode eigenvalues if @p a is not specified; or prints frequency and
>  * quality factor if mass @p Msolar is specified.
>  *
>  * The utility uses Leaver's conventions (G = c = 2M = 1) if the option
>  * `--leaver` is used
>  * 
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>
>  * <DD>print a help message and exit</DD>
>  * <DT>`-L, --leaver`</DT>
>  * <DD>use Leaver's conventions: G = c = 2M = 1</DD>
>  * <DT>`-M` Msolar</DT>
>  * <DD>(optional) set black hole mass (solar masses)</DD>
>  * <DT>`-a` a</DT>
>  * <DD>(optional) set value of dimensionless spin parameter a/M, |a/M|<1 (Leaver: |a/M|<0.5)</DD>
>  * <DT>`-l` l</DT>
>  * <DD>(required) set value of mode number l, l>=0</DD>
>  * <DT>`-m` m</DT>
>  * <DD>(required) set value of mode number m, abs(m)<=l</DD>
>  * <DT>`-s` s</DT>
>  * <DD>(required) set value of spin weight s, s<=0</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-bh-qnmode`.  Common values are: `LAL_DEBUG_LEVEL=0` which suppresses
>  * error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages alone,
>  * `LAL_DEBUG_LEVEL=3` which prints both error messages and warning messages,
>  * and `LAL_DEBUG_LEVEL=7` which additionally prints informational messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-bh-qnmode` utility exits 0 on success, and >0 if an error
>  * occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-bh-qnmode -a 0.97 -M 10 -l 2 -m 2 -s -2
>  *
>  * outputs the freqeuency and quality factor for black hole ringdown
>  * gravitational radiation in the l = m = 2 quasinormal mode for a
>  * M = 10 solar mass hole with Kerr spin parameter a = 0.97 M.
>  *
>  * The command:
>  *
>  *     lalsim-bh-qnmode -L -l 2 -m 0 -s -2
>  *
>  * prints a table of Kerr quasinormal frequencies and angular separation
>  * constants for the fundamental mode corresponding to l = 2 and m = 1
>  * for gravitational perturbations (s = -2) in Leaver's conventions:
>  *
> @verbatim
> # quasinormal mode table for l=2 m=0 s=-2 (Leaver's conventions)
> #  a   	        A        	        omega
> 0.0000 	(4.00000,+0.00000)	(+0.747343,-0.177925)
> 0.1000 	(3.99722,+0.00139)	(+0.750248,-0.177401)
> 0.2000 	(3.98856,+0.00560)	(+0.759363,-0.175653)
> 0.3000 	(3.97297,+0.01262)	(+0.776108,-0.171989)
> 0.4000 	(3.94800,+0.02226)	(+0.803835,-0.164313)
> 0.4500 	(3.93038,+0.02763)	(+0.824009,-0.156965)
> 0.4900 	(3.91269,+0.03152)	(+0.844509,-0.147065)
> 0.4999 	(3.90770,+0.03227)	(+0.850231,-0.143650)
> 
> 0.0000 	(4.00000,-0.00000)	(-0.747343,-0.177925)
> 0.1000 	(3.99722,-0.00139)	(-0.750248,-0.177401)
> 0.2000 	(3.98856,-0.00560)	(-0.759363,-0.175653)
> 0.3000 	(3.97297,-0.01262)	(-0.776108,-0.171989)
> 0.4000 	(3.94800,-0.02226)	(-0.803835,-0.164313)
> 0.4500 	(3.93038,-0.02763)	(-0.824009,-0.156965)
> 0.4900 	(3.91269,-0.03152)	(-0.844509,-0.147065)
> 0.4999 	(3.90770,-0.03227)	(-0.850231,-0.143650)
> @endverbatim
>  *
>  * Compare with Table 3 of E. W. Leaver, "An analytic representation of
>  * quasi-normal modes of Kerr black holes", Proc. R. Soc. Lond. A @b 402 285
>  * (1985).
>  */
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: bh_qnmode.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/bh_ringdown.c ./bh_ringdown.c
19a20,95
> /**
>  * @defgroup lalsim_bh_ringdown lalsim-bh-ringdown
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Simulates a gravitational waveform from black hole ringdown.
>  *
>  * ### Synopsis
>  *
>  *     lalsim-bh-ringdown [-h] -M Msolar -a a -r distanceMpc -e fracEnergy -i inclination [-q azimuth] -l l -m m
>  *
>  * ### Description
>  *
>  * The `lalsim-bh-ringdown` utility produces a stream of a simulated
>  * gravitational waveform for ringdown radiation from a quasinormal
>  * mode of a Kerr black hole with mode numbers @p l and @p m.  The
>  * dimensionless Kerr spin parameter @p a, black hole mass in solar
>  * masses @p Msolar, fraction of mass lost in ringdown radiation
>  * @p e, distance to the observer in Mpc @p distanceMpc, and inclination of the
>  * observer relative to the black hole's spin axis @p inclination must be
>  * specified.  The output is written to standard output in three-column ascii
>  * format.  The first column gives the time corresponding to each sample, the
>  * second column gives the value of the plus-polarization of the waveform, and
>  * the third column gives the value of the cross-polarization of the waveform.
>  * 
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>
>  * <DD>print a help message and exit</DD>
>  * <DT>`-M` Msolar</DT>
>  * <DD>(required) set black hole mass (solar masses)</DD>
>  * <DT>`-a` a</DT>
>  * <DD>(required) set value of dimensionless spin parameter a/M, |a/M|<1 (Leaver: |a/M|<0.5)</DD>
>  * <DT>`-r` distanceMpc</DT>
>  * <DD>(required) set distance (Mpc)</DD>
>  * <DT>`-e` fracEnergy</DT>
>  * <DD>(required) set energy radiated (fraction of mass)</DD>
>  * <DT>`-i` inclination</DT>
>  * <DD>(required) set inclination angle (degrees)</DD>
>  * <DT>`-q` azimuth</DT>
>  * <DD>(optional: default=0) set azimuth angle (degrees)</DD>
>  * <DT>`-l` l</DT>
>  * <DD>(required) set value of mode number l, l>=0</DD>
>  * <DT>`-m` m</DT>
>  * <DD>(required) set value of mode number m, abs(m)<=l</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-bh-ringdown`.  Common values are: `LAL_DEBUG_LEVEL=0` which
>  * suppresses error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages
>  * alone, `LAL_DEBUG_LEVEL=3` which prints both error messages and warning
>  * messages, and `LAL_DEBUG_LEVEL=7` which additionally prints informational
>  * messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-bh-ringdown` utility exits 0 on success, and >0 if an error
>  * occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-bh-ringdown -M 10 -a 0.97 -r 1.0 -e 0.01 -i 45.0 -l 2 -m 2
>  *
>  * produces a three-column ascii output to standard output; the rows are
>  * samples (at the rate of 16384 Hz), and the three columns are 1. the
>  * time of each sample, 2. the plus-polarization strain, and 3. the
>  * cross-polarization strain.  The waveform produced is for a 10 solar
>  * mass black hole spinning with Kerr parameter a/M = 0.97 at a distance
>  * of 1 Mpc and inclination of 45 degrees that radiates 1% of its mass in the l
>  * = 2, m = 2 quasinormal mode.
>  */
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: bh_ringdown.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/bh_sphwf.c ./bh_sphwf.c
19a20,102
> /**
>  * @defgroup lalsim_bh_sphwf lalsim-bh-sphwf
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Evaluates a spin-weighted spheroidal wave function
>  *
>  * ### Synopsis
>  *
>  *     lalsim-bh-sphwf [-h] [-i theta] -a a -l l -m m -s s
>  *
>  * ### Description
>  *
>  * The `lalsim-bh-sphwf` utility prints the value of the spin-weighted
>  * spheroidal wave function \f$ {}_{s}S_{\ell,m}(\cos\theta, a) \f$
>  * for the specified dimensionless spin parameter @p a, spin weight @p s
>  * mode numbers @p l and @p m, and polar angle @p theta.  If the parameter
>  * @p theta is not given, the utility prints a table of the values of
>  * the spin-weighted spheroidal wave function.
>  * 
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>
>  * <DD>print a help message and exit</DD>
>  * <DT>`-i` theta</DT>
>  * <DD>(optional) set the polar angle (degrees)</DD>
>  * <DT>`-a` a</DT>
>  * <DD>(required) set value of dimensionless spin parameter a/M, |a/M|<1</DD>
>  * <DT>`-l` l</DT>
>  * <DD>(required) set value of mode number l, l>=0</DD>
>  * <DT>`-m` m</DT>
>  * <DD>(required) set value of mode number m, abs(m)<=l</DD>
>  * <DT>`-s` s</DT>
>  * <DD>(required) set value of spin weight s, s<=0</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-bh-sphwf`.  Common values are: `LAL_DEBUG_LEVEL=0` which suppresses
>  * error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages alone,
>  * `LAL_DEBUG_LEVEL=3` which prints both error messages and warning messages,
>  * and `LAL_DEBUG_LEVEL=7` which additionally prints informational messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-bh-sphwf` utility exits 0 on success, and >0 if an error
>  * occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-bh-sphwf -a 0.97 -l 2 -m 2 -s -2
>  *
>  * prints a table of the spin-weighted spheroidal harmonic for
>  * spin weight -2 (gravitational perturbations) in the l = m = 2 quasinormal
>  * mode for black hole with Kerr spin parameter a/M = 0.97:
>  *
> @verbatim
> # theta(deg)	    Re(S)   	    Im(S)
>        0	1.872344e+00	-6.463929e-02
>       10	1.827823e+00	-6.206959e-02
>       20	1.694394e+00	-5.225983e-02
>       30	1.504102e+00	-4.281635e-02
>       40	1.273225e+00	-3.208053e-02
>       50	1.027770e+00	-2.170445e-02
>       60	7.909086e-01	-1.294164e-02
>       70	5.808472e-01	-6.804991e-03
>       80	4.043798e-01	-2.360517e-03
>       90	2.668276e-01	-8.673617e-19
>      100	1.656352e-01	9.846400e-04
>      110	9.604459e-02	1.063797e-03
>      120	5.104255e-02	8.091283e-04
>      130	2.420241e-02	4.838700e-04
>      140	9.739511e-03	2.305645e-04
>      150	3.034816e-03	8.061289e-05
>      160	5.924425e-04	1.697014e-05
>      170	3.675324e-05	1.099041e-06
>      180	0.000000e+00	0.000000e+00
> @endverbatim
>  */
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: bh_sphwf.o
Only in .: burst.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/config.h ./config.h
71c71
< #define LALSIMULATION_VERSION "1.4.0.1"
---
> #define LALSIMULATION_VERSION "1.4.1.1"
80c80
< #define LALSIMULATION_VERSION_MICRO 0
---
> #define LALSIMULATION_VERSION_MICRO 1
98c98
< #define PACKAGE_STRING "LALSimulation 1.4.0.1"
---
> #define PACKAGE_STRING "LALSimulation 1.4.1.1"
104c104
< #define PACKAGE_VERSION "1.4.0.1"
---
> #define PACKAGE_VERSION "1.4.1.1"
110c110
< #define VERSION "1.4.0.1"
---
> #define VERSION "1.4.1.1"
Only in .: delete_me.txt
Common subdirectories: /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/.deps and ./.deps
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/detector_noise.c ./detector_noise.c
19a20,131
> /**
>  * @defgroup lalsim_detector_noise lalsim-detector-noise
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Simulates detector noise
>  *
>  * ### Synopsis
>  *
>  *     lalsim-detector-noise [options]
>  *
>  * ### Description
>  *
>  * The `lalsim-detector-noise` utility produces a continuous stream of
>  * simulated detector noise for a specified interval of time and for
>  * a specified noise PSD.  Alternatively, `lalsim-detector-noise` outputs
>  * a requested noise PSD.  The output is written to the standard output
>  * in two-column ascii format data in which the first column contains either
>  * the GPS times of each sample or the frequency of each PSD component,
>  * and the second column contains the value of that sample.
>  *
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>
>  * <DD>print this message and exit</DD>
>  * <DT>`--verbose`</DT>
>  * <DD>verbose output</DD>
>  * <DT>`-0`, `--0noise`</DT>
>  * <DD>no noise (generates zeros)</DD>
>  * <DT>`-A`, `--aligo-nosrm`</DT>
>  * <DD>aLIGO no SRM noise</DD>
>  * <DT>`-B`, `--aligo-zerodet-lowpower`</DT>
>  * <DD>aLIGO zero detuning low power noise</DD>
>  * <DT>`-C`, `--aligo-zerodet-highpower`</DT>
>  * <DD>aLIGO zero detuning high power noise</DD>
>  * <DT>`-D`, `--aligo-nsnsopt`</DT>
>  * <DD>aLIGO NSNS optimized noise</DD>
>  * <DT>`-E`, `--aligo-bhbh20deg`</DT>
>  * <DD>aLIGO BHBH optimized 20 deg detuning noise</DD>
>  * <DT>`-F`, `--aligo-highfreq`</DT>
>  * <DD>aLIGO kHz narrowband noise</DD>
>  * <DT>`-I`, `--iligo-srd`</DT>
>  * <DD>iLIGO SRD noise power</DD>
>  * <DT>`-v`, `--virgo`</DT>
>  * <DD>initial Virgo noise power</DD>
>  * <DT>`-V`, `--advvirgo`</DT>
>  * <DD>Advanced Virgo noise power</DD>
>  * <DT>`-g`, `--geo`</DT>
>  * <DD>GEO600 noise power</DD>
>  * <DT>`-G`, `--geohf`</DT>
>  * <DD>GEO-HF noise power</DD>
>  * <DT>`-T`, `--tama`</DT>
>  * <DD>TAMA300 noise power</DD>
>  * <DT>`-K`, `--kagra`</DT>
>  * <DD>KAGRA noise power</DD>
>  * <DT>`-O`, `--official`</DT>
>  * <DD>use official data files</DD>
>  * <DT>`-P`, `--psd-only`</DT>
>  * <DD>output PSD only</DD>
>  * <DT>`-a`, `--asd-file` ASDFILE</DT>
>  * <DD>read amplitude spectrum density file</DD>
>  * <DT>`-s`, `--start-time` GPSSTART</DT>
>  * <DD>GPS start time (s)</DD>
>  * <DT>`-t`, `--duration` DURATION</DT>
>  * <DD>(required) duration of data to produce (s)</DD>
>  * <DT>`-r`, `--sample-rate` SRATE</DT>
>  * <DD>sample rate (Hz) [16384]</DD>
>  * <DT>`-d`, `--segment-duration` SEGDUR</DT>
>  * <DD>segment duration (s) [4]</DD>
>  * <DT>`-f`, `--low-frequency` FLOW</DT>
>  * <DD>override default low frequency (Hz)</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-detector-noise`.  Common values are: `LAL_DEBUG_LEVEL=0` which
>  * suppresses error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages
>  * alone, `LAL_DEBUG_LEVEL=3` which prints both error messages and warning
>  * messages, and `LAL_DEBUG_LEVEL=7` which additionally prints informational
>  * messages.
>  *
>  * The `GSL_RNG_SEED` and `GSL_RNG_TYPE` environment variables can be used
>  * to set the random number generator seed and type respectively.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-detector-noise` utility exits 0 on success, and >0 if an error
>  * occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-detector-noise --aligo-zerodet-highpower -s 1000000000 -t 1000
>  *
>  * will stream 1000 seconds of aLIGO zero detuning high power noise
>  * beginning at GPS time 1000000000.
>  *
>  * The command:
>  *
>  *     lalsim-detector-noise --iligo-srd -P
>  *
>  * outputs the Initial LIGO PSD.
>  *
>  * The command:
>  *
>  *     lalsim-detector-noise -0 -s 1000000000 -t 1000
>  *
>  * will stream 1000 seconds of zero-noise beginning at GPS time 1000000000.
>  */
> 
33a146,148
> #include <lal/LALSimUtils.h>
> 
> static LALUnit strainSquaredPerHertzUnit = { 0, { 0, 0, 1, 0, 0, 2, 0}, { 0, 0, 0, 0, 0, 0, 0} };
46c161,162
< const char *prefix;
---
> char *asdfile;
> int verbose = 0;
94,95c210,213
< 	psd = XLALCreateREAL8FrequencySeries(detector, &tstart, 0.0, srate/length, &lalSecondUnit, length/2 + 1);
< 	if (official && opsdfunc)
---
> 	psd = XLALCreateREAL8FrequencySeries(detector, &tstart, 0.0, srate/length, &strainSquaredPerHertzUnit, length/2 + 1);
> 	if (asdfile)
> 		XLALSimNoisePSDFromFile(psd, flow, asdfile);
> 	else if (official && opsdfunc)
98a217,227
> 	if (verbose) {
> 		double Mpc = 1e6 * LAL_PC_SI;
> 		double horizon_distance;
> 		fprintf(stderr, "%-39s %s\n", "detector: ", detector);
> 		fprintf(stderr, "%-39s %g Hz\n", "low-frequency cutoff: ", flow);
> 		horizon_distance = XLALMeasureStandardSirenHorizonDistance(psd, flow, -1.0);
> 		fprintf(stderr, "%-39s %g Mpc\n", "standard siren horizon distance: ", horizon_distance / Mpc);
> 		fprintf(stderr, "%-39s %g Mpc\n", "sense-monitor range: ", horizon_distance / Mpc / LAL_HORIZON_DISTANCE_OVER_SENSEMON_RANGE);
> 		fprintf(stderr, "%-39s GSL_RNG_TYPE=%s\n", "GSL random number generator:", gsl_rng_name(rng));
> 		fprintf(stderr, "%-39s GSL_RNG_SEED=%lu\n", "GSL random number seed:", gsl_rng_default_seed);
> 	}
134a264
> 			{ "verbose", no_argument, 0, 1 },
150a281
> 			{ "psd-file", no_argument, 0, 'p' },
158c289
< 	char args[] = "hI0ABCDEFOPvVgGTKs:t:r:d:f:";
---
> 	char args[] = "h\1I0ABCDEFOPvVgGTKa:s:t:r:d:f:";
177a309,311
> 			case 1: /* verbose */
> 				verbose = 1;
> 				break;
189c323
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_NoSRM";
195c329
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_ZeroDet_LowPower";
201c335
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_ZeroDet_HighPower";
207c341
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_NSNSopt";
213c347
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_BHBH20deg";
219c353
< 				detector = "aLIGO";
---
> 				detector = "aLIGO_HighFreq";
224c358
< 				detector = "LIGO SRD";
---
> 				detector = "LIGO_SRD";
261a396,400
> 			case 'a': /* asd-file */
> 				flow = 0.0;
> 				asdfile = LALoptarg;
> 				detector = LALoptarg;
> 				break;
297c436
< 	if (! psdfunc || (!psdonly && duration == 0.0)) {
---
> 	if ((!psdfunc && !asdfile) || (!psdonly && duration == 0.0)) {
327,331c466,471
< 	fprintf(stderr, "\t-s, --start-time             \tGPS start time (s)\n");
< 	fprintf(stderr, "\t-t, --duration               \t(required) duration of data to produce (s)\n");
< 	fprintf(stderr, "\t-r, --sample-rate            \tsample rate (Hz) [16384]\n");
< 	fprintf(stderr, "\t-d, --segment-duration       \tsegment duration (s) [4]\n");
< 	fprintf(stderr, "\t-f, --low-frequency          \toverride default low frequency (Hz)\n");
---
> 	fprintf(stderr, "\t-a, --asd-file ASDFILE       \tread an ASD file\n");
> 	fprintf(stderr, "\t-s, --start-time GPSSTART    \tGPS start time (s)\n");
> 	fprintf(stderr, "\t-t, --duration DURATION      \t(required) duration of data to produce (s)\n");
> 	fprintf(stderr, "\t-r, --sample-rate SRATE      \tsample rate (Hz) [16384]\n");
> 	fprintf(stderr, "\t-d, --segment-duration SEGDUR\tsegment duration (s) [4]\n");
> 	fprintf(stderr, "\t-f, --low-frequency FLOW     \toverride default low frequency (Hz)\n");
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: detector_noise.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/detector_strain.c ./detector_strain.c
28a29,118
> /**
>  * @defgroup lalsim_detector_strain lalsim-detector-strain
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Computes the strain on a detector given a gravitational waveform
>  *
>  * ### Synopsis
>  *
>  *     lalsim-detector-strain [options] [file]
>  *
>  * ### Description
>  *
>  * The `lalsim-detector-strain` utility converts a gravitational waveform
>  * in `file` or standard input if `file` is absent into an induced detector
>  * strain on a specified detector.  The input data should be in a
>  * three-column ascii format with the first column being the time of each
>  * sample, the second column being the plus-polarization of the gravitational
>  * waveform, and the third column being the cross-polarization of the
>  * gravitational waveform.  The timestamps on the input file should be
>  * centered time 0 (conventions vary: some waveforms will end near time 0;
>  * others will be centered on time 0).  The output is written to standard
>  * output in two column ascii format where the first column is the GPS
>  * timestamp of each sample and the second column is the strain induced on
>  * the detector.
>  *
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>
>  * <DD>print a help message and exit</DD>
>  * <DT>`-v`, `--verbose`</DT>
>  * <DD>verbose output</DD>
>  * <DT>`-r`, `--radians`</DT>
>  * <DD>use radians rather than decimal degrees</DD>
>  * <DT>`-O`, `--overhead`</DT>
>  * <DD>signal from directly overhead</DD>
>  * <DT>`-D` PREFIX, `--detector-prefix=`PREFIX</DT>
>  * <DD>(required unless overhead) detector prefix (e.g., 'H1', 'L1', 'V1')</DD>
>  * <DT>`-t` EPOCH, `--gps-time=`EPOCH</DT>
>  * <DD>(required) time of arrival at earth geocenter (or at detector if
>  * overhead): this is added to the timestamp of the input data, which should be
>  * an waveform about time = 0</DD>
>  * <DT>`-a` RA, `--right-ascension=`RA</DT>
>  * <DD>(required unless overhead) right ascension in H:M:S format or decimal
>  * degrees</DD>
>  * <DT>`-d` DEC, `--declination=`DEC</DT>
>  * <DD>(required unless overhead) declination in D:M:S format or decimal
>  * degrees</DD>
>  * <DT>`-p` PSI,` --polarization-angle=`PSI</DT>
>  * <DD>(required) polarization angle in degrees</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-detector-strain`.  Common values are: `LAL_DEBUG_LEVEL=0` which
>  * suppresses error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages
>  * alone, `LAL_DEBUG_LEVEL=3` which prints both error messages and warning
>  * messages, and `LAL_DEBUG_LEVEL=7` which additionally prints informational
>  * messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-detector-strain` utility exits 0 on success, and >0 if an error
>  * occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-inspiral | lalsim-detector-strain -D H1 -a 1:23:45 -d 45.0 -p 30.0 -t 1000000000
>  *
>  * outputs to standard output in two-column ascii format the strain induced
>  * on the LHO observatory detector from a 1.4 solar mass + 1.4 solar mass
>  * binary inspiral at 1 Mpc distance originating from source at
>  * right-ascension 1h 23m 45s, declination 45 degrees, and polarization angle
>  * 30 degrees that arrives at the geocenter at GPS time 1000000000.  The
>  * first column contains the GPS time of each sample and the second column
>  * contains the induced detector strain at that time.
>  *
>  * The command:
>  *
>  *     lalsim-inspiral | lalsim-detector-strain -O -p 0.0 -t 1000000000
>  *
>  * produces a similar output, but now for a signal coming from directly
>  * overhead of a arbitrary detector with polarization angle 0 (optimally
>  * oriented); the GPS arrival time is now at the detector location.
>  */
> 
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: detector_strain.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: ._.DS_Store
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: .DS_Store
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/inject.c ./inject.c
19a20,74
> /**
>  * @defgroup lalsim_inject lalsim-inject
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Injects an induced gravitational wave strain into detector data
>  *
>  * ### Synopsis
>  *
>  *     lalsim-inject [options] targetfile injectfile1 [injectfile2 ...]
>  *
>  * ### Description
>  *
>  * The `lalsim-inject` utility takes gravitational wave detector data
>  * contained in `targetfile` and adds to it the gravitational wave
>  * induced strain data in `injectfile1` ....  The result is written
>  * to standard output.  All input and output is two-column ascii format
>  * data where the first column contains the GPS timestamp of each sample
>  * and the second column contains the detector strain value.
>  *
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`    <DD>print a help message and exit</DD>
>  * <DT>`-v`, `--verbose` <DD>verbose output</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-inject`.  Common values are: `LAL_DEBUG_LEVEL=0` which suppresses
>  * error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages alone,
>  * `LAL_DEBUG_LEVEL=3` which prints both error messages and warning messages,
>  * and `LAL_DEBUG_LEVEL=7` which additionally prints informational messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-inject` utility exits 0 on success, and >0 if an error occurs.
>  *
>  * ### Example
>  *
>  * The following set of commands produces 16 seconds of simulated detector
>  * noise for the LHO detector starting at GPS time 1000000000; produces a
>  * synthetic binary neutron star signal in the LHO detector that has a
>  * geocentric end time of 1000000008; and adds the signal to the noise:
>  *
>  *
>  *     lalsim-detector-noise --aligo-zerodet-highpower -s 1000000000 -t 16 > noise
>  *     lalsim-inspiral | lalsim-detector-strain -D H1 -a 1:23:45 -d 45.0 -p 30.0 -t 1000000008 > signal
>  *     lalsim-inject noise signal > output
>  *
>  * The resulting file `output` contains the simulated signal contained in file
>  * `signal` injected into the simulated noise contained in file `noise`.
>  */
> 
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: inject.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/inspiral.c ./inspiral.c
19a20,160
> /**
>  * @defgroup lalsim_inspiral lalsim-inspiral
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Simulates a gravitational waveform from binary inspiral
>  *
>  * ### Synopsis
>  *
>  *     lalsim-inspiral [options]
>  *
>  * ### Description
>  *
>  * The `lalsim-inspiral` utility produces a stream of a simulated
>  * gravitational waveform from a binary inspiral.  The output data is
>  * the gravitational waveform polarizations in the time domain, or
>  * in the frequency domain if the `-F` option is specified.  If the
>  * option `-Q` is specified, the output data is in amplitude and phase.
>  * This program uses XLALSimInspiralChooseTDWaveform() or
>  * XLALSimInspiralChooseFDWaveform() unless the `-c` waveform contitioning
>  * option is given, in which case it uses XLALSimInspiralTD() or
>  * XLALSimInspiralFD().  The output is written to standard output as a
>  * multicolumn ascii format.  The first column gives the time or frequency
>  * corresponding to each sample and the remaining columns give the
>  * gravitational waveform values for the two polarizations (real and
>  * imaginary parts, or amplitude and phase when complex).
>  *
>  * ### Options
>  * [default values in brackets]
>  *
>  * <DL>
>  * <DT>`-h`, `--help`
>  * <DD>print a help message and exit</DD>
>  * <DT>`-v`, `--verbose`
>  * <DD>verbose output</DD>
>  * <DT>`-F`, `--frequency-domain`
>  * <DD>output data in frequency domain</DD>
>  * <DT>`-c`, `--condition-waveform`
>  * <DD>apply waveform conditioning</DD>
>  * <DT>`-Q`, `--amp-phase`
>  * <DD>output data as amplitude and phase</DD>
>  * <DT>`-a` APPROX, `--approximant=`APPROX 
>  * <DD>approximant [TaylorT1]</DD>
>  * <DT>`-w` WAVEFORM, `--waveform=`WAVEFORM 
>  * <DD>waveform string giving both approximant and order</DD>
>  * <DT>`-D` domain, `--domain=`DOMAIN      
>  * <DD>domain for waveform generation when both are available {"time", "freq"}
>  * [use natural domain for output]</DD>
>  * <DT>`-O` PHASEO, `--phase-order=`PHASEO 
>  * <DD>twice pN order of phase (-1 == highest) [-1]</DD>
>  * <DT>`-o` AMPO, `--amp-order=`AMPO       
>  * <DD>twice pN order of amplitude (-1 == highest) [0]</DD>
>  * <DT>`-q` PHIREF, `--phiRef=`PHIREF      
>  * <DD>reference phase in degrees [0]</DD>
>  * <DT>`-R` SRATE, `--sample-rate=`SRATE   
>  * <DD>sample rate in Hertz [16384]</DD>
>  * <DT>`-M` M1, `--m1=`M1                  
>  * <DD>mass of primary in solar masses [1.4]</DD>
>  * <DT>`-m` M2, `--m2=`M2                  
>  * <DD>mass of secondary in solar masses [1.4]</DD>
>  * <DT>`-d` D, `--distance=`D              
>  * <DD>distance in Mpc [1]</DD>
>  * <DT>`-i` IOTA, `--inclination=`IOTA     
>  * <DD>inclination in degrees [0]</DD>
>  * <DT>`-X` S1X, `--spin1x=`S1X            
>  * <DD>x-component of dimensionless spin of primary [0]</DD>
>  * <DT>`-Y` S1Y, `--spin1y=`S1Y            
>  * <DD>y-component of dimensionless spin of primary [0]</DD>
>  * <DT>`-Z` S1Z, `--spin1z=`S1Z            
>  * <DD>z-component of dimensionless spin of primary [0]</DD>
>  * <DT>`-x` S2X, `--spin2x=`S2X            
>  * <DD>x-component of dimensionless spin of secondary [0]</DD>
>  * <DT>`-y` S2Y, `--spin2y=`S2Y            
>  * <DD>y-component of dimensionless spin of secondary [0]</DD>
>  * <DT>`-z` S2Z, `--spin2z=`S2Z            
>  * <DD>z-component of dimensionless spin of secondary [0]</DD>
>  * <DT>`-L` LAM1, `--tidal-lambda1=`LAM1   
>  * <DD>dimensionless tidal deformability of primary [0]</DD>
>  * <DT>`-l` LAM2, `--tidal-lambda2=`LAM2   
>  * <DD>dimensionless tidal deformability of secondary [0]</DD>
>  * <DT>`-s` SPINO, `--spin-order=`SPINO    
>  * <DD>twice pN order of spin effects (-1 == all) [-1]</DD>
>  * <DT>`-t` TIDEO, `--tidal-order=`TIDEO   
>  * <DD>twice pN order of tidal effects (-1 == all) [-1]</DD>
>  * <DT>`-f` FMIN, `--f-min=`FMIN           
>  * <DD>frequency to start waveform in Hertz [40]</DD>
>  * <DT>`-r` FREF, `--fRef=`FREF            
>  * <DD>reference frequency in Hertz [0]</DD>
>  * <DT>`-A` AXIS, `--axis=`AXIS            
>  * <DD>axis for PhenSpin {View, TotalJ, OrbitalL} [OrbitalL]</DD>
>  * <DT>`-n` MODES, `--modes=`MODES         
>  * <DD>allowed l modes {L2, L23, ..., ALL} [L2]</DD>
>  * <DT>`-p` KEY1`=`VAL1`,`KEY2`=`VAL2,...,
>  * `--nonGRpar=`KEY1`=`VAL1`,`KEY2`=`VAL2,...</DT>
>  * <DD>extra parameters as a key-value pair</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-inspiral`.  Common values are: `LAL_DEBUG_LEVEL=0` which suppresses
>  * error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages alone,
>  * `LAL_DEBUG_LEVEL=3` which prints both error messages and warning messages,
>  * and `LAL_DEBUG_LEVEL=7` which additionally prints informational messages.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-inspiral` utility exits 0 on success, and >0 if an error occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-inspiral --approx=TaylorT3
>  *
>  * produces a three-column ascii output to standard output; the rows are
>  * samples (at the default rate of 16384 Hz), and the three columns are 1. the
>  * time of each sample, 2. the plus-polarization strain, and 3.  the
>  * cross-polarization strain.  The waveform produced is for the TaylorT3
>  * post-Newtonian approximant for the default parameters of a 1.4 solar mass +
>  * 1.4 solar mass binary inspiral at 1 Mpc distance.
>  *
>  * The command:
>  *
>  *     lalsim-inspiral --m1=10 --m2=10 --approx=TaylorF2 --frequency-domain
>  *
>  * produces a frequency-domain waveform for a 10 solar mass + 10 solar mass
>  * binary inspiral at 1 Mpc distance using the TaylorF2 approximant.  The five
>  * columns written to standard output are the frequency of each sample, the
>  * real part of the plus-polarization, the imaginary part of the
>  * plus-polarization, the real part of the cross-polarization, and the
>  * imaginary part of the cross-polarization.
>  *
>  * The command:
>  *
>  *     lalsim-inspiral --m1=10 --m2=10 --approx=TaylorF2 --condition
>  *
>  * produces the same waveform as in the previous example, but in the
>  * time domain and conditioned so that it is suitable for injection
>  * into detector data.
>  */
> 
549c690
<     fprintf(stderr, "\t-d domain, --domain=DOMAIN      \n\t\tdomain for waveform generation when both are available\n\t\t{\"time\", \"freq\"} [use natural domain for output]\n");
---
>     fprintf(stderr, "\t-D domain, --domain=DOMAIN      \n\t\tdomain for waveform generation when both are available\n\t\t{\"time\", \"freq\"} [use natural domain for output]\n");
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: inspiral.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-bh-qnmode
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-bh-ringdown
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-bh-sphwf
Binary files /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimBlackHoleRingdown.o and ./LALSimBlackHoleRingdown.o differ
Only in .: LALSimBlackHoleRingdownPrec.c
Only in .: LALSimBlackHoleRingdownPrec.h
Binary files /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimBurstImg.o and ./LALSimBurstImg.o differ
Binary files /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimBurst.o and ./LALSimBurst.o differ
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-detector-noise
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-detector-strain
Only in .: LALSimFindAttachTime.c
Only in .: LALSimFindAttachTime.h
Only in .: LALSimIMREOBHybridRingdownPrec.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMREOBNewtonianMultipole.c ./LALSimIMREOBNewtonianMultipole.c
148,188d147
< 
< UNUSED static int
< XLALSimIMRTNSEOBCalculateNewtonianMultipole(
<                  COMPLEX16 *multipole, /**<< OUTPUT, Newtonian multipole */
<                  REAL8 x,              /**<< Dimensionless parameter \f$\equiv v^2\f$ */
<                  UNUSED REAL8 r,       /**<< Orbital separation (units of total mass M) */
<                  REAL8 phi,            /**<< Orbital phase (in radians) */
<                  UINT4  l,             /**<< Mode l */
<                  INT4  m,              /**<< Mode m */
<                  TNSEOBParams *params     /**<< Pre-computed coefficients, parameters, etc. */
<                  )
< {
< 
<    INT4 xlalStatus;
< 
<    COMPLEX16 y;
< 
<    INT4 epsilon = (l + m) % 2;
< 
<    y = 0.0;
< 
<   /* Calculate the necessary Ylm */
<   xlalStatus = XLALScalarSphHarmThetaPiBy2( &y, l - epsilon, - m, phi );
<   if (xlalStatus != XLAL_SUCCESS )
<   {
<     XLAL_ERROR( XLAL_EFUNC );
<   }
< 
<   /* IN TNS EOB there is no Special treatment for (2,1) and (4,4) modes, defined in Eq. 17ab of PRD84:124052 2011 */
<   
<     *multipole = params->prefixes->values[l][m] * pow( x, (REAL8)(l+epsilon)/2.0);
<  
<     *multipole *= y;
< 
<   return XLAL_SUCCESS;
< }
< 
< 
< 
< 
< 
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMREOBNRv2.c ./LALSimIMREOBNRv2.c
1680a1681,1682
>  * 
>  * @review EOBNRv2 reviewed by Ilya Mandel, Riccardo Sturani, Prayush Kumar, John Whelan, Yi Pan. Review concluded with git hash b29f20ff11e62095dbd44e850b248ecc58b08a13 (April 2013).
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMREOBNRv2.h ./LALSimIMREOBNRv2.h
2c2
< *  Copyright (C) 2010 Craig Robinson 
---
> *  Copyright (C) 2010 Craig Robinson
444a445
>   UINT4 omegaPeaked;
480,685d480
<   
< } pr3In;
< 
< 
< typedef struct
< tagTNSFacWaveformCoeffs
< {
<   REAL8 delta22vh3;
<   REAL8 delta22vh6;
<   REAL8 delta22vh6S;
<   REAL8 delta22v8;
<   REAL8 delta22v8S;
<   REAL8 delta22vh9;
<   REAL8 delta22v5;
<   REAL8 delta22v6;
<   REAL8 delta22v6S;
< 
<   REAL8 rho22v2;
<   REAL8 rho22v3;
<   REAL8 rho22v3S;
<   REAL8 rho22v4;
<   REAL8 rho22v4S;
<   REAL8 rho22v5;
<   REAL8 rho22v5S;
<   REAL8 rho22v6;
<   REAL8 rho22v6S;
<   REAL8 rho22v6l;
<   REAL8 rho22v7;
<   REAL8 rho22v7S;
<   REAL8 rho22v8;
<   REAL8 rho22v8S;
<   REAL8 rho22v8l;
<   REAL8 rho22v10;
<   REAL8 rho22v10l;
< 
<   REAL8 delta21vh3;
<   REAL8 delta21vh6;
<   REAL8 delta21vh6S;
<   REAL8 delta21vh7;
<   REAL8 delta21vh7S;
<   REAL8 delta21vh9;
<   REAL8 delta21v5;
<   REAL8 delta21v7;
< 
<   REAL8 rho21v1;
<   REAL8 rho21v2;
<   REAL8 rho21v2S;
<   REAL8 rho21v3;
<   REAL8 rho21v3S;
<   REAL8 rho21v4;
<   REAL8 rho21v4S;
<   REAL8 rho21v5;
<   REAL8 rho21v5S;
<   REAL8 rho21v6;
<   REAL8 rho21v6S;
<   REAL8 rho21v6l;
<   REAL8 rho21v7;
<   REAL8 rho21v7S;
<   REAL8 rho21v7l;
<   REAL8 rho21v7lS;
<   REAL8 rho21v8;
<   REAL8 rho21v8l;
<   REAL8 rho21v10;
<   REAL8 rho21v10l;
< 
<   REAL8 f21v1;
<   REAL8 f21v1S;
<   REAL8 f21v3;
<   REAL8 f21v3S;
< 
<   REAL8 delta33vh3;
<   REAL8 delta33vh6;
<   REAL8 delta33vh6S;
<   REAL8 delta33vh9;
<   REAL8 delta33v5;
<   REAL8 delta33v7;
< 
<   REAL8 rho33v2;
<   REAL8 rho33v3;
<   REAL8 rho33v4;
<   REAL8 rho33v4S;
<   REAL8 rho33v5;
<   REAL8 rho33v5S;
<   REAL8 rho33v6;
<   REAL8 rho33v6S;
<   REAL8 rho33v6l;
<   REAL8 rho33v7;
<   REAL8 rho33v7S;
<   REAL8 rho33v8;
<   REAL8 rho33v8l;
< 
<   REAL8 f33v3;
<   REAL8 f33v3S;
< 
<   REAL8 delta32vh3;
<   REAL8 delta32vh4;
<   REAL8 delta32vh4S;
<   REAL8 delta32vh6;
<   REAL8 delta32vh6S;
<   REAL8 delta32vh9;
< 
<   REAL8 rho32v;
<   REAL8 rho32vS;
<   REAL8 rho32v2;
<   REAL8 rho32v2S;
<   REAL8 rho32v3;
<   REAL8 rho32v3S;
<   REAL8 rho32v4;
<   REAL8 rho32v4S;
<   REAL8 rho32v5;
<   REAL8 rho32v5S;
<   REAL8 rho32v6;
<   REAL8 rho32v6S;
<   REAL8 rho32v6l;
<   REAL8 rho32v8;
<   REAL8 rho32v8l;
< 
<   REAL8 delta31vh3;
<   REAL8 delta31vh6;
<   REAL8 delta31vh6S;
<   REAL8 delta31vh7;
<   REAL8 delta31vh7S;
<   REAL8 delta31vh9;
<   REAL8 delta31v5;
< 
<   REAL8 rho31v2;
<   REAL8 rho31v3;
<   REAL8 rho31v4;
<   REAL8 rho31v4S;
<   REAL8 rho31v5;
<   REAL8 rho31v5S;
<   REAL8 rho31v6;
<   REAL8 rho31v6S;
<   REAL8 rho31v6l;
<   REAL8 rho31v7;
<   REAL8 rho31v7S;
<   REAL8 rho31v8;
<   REAL8 rho31v8l;
< 
<   REAL8 f31v3;
<   REAL8 f31v3S;
< 
<   REAL8 delta44vh3;
<   REAL8 delta44vh6;
<   REAL8 delta44vh6S;
<   REAL8 delta44v5;
< 
<   REAL8 rho44v2;
<   REAL8 rho44v3;
<   REAL8 rho44v3S;
<   REAL8 rho44v4;
<   REAL8 rho44v4S;
<   REAL8 rho44v5;
<   REAL8 rho44v5S;
<   REAL8 rho44v6;
<   REAL8 rho44v6S;
<   REAL8 rho44v6l;
< 
<   REAL8 delta43vh3;
<   REAL8 delta43vh4;
<   REAL8 delta43vh4S;
<   REAL8 delta43vh6;
< 
<   REAL8 rho43v;
<   REAL8 rho43v2;
<   REAL8 rho43v4;
<   REAL8 rho43v4S;
<   REAL8 rho43v5;
<   REAL8 rho43v5S;
<   REAL8 rho43v6;
<   REAL8 rho43v6l;
< 
<   REAL8 f43v;
<   REAL8 f43vS;
< 
<   REAL8 delta42vh3;
<   REAL8 delta42vh6;
<   REAL8 delta42vh6S;
< 
<   REAL8 rho42v2;
<   REAL8 rho42v3;
<   REAL8 rho42v3S;
<   REAL8 rho42v4;
<   REAL8 rho42v4S;
<   REAL8 rho42v5;
<   REAL8 rho42v5S;
<   REAL8 rho42v6;
<   REAL8 rho42v6S;
<   REAL8 rho42v6l;
< 
<   REAL8 delta41vh3;
<   REAL8 delta41vh4;
<   REAL8 delta41vh4S;
<   REAL8 delta41vh6;
< 
<   REAL8 rho41v;
<   REAL8 rho41v2;
<   REAL8 rho41v4;
<   REAL8 rho41v4S;
<   REAL8 rho41v5;
<   REAL8 rho41v5S;
<   REAL8 rho41v6;
<   REAL8 rho41v6l;
< 
<   REAL8 f41v;
<   REAL8 f41vS;
687,929c482
<   REAL8 delta55vh3;
<   REAL8 delta55v5;
<   REAL8 rho55v2;
<   REAL8 rho55v3;
<   REAL8 rho55v3S;
<   REAL8 rho55v4;
<   REAL8 rho55v4S;
<   REAL8 rho55v5;
<   REAL8 rho55v5S;
<   REAL8 rho55v6;
< 
<   REAL8 delta54vh3;
<   REAL8 delta54vh4;
<   REAL8 delta54vh4S;
<   REAL8 rho54v2;
<   REAL8 rho54v3;
<   REAL8 rho54v3S;
<   REAL8 rho54v4;
<   REAL8 rho54v4S;
< 
<   REAL8 delta53vh3;
<   REAL8 rho53v2;
<   REAL8 rho53v3;
<   REAL8 rho53v3S;
<   REAL8 rho53v4;
<   REAL8 rho53v4S;
<   REAL8 rho53v5;
<   REAL8 rho53v5S;
< 
<   REAL8 delta52vh3;
<   REAL8 delta52vh4;
<   REAL8 delta52vh4S;
<   REAL8 rho52v2;
<   REAL8 rho52v3;
<   REAL8 rho52v3S;
<   REAL8 rho52v4;
<   REAL8 rho52v4S;
< 
<   REAL8 delta51vh3;
<   REAL8 rho51v2;
<   REAL8 rho51v3;
<   REAL8 rho51v3S;
<   REAL8 rho51v4;
<   REAL8 rho51v4S;
<   REAL8 rho51v5;
<   REAL8 rho51v5S;
< 
<   REAL8 delta66vh3;
<   REAL8 rho66v2;
<   REAL8 rho66v3;
<   REAL8 rho66v3S;
<   REAL8 rho66v4;
<   REAL8 rho66v4S;
< 
<   REAL8 delta65vh3;
<   REAL8 rho65v2;
<   REAL8 rho65v3;
<   REAL8 rho65v3S;
< 
<   REAL8 delta64vh3;
<   REAL8 rho64v2;
<   REAL8 rho64v3;
<   REAL8 rho64v3S;
<   REAL8 rho64v4;
<   REAL8 rho64v4S;
< 
<   REAL8 delta63vh3;
<   REAL8 rho63v2;
<   REAL8 rho63v3;
<   REAL8 rho63v3S;
< 
<   REAL8 delta62vh3;
<   REAL8 rho62v2;
<   REAL8 rho62v3;
<   REAL8 rho62v3S;
<   REAL8 rho62v4;
<   REAL8 rho62v4S;
< 
<   REAL8 delta61vh3;
<   REAL8 rho61v2;
<   REAL8 rho61v3;
<   REAL8 rho61v3S;
< 
<   REAL8 delta77vh3;
<   REAL8 rho77v2;
<   REAL8 rho77v3;
<   REAL8 rho77v3S;
< 
<   REAL8 rho76v2;
< 
<   REAL8 delta75vh3;
<   REAL8 rho75v2;
<   REAL8 rho75v3;
<   REAL8 rho75v3S;
< 
<   REAL8 rho74v2;
< 
<   REAL8 delta73vh3;
<   REAL8 rho73v2;
<   REAL8 rho73v3;
<   REAL8 rho73v3S;
< 
<   REAL8 rho72v2;
< 
<   REAL8 delta71vh3;
<   REAL8 rho71v2;
<   REAL8 rho71v3;
<   REAL8 rho71v3S;
< 
<   REAL8 rho88v2;
<   REAL8 rho87v2;
<   REAL8 rho86v2;
<   REAL8 rho85v2;
<   REAL8 rho84v2;
<   REAL8 rho83v2;
<   REAL8 rho82v2;
<   REAL8 rho81v2;
< 
< 
<   REAL8 rho33v10;
<   REAL8 rho33v10l;
<   REAL8 rho31v10;
<   REAL8 rho31v10l;
<   REAL8 rho44v8;
<   REAL8 rho44v8l;
<  // REAL8 rho43v6;
<  // REAL8 rho43v6l;
<   REAL8 rho43v8;
<   REAL8 rho43v8l;
<   REAL8 rho42v8;
<   REAL8 rho42v8l;
<   REAL8 rho41v8;
<   REAL8 rho41v8l;
<   //REAL8 rho55v6;
<   REAL8 rho55v6l;
<   REAL8 rho55v8;
<   REAL8 rho55v8l;
<   REAL8 rho54v6;
<   REAL8 rho54v6l;
<   REAL8 rho53v6;
<   REAL8 rho53v6l;
<   REAL8 rho53v8l;
<   REAL8 rho53v8;
<   REAL8 rho52v6l;
<   REAL8 rho52v6;
<   REAL8 rho51v6l;
<   REAL8 rho51v6;
<   REAL8 rho51v8l;
<   REAL8 rho51v8;
<   REAL8 rho66v6l;
<   REAL8 rho66v6;
<   REAL8 rho65v4;
<   REAL8 rho65v6;
<   REAL8 rho65v6l;
<   //REAL8 rho65v6;
<   REAL8 rho64v6l;
<   REAL8 rho64v6;
<   REAL8 rho63v4;
<   REAL8 rho63v6l;
<   REAL8 rho63v6;
<   REAL8 rho62v6l;
<   REAL8 rho62v6;
<   REAL8 rho61v6;
<   REAL8 rho61v6l;
<   REAL8 rho61v4;
<    REAL8 rho77v6;
<   REAL8 rho77v6l;
<   REAL8 rho77v4;
<  REAL8 rho76v4;
<  REAL8 rho75v6;
<   REAL8 rho75v6l;
<   REAL8 rho75v4;
< REAL8 rho74v4;
<  REAL8 rho73v6;
<   REAL8 rho73v6l;
<   REAL8 rho73v4;
< REAL8 rho72v4;
<  REAL8 rho71v6;
<   REAL8 rho71v6l;
<   REAL8 rho71v4;
<  REAL8 rho81v4;
<  REAL8 rho82v4;
< REAL8 rho83v4;
< REAL8 rho84v4;
< REAL8 rho85v4;
< REAL8 rho86v4;
< REAL8 rho87v4;
< REAL8 rho88v4;
< }
< TNSFacWaveformCoeffs;
< 
< /**
<  * Structure containing all the terms of the Newtonian multipole which
<  * are constant over the course of the evolution, and can therefore be
<  * pre-computed. They are stored in a two-dimensional array, which is
<  * indexed as values[l][m]. Since m has to be <= l, this structure
<  * is larger than it needs to be; but it makes the coding a bit neater...
<  */
< 
< 
< 
< typedef
< struct tagTNSEOBParams
< {
<   REAL8 eta;
<   REAL8 omega;
<   REAL8 mass1;
<   REAL8 mass2;
<   REAL8 lambda1;
<   REAL8 lambda2;
<   //EOBACoefficients        *aCoeffs;
<   TNSFacWaveformCoeffs       *hCoeffs;
<   EOBNonQCCoeffs          *nqcCoeffs;
<   NewtonMultipolePrefixes *prefixes;
< }TNSEOBParams;
< 
< /**
<  * Structure containing parameters used to determine
<  * r as a function of omega. Since this is determined within
<  * a root finding function, it is necessary to place all parameters
<  * with the exception of the current guess of the radius within
<  * a structure.
<  */
< 
< 
< /**
<  * Structure containing parameters used to determine the initial radial
<  * momentum. Since this is determined within a root finding function,
<  * it is necessary to place all parameters with the exception of the
<  * current guess of the radial momentum within a structure.
<  */
< typedef struct tagTNSPr3In {
<   REAL8 eta;   
<   REAL8 mass1;
<   REAL8 mass2;
<   REAL8 lambda1;
<   REAL8 lambda2;              /**<< Symmetric mass ratio */
<   REAL8 omega;               /**<< Angular frequency (dimensionless combination M omega) */
<   REAL8 vr;                  /**<< Radial velocity (dimensionless) */
<   REAL8 r;                   /**<< Orbital separation (units of total mass) */
<   REAL8 q;                   /**<< Momentum pphi */
<   
< } TNSPr3In;
---
> } pr3In;
Only in .: LALSimIMREOBNRv2HMROM.c
Only in .: LALSimIMREOBNRv2HMROMUtilities.c
Binary files /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMREOBNRv2.o and ./LALSimIMREOBNRv2.o differ
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMR.h ./LALSimIMR.h
25a26,29
> #ifdef LAL_HDF5_ENABLED
> #include <lal/H5FileIO.h>
> #endif
> 
42,45c46,47
<  * @defgroup LALSimIMRSEOBNRv1ROMEffectiveSpin_c LALSimIMRSEOBNRv1ROMEffectiveSpin.c
<  * @defgroup LALSimIMRSEOBNRv1ROMDoubleSpin_c    LALSimIMRSEOBNRv1ROMDoubleSpin.c
<  * @defgroup LALSimIMRSEOBNRv2ROMEffectiveSpin_c LALSimIMRSEOBNRv2ROMEffectiveSpin.c
<  * @defgroup LALSimIMRSEOBNRv2ROMDoubleSpin_c    LALSimIMRSEOBNRv2ROMDoubleSpin.c
---
>  * @defgroup LALSimIMRSpinPrecEOB_c           LALSimIMRSpinPrecEOB.c
>  * @defgroup LALSimIMRSEOBNRROM_c                LALSimIMRSEOBNRvxROMXXX.c
59a62,66
> typedef enum {
>  IMRPhenomPv1_V, /**< version 1: based on IMRPhenomC */
>  IMRPhenomPv2_V  /**< version 2: based on IMRPhenomD */
> } IMRPhenomP_version_type;
> 
76,79c83,92
< int XLALSimIMRPhenomDGenerateFD(COMPLEX16FrequencySeries **htilde, const REAL8 phi0, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 chi1, const REAL8 chi2, const REAL8 f_min, const REAL8 f_max, const REAL8 distance);
< int XLALSimIMRPhenomP(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8 chi_eff, const REAL8 chip, const REAL8 eta, const REAL8 thetaJ, const REAL8 Mtot_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 deltaF, const REAL8 f_min, const REAL8 f_max, const REAL8 f_ref);
< int XLALSimIMRPhenomPFrequencySequence(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, const REAL8 chi_eff, const REAL8 chip, const REAL8 eta, const REAL8 thetaJ, const REAL8 Mtot_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 f_ref);
< int XLALSimIMRPhenomPCalculateModelParameters(REAL8 *chi_eff, REAL8 *chip, REAL8 *eta, REAL8 *thetaJ, REAL8 *alpha0, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 f_ref, const REAL8 lnhatx, const REAL8 lnhaty, const REAL8 lnhatz, const REAL8 s1x, const REAL8 s1y, const REAL8 s1z, const REAL8 s2x, const REAL8 s2y, const REAL8 s2z);
---
> 
> /* in module LALSimIMRPhenomD.c */
> int XLALSimIMRPhenomDGenerateFD(COMPLEX16FrequencySeries **htilde, const REAL8 phi0, const REAL8 fRef, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 chi1, const REAL8 chi2, const REAL8 f_min, const REAL8 f_max, const REAL8 distance);
> double XLALIMRPhenomDGetPeakFreq(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in);
> 
> 
> int XLALSimIMRPhenomP(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 deltaF, const REAL8 f_min, const REAL8 f_max, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version);
> int XLALSimIMRPhenomPFrequencySequence(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version);
> int XLALSimIMRPhenomPCalculateModelParameters(REAL8 *chi1_l, REAL8 *chi2_l, REAL8 *chip, REAL8 *thetaJ, REAL8 *alpha0, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 f_ref, const REAL8 lnhatx, const REAL8 lnhaty, const REAL8 lnhatz, const REAL8 s1x, const REAL8 s1y, const REAL8 s1z, const REAL8 s2x, const REAL8 s2y, const REAL8 s2z, IMRPhenomP_version_type IMRPhenomP_version);
> 
86a100
> 
90a105
> 
95c110,152
< //int XLALSimIMRSpinEOBWaveform(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, const REAL8 phiC, const REAL8 deltaT, const REAL8 m1SI, const REAL8 m2SI, const REAL8 fMin, const REAL8 r, const REAL8 inc, const REAL8 spin1[], const REAL8 spin2[]);
---
> /*int XLALSimIMRSpinEOBWaveform(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, const REAL8 phiC, const REAL8 deltaT, const REAL8 m1SI, const REAL8 m2SI, const REAL8 fMin, const REAL8 r, const REAL8 inc, const REAL8 spin1[], const REAL8 spin2[]);
>  */
> 
> /* in module LALSimIMRSpinPrecEOB.c */
> int XLALSimIMRSpinEOBWaveform(
>                               REAL8TimeSeries **hplus,
>                               REAL8TimeSeries **hcross,
>                               const REAL8     phiC,
>                               const REAL8     deltaT,
>                               const REAL8     m1SI,
>                               const REAL8     m2SI,
>                               const REAL8     fMin,
>                               const REAL8     r,
>                               const REAL8     inc,
>                               const REAL8     spin1[],
>                               const REAL8     spin2[]
>                               );
> 
> int XLALSimIMRSpinEOBWaveformAll(
>                                  REAL8TimeSeries **hplus,
>                                  REAL8TimeSeries **hcross,
>                                  REAL8Vector     **dynamicsHi,
>                                  SphHarmTimeSeries **hlmPTSout,
>                                  SphHarmTimeSeries **hlmPTSHi,
>                                  SphHarmTimeSeries **hIMRlmJTSHi,
>                                  SphHarmTimeSeries **hIMRoutput,
>                                  REAL8Vector     **AttachParams,
>                                  const REAL8      phiC,
>                                  const REAL8     deltaT,
>                                  const REAL8     m1SI,
>                                  const REAL8     m2SI,
>                                  const REAL8     fMin,
>                                  const REAL8     r,
>                                  const REAL8     inc,
>                                  const REAL8     INspin1x,
>                                  const REAL8     INspin1y,
>                                  const REAL8     INspin1z,
>                                  const REAL8     INspin2x,
>                                  const REAL8     INspin2y,
>                                  const REAL8     INspin2z
>                                  );
> 
> /* in module LALSimIMREOBNRv2HMROM.c */
96a154
> int XLALSimIMREOBNRv2HMROM(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI,  REAL8 m2SI, const int higherModesFlag);
124a183,190
> /* in module LALSimIMRSEOBNRv2ROMDoubleSpinHI.c */
> 
> int XLALSimIMRSEOBNRv2ROMDoubleSpinHI(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, UINT4 nk_max);
> int XLALSimIMRSEOBNRv2ROMDoubleSpinHIFrequencySequence(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, REAL8 phiRef, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, UINT4 nk_max);
> int XLALSimIMRSEOBNRv2ROMDoubleSpinHITimeOfFrequency(REAL8 *t, REAL8 frequency, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
> int XLALSimIMRSEOBNRv2ROMDoubleSpinHIFrequencyOfTime(REAL8 *frequency, REAL8 t, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
> 
> 
132,134c198,222
< int XLALSimIMRPhenSpinFinalMassSpin(REAL8 *finalMass, REAL8 *finalSpin, REAL8 m1, REAL8 m2, REAL8 s1s1, REAL8 s2s2, REAL8 s1L, REAL8 s2L, REAL8 s1s2, REAL8 energy); 
< int XLALSimSpinInspiralGenerator(REAL8TimeSeries **hPlus, REAL8TimeSeries **hCross, REAL8 phi_start, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 iota, REAL8 s1x, REAL8 s1y, REAL8 s1z, REAL8 s2x, REAL8 s2y, REAL8 s2z, int phaseO, int ampO, LALSimInspiralWaveformFlags *waveFlags, LALSimInspiralTestGRParam *testGRparams);
< int XLALSimIMRPhenSpinInspiralRDGenerator(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, REAL8 phi0, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 iota, REAL8 s1x, REAL8 s1y, REAL8 s1z, REAL8 s2x, REAL8 s2y, REAL8 s2z, int phaseO, int ampO, LALSimInspiralWaveformFlags *waveFlag, LALSimInspiralTestGRParam *testGRparam);
---
> int XLALSimIMRPhenSpinFinalMassSpin(REAL8 *finalMass, REAL8 *finalSpin, REAL8 m1, REAL8 m2, REAL8 s1s1, REAL8 s2s2, REAL8 s1L, REAL8 s2L, REAL8 s1s2, REAL8 energy);
> int XLALSimSpinInspiralGenerator(REAL8TimeSeries **hPlus, REAL8TimeSeries **hCross, REAL8 phi_start, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 iota, REAL8 s1x, REAL8 s1y, REAL8 s1z, REAL8 s2x, REAL8 s2y, REAL8 s2z, int phaseO, int ampO, REAL8 lambda1, REAL8 lambda2, REAL8 quadparam1, REAL8 quadparam2, LALSimInspiralWaveformFlags *waveFlags, LALSimInspiralTestGRParam *testGRparams);
> int XLALSimIMRPhenSpinInspiralRDGenerator(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, REAL8 phi0, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 iota, REAL8 s1x, REAL8 s1y, REAL8 s1z, REAL8 s2x, REAL8 s2y, REAL8 s2z, int phaseO, int ampO, REAL8 lambda1, REAL8 lambda2, REAL8 quadparam1, REAL8 quadparam2, LALSimInspiralWaveformFlags *waveFlag, LALSimInspiralTestGRParam *testGRparam);
> 
> /* in module LALSimInspiralNRWaveforms.c */
> 
> int XLALSimInspiralNRWaveformGetHplusHcross(
>         REAL8TimeSeries **hplus,        /**< OUTPUT h_+ vector */
>         REAL8TimeSeries **hcross,       /**< OUTPUT h_x vector */
>         REAL8 phiRef,                   /**< orbital phase at reference pt. */
>         REAL8 inclination,              /**< inclination angle */
>         REAL8 deltaT,                   /**< sampling interval (s) */
>         REAL8 m1,                       /**< mass of companion 1 (kg) */
>         REAL8 m2,                       /**< mass of companion 2 (kg) */
>         REAL8 r,                        /**< distance of source (m) */
>         REAL8 fStart,                   /**< start GW frequency (Hz) */
>         REAL8 fRef,                     /**< reference GW frequency (Hz) */
>         REAL8 s1x,                      /**< initial value of S1x */
>         REAL8 s1y,                      /**< initial value of S1y */
>         REAL8 s1z,                      /**< initial value of S1z */
>         REAL8 s2x,                      /**< initial value of S2x */
>         REAL8 s2y,                      /**< initial value of S2y */
>         REAL8 s2z,                      /**< initial value of S2z */
>         const char *NRDataFile          /**< Location of NR HDF file */
>         );
Only in .: LALSimIMRNRWaveforms.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenom.c ./LALSimIMRPhenom.c
282,283c282,283
<  * Find a higher value of f_max so that we can safely apply a window later. 
<  * The safety factor 1.025 is an empirical estimation 
---
>  * Find a higher value of f_max so that we can safely apply a window later.
>  * The safety factor 1.025 is an empirical estimation
631c631
< /* Apply the inclination-angle weighting to the two polarizations 
---
> /* Apply the inclination-angle weighting to the two polarizations
633c633
< * Physics, Astrophysics and Cosmology with Gravitational Waves, 
---
> * Physics, Astrophysics and Cosmology with Gravitational Waves,
1194c1194,1220
<  * @review IMRPhenomB routines reviewed on YYYY-MM-DD by XXX (hash).
---
>  *
>  * These are frequency-domain models for compact binaries at comparable masses,
>  * tuned to numerical-relativity simulations.
>  *  * IMRPhenomA models non-spinning binaries.
>  *  * IMRPhenomB/C/D model spinning, but non-precessing binaries.
>  *    IMRPhenomD is the most up-to-date model and should be used
>  *    unless there are specific reasons to use an older version.
>  *  * IMRPhenomP models precessing binaries,
>  *    IMRPhenomP based on IMRPhenomC
>  *    (outdated)
>  *  * IMRPhenomPv2 models precessing binaries,
>  *    based on IMRPhenomD
>  *    (should be used instead of IMRPhenomP,
>  *    unless there are good reasons not to).
>  *
>  * @review IMRPhenomB routines reviewed by Frank Ohme, P. Ajith, Alex Nitz
>  * and Riccardo Sturani. The review concluded with git hash
>  * 43ce3b0a8753eb266d75a43ba94b6fb6412121d0 (May 2014).
>  *
>  * @review IMRPhenomD routines reviewed by Alex Nielsen, Carl Haster,
>  * Sebastian Khan, Sascha Husa, Frank Ohme, Mark Hannam, Ofek Brinholtz, Lionel London and
>  * David Keitel.
>  * The review concluded with git hash
>  * db16d17013531cd10451c7d0c6906972ce731866 (Oct/Nov 2015).
>  *
>  * @review original IMRPhenomP not reviewed, nor going to be.
>  * IMRPhenomPv2 currently under review (Dec 2015).
1352c1378
<  * Compute the default final frequency 
---
>  * Compute the default final frequency
1385c1411
<  * Compute the default final frequency 
---
>  * Compute the default final frequency
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomC.c ./LALSimIMRPhenomC.c
23a24,29
> #ifdef __GNUC__
> #define UNUSED __attribute__ ((unused))
> #else
> #define UNUSED
> #endif
> 
144c150
<     size_t n_full = NextPow2(f_max / deltaF) + 1; // we actually want to have the length be a power of 2 + 1
---
>         size_t n_full = NextPow2_PC(f_max / deltaF) + 1; // we actually want to have the length be a power of 2 + 1 power of 2 + 1
328c334
<   size_t n = NextPow2(f_max / deltaF) + 1;
---
>   size_t n = NextPow2_PC(f_max / deltaF) + 1;
445c451
<   size_t n = NextPow2(f_max / deltaF) + 1;
---
>   size_t n = NextPow2_PC(f_max / deltaF) + 1;
503c509
<     const size_t nt = NextPow2(EstimateIMRLength(m1, m2, f_min_wide, deltaT));
---
>     const size_t nt = NextPow2_PC(EstimateIMRLength(m1, m2, f_min_wide, deltaT));
559c565
< 	REAL8 tau0 = deltaT * NextPow2(1.5 * EstimateIMRLength(m1, m2, f_min, deltaT));
---
> 	REAL8 tau0 = deltaT * NextPow2_PC(1.5 * EstimateIMRLength(m1, m2, f_min, deltaT));
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomC_internals.c ./LALSimIMRPhenomC_internals.c
24,121c24
< #include <math.h>
< #include <complex.h>
< 
< #include <lal/LALStdlib.h>
< #include <lal/LALSimIMR.h>
< #include <lal/LALConstants.h>
< #include <lal/Date.h>
< #include <lal/FrequencySeries.h>
< #include <lal/StringInput.h>
< #include <lal/TimeSeries.h>
< #include <lal/TimeFreqFFT.h>
< #include <lal/Units.h>
< 
< 
< /*********************************************************************/
< /* This structure stores the PN coefficients used to calculate flux  */
< /* and waveform amplitude, and Fourier phase. It also stores some    */
< /* frequently used expressions which are constant during waveform    */
< /* generation.                                                       */
< /*********************************************************************/
< 
< // MP: could we move this into the header file?
< typedef struct tagBBHPhenomCParams{
<   REAL8 piM;
<   REAL8 m_sec;
< 
<   REAL8 fmin;
<   REAL8 fCut;
<   REAL8 df;
< 
<   REAL8 f0;
<   REAL8 f1;
<   REAL8 f2;
<   REAL8 d0;
<   REAL8 d1;
<   REAL8 d2;
< 
<   REAL8 afin;
<   REAL8 fRingDown;
<   REAL8 MfRingDown;
<   REAL8 Qual;
< 
<   REAL8 pfaN;
<   REAL8 pfa2;
<   REAL8 pfa3;
<   REAL8 pfa4;
<   REAL8 pfa5;
<   REAL8 pfa6;
<   REAL8 pfa6log;
<   REAL8 pfa7;
< 
<   REAL8 xdotaN;
<   REAL8 xdota2;
<   REAL8 xdota3;
<   REAL8 xdota4;
<   REAL8 xdota5;
<   REAL8 xdota6;
<   REAL8 xdota6log;
<   REAL8 xdota7;
< 
<   REAL8 AN;
<   REAL8 A2;
<   REAL8 A3;
<   REAL8 A4;
<   REAL8 A5;
<   REAL8 A5imag;
<   REAL8 A6;
<   REAL8 A6log;
<   REAL8 A6imag;
< 
<   REAL8 a1;
<   REAL8 a2;
<   REAL8 a3;
<   REAL8 a4;
<   REAL8 a5;
<   REAL8 a6;
<   REAL8 g1;
<   REAL8 del1;
<   REAL8 del2;
<   REAL8 b1;
<   REAL8 b2;
< }
< BBHPhenomCParams;
< 
< /**
<  *
<  * private function prototypes; all internal functions use solar masses.
<  *
<  */
< 
< static BBHPhenomCParams *ComputeIMRPhenomCParamsSPA( const REAL8 m1, const REAL8 m2, const REAL8 chi );
< static BBHPhenomCParams *ComputeIMRPhenomCParams( const REAL8 m1, const REAL8 m2, const REAL8 chi );
< static REAL8 wPlus( const REAL8 f, const REAL8 f0, const REAL8 d, const BBHPhenomCParams *params );
< static REAL8 wMinus( const REAL8 f, const REAL8 f0, const REAL8 d, const BBHPhenomCParams *params );
< 
< static size_t NextPow2(const size_t n);
< static REAL8 IMRPhenomCGeneratePhasePM( REAL8 f, REAL8 eta, const BBHPhenomCParams *params );
< static int IMRPhenomCGenerateAmpPhase( REAL8 *amplitude, REAL8 *phasing, REAL8 f, REAL8 eta, const BBHPhenomCParams *params);
---
> #include "LALSimIMRPhenomC_internals.h"
405c308
< static size_t NextPow2(const size_t n) {
---
> static size_t NextPow2_PC(const size_t n) {
Only in .: LALSimIMRPhenomC_internals.h
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomC.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomC.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomD.c ./LALSimIMRPhenomD.c
2c2
<  * Copyright (C) 2015 Michael Puerrer, Sebastian Khan, Frank Ohme
---
>  * Copyright (C) 2015 Michael Puerrer, Sebastian Khan, Frank Ohme, Ofek Birnholtz, Lionel London
21d20
< 
23c22
< #include <complex.h>
---
> /*#include <complex.h>
32c31
< 
---
> */
33a33
> UsefulPowers powers_of_pi;	// declared in LALSimIMRPhenomD_internals.c
45,46c45,47
<     COMPLEX16FrequencySeries **htilde, /**< FD waveform */
<     const REAL8 phi0,                  /**< phase at peak */
---
>     COMPLEX16FrequencySeries **htilde, /**< [out] FD waveform */
>     const REAL8 phi0,                  /**< phase at fRef */
>     const REAL8 fRef,                  /**< reference frequency [Hz] */
67d67
<  * See ... for details.
69a70,72
>  * See Husa et al \cite Husa:2015iqa, and Khan et al \cite Khan:2015jqa
>  * for details. Any studies that use this waveform model should include
>  * a reference to both of these papers.
78c81
<  * @note The model is usable outside this parameter range,
---
>  * @attention The model is usable outside this parameter range,
82c85,86
<  * numerical-relativity simulations.
---
>  * numerical-relativity simulations. For more information, see the review wiki
>  * under https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview
91,92c95,96
<  * - Waveform: Eq.
<  * - Coefficients: Eq. and Table xyz
---
>  * - Waveform: Eq. 35 and 36 in arXiv:1508.07253
>  * - Coefficients: Eq. 31 and Table V in arXiv:1508.07253
97,98c101,103
<     COMPLEX16FrequencySeries **htilde, /**< FD waveform */
<     const REAL8 phi0,                  /**< Orbital phase at peak (rad) */
---
>     COMPLEX16FrequencySeries **htilde, /**< [out] FD waveform */
>     const REAL8 phi0,                  /**< Orbital phase at fRef (rad) */
>     const REAL8 fRef_in,               /**< reference frequency (Hz) */
102,103c107,108
<     const REAL8 chi1,                  /**< Aligned-spin of companion 1 */
<     const REAL8 chi2,                  /**< Aligned-spin of companion 2 */
---
>     const REAL8 chi1,                  /**< Aligned-spin parameter of companion 1 */
>     const REAL8 chi2,                  /**< Aligned-spin parameter of companion 2 */
105c110
<     const REAL8 f_max,                 /**< End frequency; 0 defaults to ringdown cutoff freq */
---
>     const REAL8 f_max,                 /**< End frequency; 0 defaults to Mf = \ref f_CUT */
111d115
<   const REAL8 q = (m1 > m2) ? (m1 / m2) : (m2 / m1);
113a118
>   XLAL_CHECK(0 != htilde, XLAL_EFAULT, "htilde is null");
115,121c120,128
<   if (deltaF <= 0) XLAL_ERROR(XLAL_EDOM);
<   if (m1 <= 0) XLAL_ERROR(XLAL_EDOM);
<   if (m2 <= 0) XLAL_ERROR(XLAL_EDOM);
<   if (fabs(chi1) > 1 || fabs(chi2) > 1) XLAL_ERROR(XLAL_EDOM);
<   if (f_min <= 0) XLAL_ERROR(XLAL_EDOM);
<   if (f_max < 0) XLAL_ERROR(XLAL_EDOM);
<   if (distance <= 0) XLAL_ERROR(XLAL_EDOM);
---
>   if (fRef_in < 0) XLAL_ERROR(XLAL_EDOM, "fRef_in must be positive (or 0 for 'ignore')\n");
>   if (deltaF <= 0) XLAL_ERROR(XLAL_EDOM, "deltaF must be positive\n");
>   if (m1 <= 0) XLAL_ERROR(XLAL_EDOM, "m1 must be positive\n");
>   if (m2 <= 0) XLAL_ERROR(XLAL_EDOM, "m2 must be positive\n");
>   if (f_min <= 0) XLAL_ERROR(XLAL_EDOM, "f_min must be positive\n");
>   if (f_max < 0) XLAL_ERROR(XLAL_EDOM, "f_max must be greater than 0\n");
>   if (distance <= 0) XLAL_ERROR(XLAL_EDOM, "distance must be positive\n");
> 
>   const REAL8 q = (m1 > m2) ? (m1 / m2) : (m2 / m1);
123,124c130,131
<   if (chi1 > 0.99 || chi1 < -1.0 || chi2 > 0.99 || chi2 < -1.0)
<     XLAL_ERROR(XLAL_EDOM, "Spins outside the range [-1,0.99] are not supported\n");
---
>   if (q > MAX_ALLOWED_MASS_RATIO)
>     XLAL_PRINT_WARNING("Warning: The model is not supported for high mass ratio, see MAX_ALLOWED_MASS_RATIO\n");
126,127c133,134
<   if (q > 18.0)
<     XLAL_PRINT_WARNING("Warning: The model is calibrated up to m1/m2 <= 18.\n");
---
>   if (chi1 > 1.0 || chi1 < -1.0 || chi2 > 1.0 || chi2 < -1.0)
>     XLAL_ERROR(XLAL_EDOM, "Spins outside the range [-1,1] are not supported\n");
129,130c136,142
<   const REAL8 M_sec = (m1+m2) * LAL_MTSUN_SI;
<   const REAL8 fCut = 0.3/M_sec;
---
>   // if no reference frequency given, set it to the starting GW frequency
>   REAL8 fRef = (fRef_in == 0.0) ? f_min : fRef_in;
> 
>   const REAL8 M_sec = (m1+m2) * LAL_MTSUN_SI; // Conversion factor Hz -> dimensionless frequency
>   const REAL8 fCut = f_CUT/M_sec; // convert Mf -> Hz
>   // Somewhat arbitrary end point for the waveform.
>   // Chosen so that the end of the waveform is well after the ringdown.
132c144
<     XLAL_ERROR(XLAL_EDOM, "(fCut = %gM) <= f_min = %g\n", fCut, f_min);
---
>     XLAL_ERROR(XLAL_EDOM, "(fCut = %g Hz) <= f_min = %g\n", fCut, f_min);
134c146
<   /* default f_max to params->fCut */
---
>     /* default f_max to Cut */
141,143c153,156
<   REAL8 status = IMRPhenomDGenerateFD(htilde, phi0, deltaF,
<                                       m1, m2, chi1, chi2,
<                                       f_min, f_max_prime, distance);
---
>   int status = IMRPhenomDGenerateFD(htilde, phi0, fRef, deltaF,
>                                     m1, m2, chi1, chi2,
>                                     f_min, f_max_prime, distance);
>   XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to generate IMRPhenomD waveform.");
146,147c159,161
<     // The user has requested a higher f_max than Mf=params->fCut.
<     // Resize the frequency series to fill with zeros to fill with zeros beyond the cutoff frequency.
---
>     // The user has requested a higher f_max than Mf=fCut.
>     // Resize the frequency series to fill with zeros beyond the cutoff frequency.
>     size_t n = (*htilde)->data->length;
149a164
>     XLAL_CHECK ( *htilde, XLAL_ENOMEM, "Failed to resize waveform COMPLEX16FrequencySeries of length %zu (for internal fCut=%f) to new length %zu (for user-requested f_max=%f).", n, fCut, n_full, f_max );
152c167
<   return status;
---
>   return XLAL_SUCCESS;
165,166c180,182
<     COMPLEX16FrequencySeries **htilde, /**< FD waveform */
<     const REAL8 phi0,                  /**< phase at peak */
---
>     COMPLEX16FrequencySeries **htilde, /**< [out] FD waveform */
>     const REAL8 phi0,                  /**< phase at fRef */
>     const REAL8 fRef,                  /**< reference frequency [Hz] */
168,169c184,185
<     const REAL8 m1,                    /**< mass of companion 1 [solar masses] */
<     const REAL8 m2,                    /**< mass of companion 2 [solar masses] */
---
>     const REAL8 m1_in,                 /**< mass of companion 1 [solar masses] */
>     const REAL8 m2_in,                 /**< mass of companion 2 [solar masses] */
177a194,209
>   REAL8 chi1, chi2, m1, m2;
>   if (m1_in>m2_in) {
>      chi1 = chi1_in;
>      chi2 = chi2_in;
>      m1   = m1_in;
>      m2   = m2_in;
>   } else { // swap spins and masses
>      chi1 = chi2_in;
>      chi2 = chi1_in;
>      m1   = m2_in;
>      m2   = m1_in;
>   }
> 
>   int status = init_useful_powers(&powers_of_pi, LAL_PI);
>   XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initiate useful powers of pi.");
> 
180d211
<   const REAL8 M_sec = M * LAL_MTSUN_SI;
182,189c213,216
<   REAL8 chi1, chi2;
<   if (m1>m2) { // swap spins
<     chi1 = chi1_in;
<     chi2 = chi2_in;
<   } else {
<     chi1 = chi2_in;
<     chi2 = chi1_in;
<   }
---
>   if (eta > 0.25 || eta < 0.0)
>     XLAL_ERROR(XLAL_EDOM, "Unphysical eta. Must be between 0. and 0.25\n");
> 
>   const REAL8 M_sec = M * LAL_MTSUN_SI;
193a221,224
>   /* Coalesce at t=0 */
>   // shift by overall length in time
>   XLAL_CHECK ( XLALGPSAdd(&ligotimegps_zero, -1. / deltaF), XLAL_EFUNC, "Failed to shift coalescence time to t=0, tried to apply shift of -1.0/deltaF with deltaF=%g.", deltaF);
> 
196,197c227
<   /* Coalesce at t=0 */
<   XLALGPSAdd(&ligotimegps_zero, -1. / deltaF); // shift by overall length in time
---
> 
199a230,231
>   XLAL_CHECK ( *htilde, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu for f_max=%f, deltaF=%g.", n, f_max, deltaF);
> 
202d233
<   if (!(*htilde)) XLAL_ERROR(XLAL_EFUNC);
203a235
>   /* range that will have actual non-zero waveform values generated */
205a238
>   XLAL_CHECK ( (ind_max<=n) && (ind_min<=ind_max), XLAL_EDOM, "minimum freq index %zu and maximum freq index %zu do not fulfill 0<=ind_min<=ind_max<=htilde->data>length=%zu.", ind_min, ind_max, n);
208,210c241
<   IMRPhenomDAmplitudeCoefficients *pAmp = ComputeIMRPhenomDAmplitudeCoefficients(eta, chi1, chi2);
<   IMRPhenomDPhaseCoefficients *pPhi = ComputeIMRPhenomDPhaseCoefficients(eta, chi1, chi2);
<   if (!pAmp || !pPhi) XLAL_ERROR(XLAL_EFUNC);
---
>   REAL8 finspin = FinalSpin0815(eta, chi1, chi2); //FinalSpin0815 - 0815 is like a version number
212,213c243,274
<   // Compute coefficients to make phase C^1
<   ComputeIMRPhenDPhaseConnectionCoefficients(pPhi);
---
>   if (finspin < MIN_FINAL_SPIN)
>           XLAL_PRINT_WARNING("Final spin (Mf=%g) and ISCO frequency of this system are small, \
>                           the model might misbehave here.", finspin);
> 
>   IMRPhenomDAmplitudeCoefficients *pAmp = ComputeIMRPhenomDAmplitudeCoefficients(eta, chi1, chi2, finspin);
>   if (!pAmp) XLAL_ERROR(XLAL_EFUNC);
>   IMRPhenomDPhaseCoefficients *pPhi = ComputeIMRPhenomDPhaseCoefficients(eta, chi1, chi2, finspin);
>   if (!pPhi) XLAL_ERROR(XLAL_EFUNC);
>   PNPhasingSeries *pn = NULL;
>   XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1, chi2, 1.0, 1.0, LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
>   if (!pn) XLAL_ERROR(XLAL_EFUNC);
> 
>   // Subtract 3PN spin-spin term below as this is in LAL's TaylorF2 implementation
>   // (LALSimInspiralPNCoefficients.c -> XLALSimInspiralPNPhasing_F2), but
>   // was not available when PhenomD was tuned.
>   pn->v[6] -= (Subtract3PNSS(m1, m2, M, chi1, chi2) * pn->v[0]);
> 
> 
>   PhiInsPrefactors phi_prefactors;
>   status = init_phi_ins_prefactors(&phi_prefactors, pPhi, pn);
>   XLAL_CHECK(XLAL_SUCCESS == status, status, "init_phi_ins_prefactors failed");
> 
>   // Compute coefficients to make phase C^1 continuous (phase and first derivative)
>   ComputeIMRPhenDPhaseConnectionCoefficients(pPhi, pn, &phi_prefactors);
> 
>   //time shift so that peak amplitude is approximately at t=0
>   //For details see https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview/timedomain
>   REAL8 t0 = DPhiMRD(pAmp->fmaxCalc, pPhi);
> 
>   AmpInsPrefactors amp_prefactors;
>   status = init_amp_ins_prefactors(&amp_prefactors, pAmp);
>   XLAL_CHECK(XLAL_SUCCESS == status, status, "init_amp_ins_prefactors failed");
214a276
>   int status_in_for = XLAL_SUCCESS;
217c279,312
<   for (size_t i = ind_min; i < ind_max; i++) {
---
>   for (size_t i = ind_min; i < ind_max; i++)
>   {
> 	REAL8 Mf = M_sec * i * deltaF; // geometric frequency
> 
> 	UsefulPowers powers_of_f;
> 	status_in_for = init_useful_powers(&powers_of_f, Mf);
> 	if (XLAL_SUCCESS != status_in_for)
> 	{
> 		XLALPrintError("init_useful_powers failed for Mf, status_in_for=%d", status_in_for);
> 		status = status_in_for;
> 	}
> 	else
> 	{
> 		 REAL8 amp = IMRPhenDAmplitude(Mf, pAmp, &powers_of_f, &amp_prefactors);
> 		 REAL8 phi = IMRPhenDPhase(Mf, pPhi, pn, &powers_of_f, &phi_prefactors);
> 
> 		 // incorporating fRef
> 		 REAL8 MfRef = M_sec * fRef;
> 		 UsefulPowers powers_of_fRef;
> 		 status_in_for = init_useful_powers(&powers_of_fRef, MfRef);
> 		 if (XLAL_SUCCESS != status_in_for)
> 		 {
> 			 XLALPrintError("init_useful_powers failed for MfRef, status_in_for=%d", status_in_for);
> 			 status = status_in_for;
> 		 }
> 		 else
> 		 {
> 			 REAL8 phifRef = IMRPhenDPhase(MfRef, pPhi, pn, &powers_of_fRef, &phi_prefactors);
> 			 phi -= 2.*phi0 + t0*(Mf-MfRef) + phifRef; // factor of 2 b/c phi0 is orbital phase
> 
> 			 ((*htilde)->data->data)[i] = amp0 * amp * cexp(-I * phi);
> 		 }
> 	}
>   }
219c314,316
<     REAL8 Mf = M_sec * i * deltaF; // geometric frequency
---
>   LALFree(pAmp);
>   LALFree(pPhi);
>   LALFree(pn);
221,222c318,319
<     REAL8 amp = IMRPhenDAmplitude(Mf, pAmp);
<     REAL8 phi = IMRPhenDPhase(Mf, pPhi);
---
>   return status;
> }
224c321,363
<     phi -= 2.*phi0; // factor of 2 b/c phi0 is orbital phase
---
> /**
>  * Function to return the frequency (in Hz) of the peak of the frequency
>  * domain amplitude for the IMRPhenomD model.
>  *
>  * The peak is a parameter in the PhenomD model given by Eq. 20 in 1508.07253
>  * where it is called f_peak in the paper.
>  *  All input parameters should be in SI units. Angles should be in radians.
>  */
> double XLALIMRPhenomDGetPeakFreq(
>     const REAL8 m1_in,                 /**< mass of companion 1 [kg] */
>     const REAL8 m2_in,                 /**< mass of companion 2 [kg] */
>     const REAL8 chi1_in,               /**< aligned-spin of companion 1 */
>     const REAL8 chi2_in               /**< aligned-spin of companion 2 */
> ) {
>     // Ensure that m1 > m2 and that chi1 is the spin on m1
>     REAL8 chi1, chi2, m1, m2;
>     if (m1_in>m2_in) {
>        chi1 = chi1_in;
>        chi2 = chi2_in;
>        m1   = m1_in;
>        m2   = m2_in;
>     } else { // swap spins and masses
>        chi1 = chi2_in;
>        chi2 = chi1_in;
>        m1   = m2_in;
>        m2   = m1_in;
>     }
> 
>     const REAL8 M = m1 + m2;
>     const REAL8 M_sec = M * LAL_MTSUN_SI; // Conversion factor Hz -> dimensionless frequency
> 
>     REAL8 eta = m1 * m2 / (M * M);
>     if (eta > 0.25 || eta < 0.0)
>       XLAL_ERROR(XLAL_EDOM, "Unphysical eta. Must be between 0. and 0.25\n");
> 
>     // Calculate phenomenological parameters
>     REAL8 finspin = FinalSpin0815(eta, chi1, chi2);
> 
>     if (finspin < MIN_FINAL_SPIN)
>           XLAL_PRINT_WARNING("Final spin (Mf=%g) and ISCO frequency of this system are small, \
>                           the model might misbehave here.", finspin);
>     IMRPhenomDAmplitudeCoefficients *pAmp = ComputeIMRPhenomDAmplitudeCoefficients(eta, chi1, chi2, finspin);
>     if (!pAmp) XLAL_ERROR(XLAL_EFUNC);
226,227c365,366
<     ((*htilde)->data->data)[i] = amp0 * amp * cexp(-I * phi);
<   }
---
>     // PeakFreq, converted to Hz
>     REAL8 PeakFreq = ( pAmp->fmaxCalc ) / M_sec;
229,230c368
<   LALFree(pAmp);
<   LALFree(pPhi);
---
>     LALFree(pAmp);
232c370
<   return XLAL_SUCCESS;
---
>     return PeakFreq;
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomD.h ./LALSimIMRPhenomD.h
0a1,11
> /**
>  *
>  * \file
>  * \brief Tabulated Quasi-Normal Mode Information for Ringdown
>  *
>  * This file contains listed final spin values, and corresponding Quasi-Normal-Mode(QNM) central frequencies and decay rates. The spins are on [-1,1] where values are the dimensionless Kerr parameters S/M^2. The frequencies and decay rates are in units of 1/(s*pi*M), where M is 1. To compare values with tables given at, for example, www.phy.olemiss.edu/~berti/ringdown/, multiply by 2*pi, and note that the decay rate corresponds to the imaginary part of the QNM frequency.
>  *
>  * Values for spins between -0.994 and 0.994 were sourced from the above website (2014), while qualitatively accurate values for the remaining spins where sourced from the implementation used in arxiv:1404:3197. Both references use the analytic representation of QNMs developed by Leaver in 1986, and for spin values within +-0.994, have identical values within numerical error.
>  *
>  * */
> 
3a15,48
> /* CONSTANTS */
> 
> /**
>  * Dimensionless frequency (Mf) at which define the end of the waveform
>  */
> #define f_CUT 0.2
> 
> /**
>  * Dimensionless frequency (Mf) at which the inspiral amplitude
>  * switches to the intermediate amplitude
>  */
> #define AMP_fJoin_INS 0.014
> 
> /**
>  * Dimensionless frequency (Mf) at which the inspiral phase
>  * switches to the intermediate phase
>  */
> #define PHI_fJoin_INS 0.018
> 
> /**
>   * Minimal final spin value below which the waveform might behave pathological
>   * because the ISCO frequency is too low. For more details, see the review wiki
>   * page https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview/PhenD_LargeNegativeSpins
>   */
> #define MIN_FINAL_SPIN -0.717
> 
> /**
>   * A large mass ratio causes memory over-runs.
>   * We test and put the limit an order of magnitude above that of previous waveform models (which were around q=100).
>   */
> #define MAX_ALLOWED_MASS_RATIO 5000
> 
> 
> /* QNM data */
5,6c50,51
< static const int QNMData_length = 996;
< static const double QNMData_a[] = {-0.996, -0.994, -0.992, -0.99, -0.988, -0.986, -0.984, -0.982, \
---
> static const int QNMData_length = 1003;
> static const double QNMData_a[] = { -1.0, -0.999, -0.998,-0.996,         -0.994, -0.992, -0.99, -0.988, -0.986, -0.984, -0.982, \
112c157
< 0.992, 0.994};
---
> 0.992, 0.994,       0.996, 0.998, 0.999, 1.0};
114c159
< static const double QNMData_fring[] = {0.0464189, 0.0464526, 0.046473, 0.0464909, 0.0465084, 0.0465259, \
---
> static const double QNMData_fring[] = {0.0464014,0.0464110,0.0464197,0.0464373,       0.0464526, 0.046473, 0.0464909, 0.0465084, 0.0465259, \
278c323
< 0.14056, 0.142833};
---
> 0.14056, 0.142833,      0.1456111,0.1493707,0.1521282,0.1579619};
280c325
< static const double QNMData_fdamp[] = {0.014021, 0.0140177, 0.0140154, 0.0140148, 0.014015, 0.0140156, \
---
> static const double QNMData_fdamp[] = {0.0140098,0.0140102,0.0140106,0.0140114,       0.0140177, 0.0140154, 0.0140148, 0.014015, 0.0140156, \
446c491
< 0.00564485, 0.00535699, 0.0050375, 0.00467763, 0.00426389, 0.00377349};
---
> 0.00564485, 0.00535699, 0.0050375, 0.00467763, 0.00426389, 0.00377349,    0.0031618,0.0023131,0.0016762,0.0002908};
448c493
< #endif /* _LALSIM_IMR_PHENOMD_H */
\ No newline at end of file
---
> #endif /* _LALSIM_IMR_PHENOMD_H */
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomD_internals.c ./LALSimIMRPhenomD_internals.c
2c2
<  * Copyright (C) 2015 Michael Puerrer, Sebastian Khan, Frank Ohme
---
>  * Copyright (C) 2015 Michael Puerrer, Sebastian Khan, Frank Ohme, Ofek Birnholtz, Lionel London
22c22
<  * \author Michael Puerrer, Sebastian Khan, Frank Ohme
---
>  * \author Michael Puerrer, Sebastian Khan, Frank Ohme, Ofek Birnholtz, Lionel London
26,42c26,27
<  * \brief C code for IMRPhenomD phenomenological waveform model.
<  * See ... for details.
<  *
<  * This is an aligned-spin frequency domain model.
<  *
<  * @note The model was calibrated to mass-ratios [1:1,1:4,1:8,1:18].
<  * * Along the mass-ratio 1:1 line it was calibrated to spins  [-0.95, +0.98].
<  * * Along the mass-ratio 1:4 line it was calibrated to spins  [-0.75, +0.75].
<  * * Along the mass-ratio 1:8 line it was calibrated to spins  [-0.85, +0.85].
<  * * Along the mass-ratio 1:18 line it was calibrated to spins [-0.8, +0.4].
<  * The calibration points will be given in forthcoming papers.
<  *
<  * @note The model is usable outside this parameter range,
<  * and in tests to date gives sensible physical results,
<  * but conclusive statements on the physical fidelity of
<  * the model for these parameters await comparisons against further
<  * numerical-relativity simulations.
---
>  * \brief Internal function for IMRPhenomD phenomenological waveform model.
>  * See \ref LALSimIMRPhenom_c for more details.
46,160c31,79
< #include <stdlib.h>
< #include <stdio.h>
< #include <math.h>
< #include <complex.h>
< #include <gsl/gsl_errno.h>
< #include <gsl/gsl_spline.h>
< 
< #include <lal/LALStdlib.h>
< #include <lal/LALSimIMR.h>
< #include <lal/LALConstants.h>
< #include <lal/Date.h>
< #include <lal/FrequencySeries.h>
< #include <lal/Units.h>
< #include <lal/LALSimInspiral.h>
< 
< #include "LALSimIMRPhenomD.h"
< 
< // Constants in Mathematica CForm expressions
< const double Pi = LAL_PI;
< const double EulerGamma = LAL_GAMMA;
< 
< // NOTE: At the moment we have separate functions for each Phenom coefficient;
< // these could be collected together
< 
< typedef struct tagIMRPhenomDAmplitudeCoefficients {
<   double eta;         // symmetric mass-ratio
<   double chi1, chi2;  // dimensionless aligned spins, convention m1 >= m2.
<   double q;           // asymmetric mass-ratio (q>=1)
<   double chi;         // PN reduced spin parameter
<   double fRD;         // ringdown frequency
<   double fDM;         // imaginary part of the ringdown frequency (damping time)
< 
<   double fmaxCalc;
< 
<   // Phenomenological inspiral amplitude coefficients
<   double rho1;
<   double rho2;
<   double rho3;
< 
<   // Phenomenological intermediate amplitude coefficients
<   double delta0;
<   double delta1;
<   double delta2;
<   double delta3;
<   double delta4;
< 
<   // Phenomenological merger-ringdown amplitude coefficients
<   double gamma1;
<   double gamma2;
<   double gamma3;
< 
<   // Coefficients for collocation method
<   double f1, f2, f3;
<   double v1, v2, v3;
<   double d1, d2;
< 
<   // Transition frequencies for amplitude
<   // We don't *have* to store them, but it may be clearer.
<   double fInsJoin;
<   double fMRDJoin;
< }
< IMRPhenomDAmplitudeCoefficients;
< 
< typedef struct tagIMRPhenomDPhaseCoefficients {
<   double eta;         // symmetric mass-ratio
<   double chi1, chi2;  // dimensionless aligned spins, convention m1 >= m2.
<   double q;           // asymmetric mass-ratio (q>=1)
<   double chi;         // PN reduced spin parameter
<   double fRD;         // ringdown frequency
<   double fDM;         // imaginary part of the ringdown frequency (damping time)
< 
<   // Phenomenological inspiral phase coefficients
<   double sigma1;
<   double sigma2;
<   double sigma3;
<   double sigma4;
<   double sigma5;
< 
<   // Phenomenological intermediate phase coefficients
<   double beta1;
<   double beta2;
<   double beta3;
< 
<   // Phenomenological merger-ringdown phase coefficients
<   double alpha1;
<   double alpha2;
<   double alpha3;
<   double alpha4;
<   double alpha5;
< 
<   // C1 phase connection coefficients
<   double C1Int;
<   double C2Int;
<   double C1MRD;
<   double C2MRD;
< 
<   // Transition frequencies for phase
<   double fInsJoin;
<   double fMRDJoin;
< }
< IMRPhenomDPhaseCoefficients;
< 
< typedef struct tagdeltaUtility {
<   double f12;
<   double f13;
<   double f14;
<   double f15;
<   double f22;
<   double f23;
<   double f24;
<   double f32;
<   double f33;
<   double f34;
<   double f35;
< } DeltaUtility;
---
> /*
> This waveform uses the TaylorF2 coefficients for it's inspiral phase augmented
> by higher order phenomenological terms tuned to SEOBv2-Hybrid waveforms.
> Below are lines copied from LALSimInspiralPNCoefficients.c which are the TaylorF2
> phase coefficients we have used.
> We document them here in case changes to that file changes the behaviour
> of this waveform.
> 
>     const REAL8 mtot = m1 + m2;
>     const REAL8 d = (m1 - m2) / (m1 + m2);
>     const REAL8 eta = m1*m2/mtot/mtot;
>     const REAL8 m1M = m1/mtot;
>     const REAL8 m2M = m2/mtot;
>     // Use the spin-orbit variables from arXiv:1303.7412, Eq. 3.9
>     // We write dSigmaL for their (\delta m/m) * \Sigma_\ell
>     // There's a division by mtotal^2 in both the energy and flux terms
>     // We just absorb the division by mtotal^2 into SL and dSigmaL
> 
>     const REAL8 SL = m1M*m1M*chi1L + m2M*m2M*chi2L;
>     const REAL8 dSigmaL = d*(m2M*chi2L - m1M*chi1L);
> 
>     const REAL8 pfaN = 3.L/(128.L * eta);
>     //Non-spin phasing terms - see arXiv:0907.0700, Eq. 3.18
>     pfa->v[0] = 1.L;
>     pfa->v[2] = 5.L*(743.L/84.L + 11.L * eta)/9.L;
>     pfa->v[3] = -16.L*LAL_PI;
>     pfa->v[4] = 5.L*(3058.673L/7.056L + 5429.L/7.L * eta
>                      + 617.L * eta*eta)/72.L;
>     pfa->v[5] = 5.L/9.L * (7729.L/84.L - 13.L * eta) * LAL_PI;
>     pfa->vlogv[5] = 5.L/3.L * (7729.L/84.L - 13.L * eta) * LAL_PI;
>     pfa->v[6] = (11583.231236531L/4.694215680L
>                      - 640.L/3.L * LAL_PI * LAL_PI - 6848.L/21.L*LAL_GAMMA)
>                  + eta * (-15737.765635L/3.048192L
>                      + 2255./12. * LAL_PI * LAL_PI)
>                  + eta*eta * 76055.L/1728.L
>                  - eta*eta*eta * 127825.L/1296.L;
>     pfa->v[6] += (-6848.L/21.L)*log(4.);
>     pfa->vlogv[6] = -6848.L/21.L;
>     pfa->v[7] = LAL_PI * ( 77096675.L/254016.L
>                      + 378515.L/1512.L * eta - 74045.L/756.L * eta*eta);
> 
>     // Spin-orbit terms - can be derived from arXiv:1303.7412, Eq. 3.15-16
>     const REAL8 pn_gamma = (554345.L/1134.L + 110.L*eta/9.L)*SL + (13915.L/84.L - 10.L*eta/3.)*dSigmaL;
>     switch( spinO )
>     {
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
>             pfa->v[7] += (-8980424995.L/762048.L + 6586595.L*eta/756.L - 305.L*eta*eta/36.L)*SL - (170978035.L/48384.L - 2876425.L*eta/672.L - 4735.L*eta*eta/144.L) * dSigmaL;
> */
162c81,83
< /**
---
> #include "LALSimIMRPhenomD_internals.h"
> 
> /*
164c85
<  * Internal function prototypes; f stands for geometric frequency "Mf"
---
>  * Internal function implementations
170,255d90
< static double chiPN(double eta, double chi1, double chi2);
< static double PlanckTaper(const double t, const double t1, const double t2);
< static size_t NextPow2(const size_t n);
< 
< //////////////////////// Final spin, final mass, fring, fdamp ///////////////////////
< 
< static double FinalSpin0714_s(double eta, double s);
< static double FinalSpin0714(double eta, double chi1, double chi2);
< static double EradRational_s(double eta, double s);
< static double EradRational(double eta, double chi1, double chi2);
< static double fring(double eta, double chi1, double chi2);
< static double fdamp(double eta, double chi1, double chi2);
< 
< /******************************* Amplitude functions *******************************/
< 
< static double amp0Func(double eta);
< 
< ///////////////////////////// Amplitude: Inspiral functions /////////////////////////
< 
< static double rho1_fun(double eta, double chiPN);
< static double rho2_fun(double eta, double chiPN);
< static double rho3_fun(double eta, double chiPN);
< static double AmpInsAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p);
< static double DAmpInsAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p);
< 
< ////////////////////////// Amplitude: Merger-Ringdown functions //////////////////////
< 
< static double gamma1_fun(double eta, double chiPN);
< static double gamma2_fun(double eta, double chiPN);
< static double gamma3_fun(double eta, double chiPN);
< static double AmpMRDAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p);
< static double DAmpMRDAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p);
< static double fmaxCalc(IMRPhenomDAmplitudeCoefficients* p);
< 
< //////////////////////////// Amplitude: Intermediate functions ///////////////////////
< 
< static double AmpIntAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p);
< static double AmpIntColFitCoeff(double eta, double chiPN);
< static double delta0_fun(IMRPhenomDAmplitudeCoefficients* p, DeltaUtility* d);
< static double delta1_fun(IMRPhenomDAmplitudeCoefficients* p, DeltaUtility* d);
< static double delta2_fun(IMRPhenomDAmplitudeCoefficients* p, DeltaUtility* d);
< static double delta3_fun(IMRPhenomDAmplitudeCoefficients* p, DeltaUtility* d);
< static double delta4_fun(IMRPhenomDAmplitudeCoefficients* p, DeltaUtility* d);
< static void ComputeDeltasFromCollocation(IMRPhenomDAmplitudeCoefficients* p);
< 
< ///////////////////////////// Amplitude: glueing function ////////////////////////////
< 
< static IMRPhenomDAmplitudeCoefficients* ComputeIMRPhenomDAmplitudeCoefficients(double eta, double chi1, double chi2);
< static double IMRPhenDAmplitude(double f, IMRPhenomDAmplitudeCoefficients *p);
< 
< /********************************* Phase functions *********************************/
< 
< /////////////////////////////// Phase: Ringdown functions ////////////////////////////
< 
< static double alpha1Fit(double eta, double chiPN);
< static double alpha2Fit(double eta, double chiPN);
< static double alpha3Fit(double eta, double chiPN);
< static double alpha4Fit(double eta, double chiPN);
< static double alpha5Fit(double eta, double chiPN);
< static double PhiMRDAnsatzInt(double f, IMRPhenomDPhaseCoefficients *p);
< static double DPhiMRD(double f, IMRPhenomDPhaseCoefficients *p);
< 
< /////////////////////////// Phase: Intermediate functions ///////////////////////////
< 
< static double beta1Fit(double eta, double chiPN);
< static double beta2Fit(double eta, double chiPN);
< static double beta3Fit(double eta, double chiPN);
< static double PhiIntAnsatz(double f, IMRPhenomDPhaseCoefficients *p);
< static double DPhiIntAnsatz(double f, IMRPhenomDPhaseCoefficients *p);
< static double DPhiIntTemp(double ff, IMRPhenomDPhaseCoefficients *p);
< 
< ///////////////////////////// Phase: Inspiral functions /////////////////////////////
< 
< static double sigma1Fit(double eta, double chiPN);
< static double sigma2Fit(double eta, double chiPN);
< static double sigma3Fit(double eta, double chiPN);
< static double sigma4Fit(double eta, double chiPN);
< static double PhiInsAnsatzInt(double f, IMRPhenomDPhaseCoefficients *p);
< static double DPhiInsAnsatzInt(double ff, IMRPhenomDPhaseCoefficients *p);
< 
< ////////////////////////////// Phase: glueing function //////////////////////////////
< 
< static IMRPhenomDPhaseCoefficients* ComputeIMRPhenomDPhaseCoefficients(double eta, double chi1, double chi2);
< static void ComputeIMRPhenDPhaseConnectionCoefficients(IMRPhenomDPhaseCoefficients *p);
< static double IMRPhenDPhase(double f, IMRPhenomDPhaseCoefficients *p);
< 
257,265c92,94
<  *
<  * Internal function definitions
<  *
<  * */
< 
< ////////////////////////////// Miscellaneous functions //////////////////////////////
< 
< // PN reduced spin parameter
< // See Eq 5.9 in http://arxiv.org/pdf/1107.1267v2.pdf
---
>  * PN reduced spin parameter
>  * See Eq 5.9 in http://arxiv.org/pdf/1107.1267v2.pdf
>  */
267,271c96,97
<   // Convention m1 >= m2
<   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
<   double M = 1; // only used for delta; value is irrelevant
<   double m1 = M*q/(1.0+q);
<   double m2 = M*1.0/(1.0+q);
---
>   // Convention m1 >= m2 and chi1 is the spin on m1
>   double delta = sqrt(1.0 - 4.0*eta);
274,275c100
<   double delta = (m1 - m2) / M;
<   return chi_s * (1.0 - 76.0/113.0*eta) + delta*chi_a;
---
>   return chi_s * (1.0 - eta*76.0/113.0) + delta*chi_a;
278,285c103,109
< // Planck taper function. See http://arxiv.org/abs/1003.2939
< static double PlanckTaper(const double t, const double t1, const double t2) {
<   if (t <= t1)
<     return 0.0;
<   else if (t >= t2)
<     return 1.0;
<   else
<     return 1.0 / (exp((t2 - t1)/(t - t1) + (t2 - t1)/(t - t2)) + 1.0);
---
> /**
>  * Return the closest higher power of 2
>  */
> static size_t NextPow2(const size_t n)
> {
>   // use pow here, not bit-wise shift, as the latter seems to run against an upper cutoff long before SIZE_MAX, at least on some platforms
>   return (size_t) pow(2,ceil(log2(n)));
288,290c112,126
< // Return the closest higher power of 2
< static size_t NextPow2(const size_t n) {
<   return 1 << (size_t) ceil(log2(n));
---
> ///**
> // * Step function
> // */
> //static double StepFunc(const double t, const double t1) {
> //  if (t < t1)
> //    return 0.0;
> //  else
> //    return 1.0;
> //}
> 
> /**
>  * Step function in boolean version
>  */
> static bool StepFunc_boolean(const double t, const double t1) {
> 	return (t >= t1);
295c131
< // TODO: Add documentation of these functions
---
> // Final Spin and Radiated Energy formulas described in 1508.07250
297c133,137
< static double FinalSpin0714_s(double eta, double s) {
---
> /**
>  * Formula to predict the final spin. Equation 3.6 arXiv:1508.07250
>  * s defined around Equation 3.6.
>  */
> static double FinalSpin0815_s(double eta, double s) {
299a140
>   double eta4 = eta3*eta;
304,307c145,150
<   return 3.4641016151377544*eta - 3.896044039898422*eta2 + 4.133657521035006*eta3 +
<    (1 - 2.6507474704915883*eta + 0.5478819823269401*eta2 - 4.032593676598959*eta3)*s +
<    (0.12443985124277726*eta - 0.9295544432946068*eta2 - 0.10106384443604632*eta3)*s2 +
<    (-0.5142453933108723*eta + 1.8929952741242566*eta2)*s3 + (-0.6162184851271666*eta + 2.384721226741833*eta2)*s4;
---
> return 3.4641016151377544*eta - 4.399247300629289*eta2 +
>    9.397292189321194*eta3 - 13.180949901606242*eta4 +
>    (1 - 0.0850917821418767*eta - 5.837029316602263*eta2)*s +
>    (0.1014665242971878*eta - 2.0967746996832157*eta2)*s2 +
>    (-1.3546806617824356*eta + 4.108962025369336*eta2)*s3 +
>    (-0.8676969352555539*eta + 2.064046835273906*eta2)*s4;
310c153,156
< static double FinalSpin0714(double eta, double chi1, double chi2) {
---
> /**
>  * Wrapper function for FinalSpin0815_s.
>  */
> static double FinalSpin0815(double eta, double chi1, double chi2) {
312,313c158,160
<   double m1 = 0.5 * (1.0 + sqrt(1.0 - 4.0*eta));
<   double m2 = 0.5 * (1.0 - sqrt(1.0 - 4.0*eta));
---
>   double Seta = sqrt(1.0 - 4.0*eta);
>   double m1 = 0.5 * (1.0 + Seta);
>   double m2 = 0.5 * (1.0 - Seta);
316,318c163,165
<   double s = (m1s * chi1 + m2s * chi2) / (m1s + m2s); // CHECK: this is different in EradRational: Is this correct?
< 
<   return FinalSpin0714_s(eta, s);
---
>   // s defined around Equation 3.6 arXiv:1508.07250
>   double s = (m1s * chi1 + m2s * chi2);
>   return FinalSpin0815_s(eta, s);
321c168,172
< static double EradRational_s(double eta, double s) {
---
> /**
>  * Formula to predict the total radiated energy. Equation 3.7 and 3.8 arXiv:1508.07250
>  * Input parameter s defined around Equation 3.7 and 3.8.
>  */
> static double EradRational0815_s(double eta, double s) {
323a175
>   double eta4 = eta3*eta;
325,326c177,178
<   return ((0.0731529149096712*eta + 0.26674934921953924*eta2 + 0.8576638056091429*eta3)*
<      (1. + (0.7306635209598181 - 5.097805627396959*eta + 7.881058808305713*eta2)*s))/(1. + (-0.15735564839807778 - 4.051664713223574*eta)*s);
---
>   return ((0.055974469826360077*eta + 0.5809510763115132*eta2 - 0.9606726679372312*eta3 + 3.352411249771192*eta4)*
>     (1. + (-0.0030302335878845507 - 2.0066110851351073*eta + 7.7050567802399215*eta2)*s))/(1. + (-0.6714403054720589 - 1.4756929437702908*eta + 7.304676214885011*eta2)*s);
329c181,184
< static double EradRational(double eta, double chi1, double chi2) {
---
> /**
>  * Wrapper function for EradRational0815_s.
>  */
> static double EradRational0815(double eta, double chi1, double chi2) {
331,332c186,188
<   double m1 = 0.5 * (1.0 + sqrt(1.0 - 4.0*eta));
<   double m2 = 0.5 * (1.0 - sqrt(1.0 - 4.0*eta));
---
>   double Seta = sqrt(1.0 - 4.0*eta);
>   double m1 = 0.5 * (1.0 + Seta);
>   double m2 = 0.5 * (1.0 - Seta);
335c191,192
<   double s = m1s * chi1 + m2s * chi2; // CHECK: this is different in FinalSpin0714: Is this correct?
---
>   // arXiv:1508.07250
>   double s = (m1s * chi1 + m2s * chi2) / (m1s + m2s);
337c194
<   return EradRational_s(eta, s);
---
>   return EradRational0815_s(eta, s);
340c197,201
< static double fring(double eta, double chi1, double chi2) {
---
> /**
>  * fring is the real part of the ringdown frequency
>  * 1508.07250 figure 9
>  */
> static double fring(double eta, double chi1, double chi2, double finspin) {
342a204,205
>   if (finspin > 1.0) XLAL_ERROR(XLAL_EDOM, "PhenomD fring function: final spin > 1.0 not supported\n");
> 
347c210
<   return_val = gsl_spline_eval(iFring, FinalSpin0714(eta, chi1, chi2), acc) / (1.0 - EradRational(eta, chi1, chi2));
---
>   return_val = gsl_spline_eval(iFring, finspin, acc) / (1.0 - EradRational0815(eta, chi1, chi2));
354c217,221
< static double fdamp(double eta, double chi1, double chi2) {
---
> /**
>  * fdamp is the complex part of the ringdown frequency
>  * 1508.07250 figure 9
>  */
> static double fdamp(double eta, double chi1, double chi2, double finspin) {
355a223,225
> 
>   if (finspin > 1.0) XLAL_ERROR(XLAL_EDOM, "PhenomD fdamp function: final spin > 1.0 not supported\n");
> 
360c230
<   return_val = gsl_spline_eval(iFdamp, FinalSpin0714(eta, chi1, chi2), acc) / (1.0 - EradRational(eta, chi1, chi2));
---
>   return_val = gsl_spline_eval(iFdamp, finspin, acc) / (1.0 - EradRational0815(eta, chi1, chi2));
366a237,254
> static int init_useful_powers(UsefulPowers * p, REAL8 number)
> {
> 	XLAL_CHECK(0 != p, XLAL_EFAULT, "p is NULL");
> 	XLAL_CHECK(number >= 0 , XLAL_EDOM, "number must be non-negative");
> 
> 	// consider changing pow(x,1/6.0) to cbrt(x) and sqrt(x) - might be faster
> 	p->sixth = pow(number, 1/6.0);
> 	p->third = p->sixth * p->sixth;
> 	p->two_thirds = number / p->third;
> 	p->four_thirds = number * (p->third);
> 	p->five_thirds = p->four_thirds * (p->third);
> 	p->two = number * number;
> 	p->seven_thirds = p->third * p->two;
> 	p->eight_thirds = p->two_thirds * p->two;
> 
> 	return XLAL_SUCCESS;
> }
> 
368a257,259
> /**
>  * amplitude scaling factor defined by eq. 17 in 1508.07253
>  */
370c261
<   return (sqrt(0.6666666666666666)*sqrt(eta))/pow(Pi,0.16666666666666666);
---
>   return (sqrt(2.0/3.0)*sqrt(eta))/powers_of_pi.sixth;
377a269,271
> /**
>  * rho_1 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
384,387c278,281
<   return 9971.492472945103 - 17037.888891610917*eta
<     + (12668.61511289507 + 346089.83163884433*eta - 1.2149167739883522e6*eta2)*xi
<     + (-67553.74726851289 + 1.3861298880085826e6*eta - 3.963246463568903e6*eta2)*xi2
<     + (-60370.53480844165 + 804019.1829911621*eta - 2.0902056443125196e6*eta2)*xi3;
---
>   return 3931.8979897196696 - 17395.758706812805*eta
>   + (3132.375545898835 + 343965.86092361377*eta - 1.2162565819981997e6*eta2)*xi
>   + (-70698.00600428853 + 1.383907177859705e6*eta - 3.9662761890979446e6*eta2)*xi2
>   + (-60017.52423652596 + 803515.1181825735*eta - 2.091710365941658e6*eta2)*xi3;
389a284,286
> /**
>  * rho_2 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
396,399c293,296
<   return -66310.52250429206 + 109014.21151257299*eta
<     + (-17171.567397449413 - 3.490892198148065e6*eta + 1.1374537779220121e7*eta2)*xi
<     + (741885.6177097048 - 1.3100372065215468e7*eta + 3.643880366528771e7*eta2)*xi2
<     + (598326.6388874187 - 7.43208895148914e6*eta + 1.8925268527639613e7*eta2)*xi3;
---
>   return -40105.47653771657 + 112253.0169706701*eta
>   + (23561.696065836168 - 3.476180699403351e6*eta + 1.137593670849482e7*eta2)*xi
>   + (754313.1127166454 - 1.308476044625268e7*eta + 3.6444584853928134e7*eta2)*xi2
>   + (596226.612472288 - 7.4277901143564405e6*eta + 1.8928977514040343e7*eta2)*xi3;
401a299,301
> /**
>  * rho_3 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
408,411c308,311
<   return 121291.86682475785 - 185262.388853303*eta
<     + (-152202.97634608237 + 8.743489674196277e6*eta - 2.6916230268901654e7*eta2)*xi
<     + (-1.971833989372485e6 + 3.091520754702774e7*eta - 8.390584129432291e7*eta2)*xi2
<     + (-1.4569827161973754e6 + 1.7071365122228015e7*eta - 4.2745390843862176e7*eta2)*xi3;
---
>   return 83208.35471266537 - 191237.7264145924*eta +
>   (-210916.2454782992 + 8.71797508352568e6*eta - 2.6914942420669552e7*eta2)*xi
>   + (-1.9889806527362722e6 + 3.0888029960154563e7*eta - 8.390870279256162e7*eta2)*xi2
>   + (-1.4535031953446497e6 + 1.7063528990822166e7*eta - 4.2748659731120914e7*eta2)*xi3;
415,417c315,391
< // The higher order amplitude corrections in LAL are wrong.
< // So, we just use the Mathematica expression for convencience.
< static double AmpInsAnsatz(double Mf, IMRPhenomDAmplitudeCoefficients* p) {
---
> // We just use the Mathematica expression for convenience.
> /**
>  * Inspiral amplitude plus rho phenom coefficents. rho coefficients computed
>  * in rho1_fun, rho2_fun, rho3_fun functions.
>  * Amplitude is a re-expansion. See 1508.07253 and Equation 29, 30 and Appendix B arXiv:1508.07253 for details
>  */
> static double AmpInsAnsatz(double Mf, UsefulPowers * powers_of_Mf, AmpInsPrefactors * prefactors) {
>   double Mf2 = powers_of_Mf->two;
>   double Mf3 = Mf*Mf2;
> 
>   return 1 + powers_of_Mf->two_thirds * prefactors->two_thirds
> 			+ Mf * prefactors->one + powers_of_Mf->four_thirds * prefactors->four_thirds
> 			+ powers_of_Mf->five_thirds * prefactors->five_thirds + Mf2 * prefactors->two
> 			+ powers_of_Mf->seven_thirds * prefactors->seven_thirds + powers_of_Mf->eight_thirds * prefactors->eight_thirds
> 			+ Mf3 * prefactors->three;
> }
> 
> static int init_amp_ins_prefactors(AmpInsPrefactors * prefactors, IMRPhenomDAmplitudeCoefficients* p)
> {
> 	XLAL_CHECK(0 != p, XLAL_EFAULT, "p is NULL");
> 	XLAL_CHECK(0 != prefactors, XLAL_EFAULT, "prefactors is NULL");
> 
> 	double eta = p->eta;
> 
> 	prefactors->amp0 = amp0Func(p->eta);
> 
> 	double chi1 = p->chi1;
> 	double chi2 = p->chi2;
> 	double rho1 = p->rho1;
> 	double rho2 = p->rho2;
> 	double rho3 = p->rho3;
> 
> 	double chi12 = chi1*chi1;
> 	double chi22 = chi2*chi2;
> 	double eta2 = eta*eta;
> 	double eta3 = eta*eta2;
> 
> 
> 	double Pi = LAL_PI;
> 	double Pi2 = powers_of_pi.two;
> 	double Seta = sqrt(1.0 - 4.0*eta);
> 
> 	prefactors->two_thirds = ((-969 + 1804*eta)*powers_of_pi.two_thirds)/672.;
> 	prefactors->one = ((chi1*(81*(1 + Seta) - 44*eta) + chi2*(81 - 81*Seta - 44*eta))*Pi)/48.;
> 	prefactors->four_thirds = (	(-27312085.0 - 10287648*chi22 - 10287648*chi12*(1 + Seta) + 10287648*chi22*Seta
> 								 + 24*(-1975055 + 857304*chi12 - 994896*chi1*chi2 + 857304*chi22)*eta
> 								 + 35371056*eta2
> 								 )
> 							* powers_of_pi.four_thirds) / 8.128512e6;
> 	prefactors->five_thirds = (powers_of_pi.five_thirds * (chi2*(-285197*(-1 + Seta) + 4*(-91902 + 1579*Seta)*eta - 35632*eta2)
> 															+ chi1*(285197*(1 + Seta) - 4*(91902 + 1579*Seta)*eta - 35632*eta2)
> 															+ 42840*(-1.0 + 4*eta)*Pi
> 															)
> 								) / 32256.;
> 	prefactors->two = - (Pi2*(-336*(-3248849057.0 + 2943675504*chi12 - 3339284256*chi1*chi2 + 2943675504*chi22)*eta2
> 							  - 324322727232*eta3
> 							  - 7*(-177520268561 + 107414046432*chi22 + 107414046432*chi12*(1 + Seta)
> 									- 107414046432*chi22*Seta + 11087290368*(chi1 + chi2 + chi1*Seta - chi2*Seta)*Pi
> 									)
> 							  + 12*eta*(-545384828789 - 176491177632*chi1*chi2 + 202603761360*chi22
> 										+ 77616*chi12*(2610335 + 995766*Seta) - 77287373856*chi22*Seta
> 										+ 5841690624*(chi1 + chi2)*Pi + 21384760320*Pi2
> 										)
> 								)
> 						)/6.0085960704e10;
> 	prefactors->seven_thirds= rho1;
> 	prefactors->eight_thirds = rho2;
> 	prefactors->three = rho3;
> 
> 	return XLAL_SUCCESS;
> }
> 
> /**
>  * Take the AmpInsAnsatz expression and compute the first derivative
>  * with respect to frequency to get the expression below.
>  */
> static double DAmpInsAnsatz(double Mf, IMRPhenomDAmplitudeCoefficients* p) {
426d399
<   double chi13 = chi12*chi1;
431,432c404,405
<   double Mf3 = Mf*Mf2;
<   double Pi2 = Pi*Pi;
---
>   double Pi = LAL_PI;
>   double Pi2 = powers_of_pi.two;
435,476c408,421
<   // optimized expression
<   return 1 + ((-969 + 1804*eta)*pow(Pi*Mf,0.6666666666666666))/672.
<   + ((chi1*(81*(1 + Seta) - 44*eta) + chi2*(81 - 81*Seta - 44*eta))*Mf*Pi)/48.
<   + ((-27312085 - 10287648*chi22 - 10287648*chi12*(1 + Seta) + 10287648*chi22*Seta
<   + 24*(-1975055 + 857304*chi12 - 994896*chi1*chi2 + 857304*chi22)*eta + 35371056*eta2)
<   *pow(Pi*Mf,1.3333333333333333))/8.128512e6
<   + (pow(Pi*Mf,1.6666666666666667)*(-6048*chi13*(-1 - Seta + (3 + Seta)*eta)
<   + chi1*(287213*(1 + Seta) - 4*(93414 + 2083*Seta)*eta - 35632*eta2)
<   + chi2*(-((287213 + 6048*chi22)*(-1 + Seta)) + 4*(-93414 + 1512*chi22*(-3 + Seta) + 2083*Seta)*eta
<   - 35632*eta2) + 42840*(-1 + 4*eta)*Pi))/32256.
<   - (Mf2*Pi2*(-336*(-3248849057 + 1809550512*chi12 - 2954929824*chi1*chi2 + 1809550512*chi22)*eta2
<   - 324322727232*eta3 + 7*(177520268561 + 29362199328*chi22 + 29362199328*chi12*(1 + Seta)
<   - 29362199328*chi22*Seta + 12160253952*(chi1 + chi2 + chi1*Seta - chi2*Seta)*Pi)
<   + 12*eta*(-545384828789 + 49568837472*chi1*chi2 - 12312458928*chi22
<   + 77616*chi12*(-158633 + 282718*Seta) - 21943440288*chi22*Seta - 8345272320*(chi1 + chi2)*Pi
<   + 21384760320*Pi2)))/6.0085960704e10 + pow(Mf,2.333333333333333)*rho1
<   + pow(Mf,2.6666666666666665)*rho2 + Mf3*rho3;
< }
< 
< static double DAmpInsAnsatz(double f, IMRPhenomDAmplitudeCoefficients* p) {
<   double eta = p->eta;
<   double chi1 = p->chi1;
<   double chi2 = p->chi2;
<   double rho1 = p->rho1;
<   double rho2 = p->rho2;
<   double rho3 = p->rho3;
< 
<   return ((-969 + 1804*eta)*pow(Pi,0.6666666666666666))/(1008.*pow(f,0.3333333333333333)) +
<    ((chi1*(81*(1 + sqrt(1 - 4*eta)) - 44*eta) + chi2*(81 - 81*sqrt(1 - 4*eta) - 44*eta))*Pi)/48. +
<    ((-27312085 - 10287648*pow(chi2,2) - 10287648*pow(chi1,2)*(1 + sqrt(1 - 4*eta)) + 10287648*pow(chi2,2)*sqrt(1 - 4*eta) +
<         24*(-1975055 + 857304*pow(chi1,2) - 994896*chi1*chi2 + 857304*pow(chi2,2))*eta + 35371056*pow(eta,2))*pow(f,0.3333333333333333)*
<       pow(Pi,1.3333333333333333))/6.096384e6 + (5*pow(f,0.6666666666666666)*pow(Pi,1.6666666666666667)*
<       (-6048*pow(chi1,3)*(-1 - sqrt(1 - 4*eta) + (3 + sqrt(1 - 4*eta))*eta) +
<         chi1*(287213*(1 + sqrt(1 - 4*eta)) - 4*(93414 + 2083*sqrt(1 - 4*eta))*eta - 35632*pow(eta,2)) +
<         chi2*(-((287213 + 6048*pow(chi2,2))*(-1 + sqrt(1 - 4*eta))) +
<            4*(-93414 + 1512*pow(chi2,2)*(-3 + sqrt(1 - 4*eta)) + 2083*sqrt(1 - 4*eta))*eta - 35632*pow(eta,2)) + 42840*(-1 + 4*eta)*Pi))/96768. -
<    (f*pow(Pi,2)*(-336*(-3248849057 + 1809550512*pow(chi1,2) - 2954929824*chi1*chi2 + 1809550512*pow(chi2,2))*pow(eta,2) -
<         324322727232*pow(eta,3) + 7*(177520268561 + 29362199328*pow(chi2,2) + 29362199328*pow(chi1,2)*(1 + sqrt(1 - 4*eta)) -
<            29362199328*pow(chi2,2)*sqrt(1 - 4*eta) + 12160253952*(chi1 + chi2 + chi1*sqrt(1 - 4*eta) - chi2*sqrt(1 - 4*eta))*Pi) +
<         12*eta*(-545384828789 + 49568837472*chi1*chi2 - 12312458928*pow(chi2,2) + 77616*pow(chi1,2)*(-158633 + 282718*sqrt(1 - 4*eta)) -
<            21943440288*pow(chi2,2)*sqrt(1 - 4*eta) - 8345272320*(chi1 + chi2)*Pi + 21384760320*pow(Pi,2))))/3.0042980352e10 +
<    2.333333333333333*pow(f,1.333333333333333)*rho1 + 2.6666666666666665*pow(f,1.6666666666666665)*rho2 + 3*pow(f,2)*rho3;
---
>    return ((-969 + 1804*eta)*pow(Pi,2.0/3.0))/(1008.*pow(Mf,1.0/3.0))
>    + ((chi1*(81*(1 + Seta) - 44*eta) + chi2*(81 - 81*Seta - 44*eta))*Pi)/48.
>    + ((-27312085 - 10287648*chi22 - 10287648*chi12*(1 + Seta)
>    + 10287648*chi22*Seta + 24*(-1975055 + 857304*chi12 - 994896*chi1*chi2 + 857304*chi22)*eta
>    + 35371056*eta2)*pow(Mf,1.0/3.0)*pow(Pi,4.0/3.0))/6.096384e6
>    + (5*pow(Mf,2.0/3.0)*pow(Pi,5.0/3.0)*(chi2*(-285197*(-1 + Seta)
>    + 4*(-91902 + 1579*Seta)*eta - 35632*eta2) + chi1*(285197*(1 + Seta)
>    - 4*(91902 + 1579*Seta)*eta - 35632*eta2) + 42840*(-1 + 4*eta)*Pi))/96768.
>    - (Mf*Pi2*(-336*(-3248849057.0 + 2943675504*chi12 - 3339284256*chi1*chi2 + 2943675504*chi22)*eta2 - 324322727232*eta3
>    - 7*(-177520268561 + 107414046432*chi22 + 107414046432*chi12*(1 + Seta) - 107414046432*chi22*Seta
>    + 11087290368*(chi1 + chi2 + chi1*Seta - chi2*Seta)*Pi)
>    + 12*eta*(-545384828789.0 - 176491177632*chi1*chi2 + 202603761360*chi22 + 77616*chi12*(2610335 + 995766*Seta)
>    - 77287373856*chi22*Seta + 5841690624*(chi1 + chi2)*Pi + 21384760320*Pi2)))/3.0042980352e10
>    + (7.0/3.0)*pow(Mf,4.0/3.0)*rho1 + (8.0/3.0)*pow(Mf,5.0/3.0)*rho2 + 3*Mf2*rho3;
483a429,431
> /**
>  * gamma 1 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
490,493c438,441
<   return 0.006929325756444066 + 0.028178602456554704*eta
<     + (0.004712463375341761 - 0.10042540687248233*eta + 0.1913418949251075*eta2)*xi
<     + (0.000992288691457378 - 0.0735538521653164*eta + 0.1623598588976758*eta2)*xi2
<     + (-0.00012994126836641466 - 0.014868851443782867*eta + 0.03420784550184175*eta2)*xi3;
---
>   return 0.006927402739328343 + 0.03020474290328911*eta
>   + (0.006308024337706171 - 0.12074130661131138*eta + 0.26271598905781324*eta2)*xi
>   + (0.0034151773647198794 - 0.10779338611188374*eta + 0.27098966966891747*eta2)*xi2
>   + (0.0007374185938559283 - 0.02749621038376281*eta + 0.0733150789135702*eta2)*xi3;
495a444,446
> /**
>  * gamma 2 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
502,505c453,456
<   return 1.0338973605758845 - 0.0314363028397228*eta
<     + (0.6461456789695995 - 8.452571007081147*eta + 25.039441014539896*eta2)*xi
<     + (0.6170831015808893 - 13.59833956349621*eta + 42.618165831477675*eta2)*xi2
<     + (0.20878227999538593 - 4.991235292948315*eta + 15.879490996567085*eta2)*xi3;
---
>   return 1.010344404799477 + 0.0008993122007234548*eta
>   + (0.283949116804459 - 4.049752962958005*eta + 13.207828172665366*eta2)*xi
>   + (0.10396278486805426 - 7.025059158961947*eta + 24.784892370130475*eta2)*xi2
>   + (0.03093202475605892 - 2.6924023896851663*eta + 9.609374464684983*eta2)*xi3;
507a459,461
> /**
>  * gamma 3 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
514,517c468,471
<   return 1.3638671714681179 - 0.2648078572888508*eta
<     + (0.17346232045631538 - 2.7148000635403484*eta + 7.242203410070453*eta2)*xi
<     + (0.2115831718297191 - 3.616857536014833*eta + 10.649274664019698*eta2)*xi2
<     + (0.07706402964475789 - 1.275335316106863*eta + 3.874082717359707*eta2)*xi3;
---
>   return 1.3081615607036106 - 0.005537729694807678*eta
>   + (-0.06782917938621007 - 0.6689834970767117*eta + 3.403147966134083*eta2)*xi
>   + (-0.05296577374411866 - 0.9923793203111362*eta + 4.820681208409587*eta2)*xi2
>   + (-0.006134139870393713 - 0.38429253308696365*eta + 1.7561754421985984*eta2)*xi3;
519a474,476
> /**
>  * Ansatz for the merger-ringdown amplitude. Equation 19 arXiv:1508.07253
>  */
526,528c483,486
< 
<   return exp( -(f - fRD)*gamma2 / (fDM*gamma3) )
<     * (fDM*gamma3*fabs(gamma1)) / (pow(f - fRD,2) + pow(fDM,2)*pow(gamma3,2));
---
>   double fDMgamma3 = fDM*gamma3;
>   double fminfRD = f - fRD;
>   return exp( -(fminfRD)*gamma2 / (fDMgamma3) )
>     * (fDMgamma3*gamma1) / (pow_2_of(fminfRD) + pow_2_of(fDMgamma3));
530a489,491
> /**
>  * first frequency derivative of AmpMRDAnsatz
>  */
538,539c499,506
<   return (-2*fDM*(f - fRD)*gamma3*fabs(gamma1)) / ( exp(((f - fRD)*gamma2)/(fDM*gamma3)) * pow(pow(f - fRD,2) + pow(fDM,2)*pow(gamma3,2),2)) -
<    (gamma2*fabs(gamma1)) / ( exp(((f - fRD)*gamma2)/(fDM*gamma3)) * (pow(f - fRD,2) + pow(fDM,2)*pow(gamma3,2)));
---
>   double fDMgamma3 = fDM * gamma3;
>   double pow2_fDMgamma3 = pow_2_of(fDMgamma3);
>   double fminfRD = f - fRD;
>   double expfactor = exp(((fminfRD)*gamma2)/(fDMgamma3));
>   double pow2pluspow2 = pow_2_of(fminfRD) + pow2_fDMgamma3;
> 
>    return (-2*fDM*(fminfRD)*gamma3*gamma1) / ( expfactor * pow_2_of(pow2pluspow2)) -
>      (gamma2*gamma1) / ( expfactor * (pow2pluspow2)) ;
541a509,512
> /**
>  * Equation 20 arXiv:1508.07253 (called f_peak in paper)
>  * analytic location of maximum of AmpMRDAnsatz
>  */
548,552c519,520
<   // NOTE: There's a problem with this expression becoming imaginary if the spin is large.
<   //return fabs(fRD + (fDM*(-1 + sqrt(1 - pow(gamma2,2)))*gamma3)/gamma2);
<   //return fabs(fRD + (fDM*(-1 + sqrt( fabs(1 - pow(gamma2,2))))*gamma3)/gamma2);
< 
<   // Possible fix: if gamma2 >= 1 then set the square root term to zero.
---
>   // NOTE: There's a problem with this expression from the paper becoming imaginary if gamma2>=1
>   // Fix: if gamma2 >= 1 then set the square root term to zero.
554c522
<     return fabs(fRD + (fDM*(-1 + sqrt(1 - pow(gamma2,2)))*gamma3)/gamma2);
---
>     return fabs(fRD + (fDM*(-1 + sqrt(1 - pow_2_of(gamma2)))*gamma3)/gamma2);
565c533,535
< 
---
> /**
>  * Ansatz for the intermediate amplitude. Equation 21 arXiv:1508.07253
>  */
573c543,546
< // AmpIntColFitCoeff\[Chi]PNFunc[eta, chiPN][[2]] // CForm
---
> /**
>  * The function name stands for 'Amplitude Intermediate Collocation Fit Coefficient'
>  * This is the 'v2' value in Table 5 of arXiv:1508.07253
>  */
580,583c553,556
<   return 0.8193644340977788 + 2.519365484276569*eta
<     + (1.1630617232064524 - 2.302683026216893*eta + 6.086868143445912*eta2)*xi
<     + (0.7516886002177731 - 2.5295728215368083*eta + 6.06319783479259*eta2)*xi2
<     + (0.1736858389317789 - 0.7143291487179297*eta + 1.7339015693455153*eta2)*xi3;
---
>   return 0.8149838730507785 + 2.5747553517454658*eta
>   + (1.1610198035496786 - 2.3627771785551537*eta + 6.771038707057573*eta2)*xi
>   + (0.7570782938606834 - 2.7256896890432474*eta + 7.1140380397149965*eta2)*xi2
>   + (0.1766934149293479 - 0.7978690983168183*eta + 2.1162391502005153*eta2)*xi3;
585a559,567
>   /**
>   * The following functions (delta{0,1,2,3,4}_fun) were derived
>   * in mathematica according to
>   * the constraints detailed in arXiv:1508.07253,
>   * section 'Region IIa - intermediate'.
>   * These are not given in the paper.
>   * Can be rederived by solving Equation 21 for the constraints
>   * given in Equations 22-26 in arXiv:1508.07253
>   */
616c598
<   + 8*f13*f22*f32*v3 - 4*f12*f23*f32*v3) / (pow(f1 - f2,2)*pow(f1 - f3,3)*pow(-f2 + f3,2)));
---
>   + 8*f13*f22*f32*v3 - 4*f12*f23*f32*v3) / (pow_2_of(f1 - f2)*pow_3_of(f1 - f3)*pow_2_of(f3-f2)));
649c631
<   / (pow(f1 - f2,2)*pow(f1 - f3,3)*pow(-f2 + f3,2)));
---
>   / (pow_2_of(f1 - f2)*pow_3_of(f1 - f3)*pow_2_of(-f2 + f3)));
681c663
<   / (pow(f1 - f2,2)*pow(f1 - f3,3)*pow(-f2 + f3,2)));
---
>   / (pow_2_of(f1 - f2)*pow_3_of(f1 - f3)*pow_2_of(-f2 + f3)));
711c693
<   / (pow(f1 - f2,2)*pow(f1 - f3,3)*pow(-f2 + f3,2)));
---
>   / (pow_2_of(f1 - f2)*pow_3_of(f1 - f3)*pow_2_of(-f2 + f3)));
736c718
<   / (pow(f1 - f2,2)*pow(f1 - f3,3)*pow(-f2 + f3,2)));
---
>   / (pow_2_of(f1 - f2)*pow_3_of(f1 - f3)*pow_2_of(-f2 + f3)));
739c721,724
< // Calculates delta_i's
---
> /**
>  * Calculates delta_i's
>  * Method described in arXiv:1508.07253 section 'Region IIa - intermediate'
>  */
741,743c726,727
< 
<   // Four evenly spaced collocation points in the interval [f1,f4].
<   double f1 = 0.014;
---
>   // Three evenly spaced collocation points in the interval [f1,f3].
>   double f1 = AMP_fJoin_INS;
747a732,740
>   UsefulPowers powers_of_f1;
>   int status = init_useful_powers(&powers_of_f1, f1);
>   XLAL_CHECK_VOID ( status == XLAL_SUCCESS, XLAL_EFUNC, "Failed to initialize useful powers of f1.");
> 
>   AmpInsPrefactors prefactors;
>   status = init_amp_ins_prefactors(&prefactors, p);
>   XLAL_CHECK_VOID ( status == XLAL_SUCCESS, XLAL_EFUNC, "Failed to initialize amplitude prefactors for inspiral range.");
> 
> 
750,751c743,744
<   double v1 = AmpInsAnsatz(f1, p); // FIXME: depends on rho_i's
<   double d1 = DAmpInsAnsatz(f1, p); // FIXME: depends on rho_i's
---
>   double v1 = AmpInsAnsatz(f1, &powers_of_f1, &prefactors);
>   double d1 = DAmpInsAnsatz(f1, p);
753c746
<   // v4??? is merger-ringdown model evaluated at f3
---
>   // v3 is merger-ringdown model evaluated at f3
755,757c748,749
<   //
<   double v3 = AmpMRDAnsatz(f3, p); // FIXME: depends on gamma_i's
<   double d2 = DAmpMRDAnsatz(f3, p); // FIXME: depends on gamma_i's
---
>   double v3 = AmpMRDAnsatz(f3, p);
>   double d2 = DAmpMRDAnsatz(f3, p);
796c788,792
< static IMRPhenomDAmplitudeCoefficients* ComputeIMRPhenomDAmplitudeCoefficients(double eta, double chi1, double chi2) {
---
> /**
>  * A struct containing all the parameters that need to be calculated
>  * to compute the phenomenological amplitude
>  */
> static IMRPhenomDAmplitudeCoefficients* ComputeIMRPhenomDAmplitudeCoefficients(double eta, double chi1, double chi2, double finspin) {
806,807c802,803
<   p->fRD = fring(eta, chi1, chi2);
<   p->fDM = fdamp(eta, chi1, chi2);
---
>   p->fRD = fring(eta, chi1, chi2, finspin);
>   p->fDM = fdamp(eta, chi1, chi2, finspin);
814c810
<   p->fmaxCalc = fmaxCalc(p); // NOTE: needs the MR gamma_i coeffs already calculated in p!
---
>   p->fmaxCalc = fmaxCalc(p);
827c823,828
< static double IMRPhenDAmplitude(double f, IMRPhenomDAmplitudeCoefficients *p) {
---
> /**
>  * This function computes the IMR amplitude given phenom coefficients.
>  * Defined in VIII. Full IMR Waveforms arXiv:1508.07253
>  */
> static double IMRPhenDAmplitude(double f, IMRPhenomDAmplitudeCoefficients *p, UsefulPowers *powers_of_f, AmpInsPrefactors * prefactors) {
>   // Defined in VIII. Full IMR Waveforms arXiv:1508.07253
829d829
<   // FIXME: could avoid evaluating two of those when we are far enough away from one of the transition frequencies
832c832
<   p->fInsJoin = 0.014;
---
>   p->fInsJoin = AMP_fJoin_INS;
835,838c835,836
<   double AmpPreFac = amp0Func(p->eta) * pow(f, -7.0/6.0);
<   double AmpIns = AmpPreFac * AmpInsAnsatz(f, p);
<   double AmpInt = AmpPreFac * AmpIntAnsatz(f, p);
<   double AmpMRD = AmpPreFac * AmpMRDAnsatz(f, p);
---
>   double f_seven_sixths = f * powers_of_f->sixth;
>   double AmpPreFac = prefactors->amp0 / f_seven_sixths;
840,842c838
<   double df = 0.001; // frequency window length for Planck taper
<   double PT1 = PlanckTaper(f, p->fInsJoin, p->fInsJoin + df);
<   double PT2 = PlanckTaper(f, p->fMRDJoin, p->fMRDJoin + df);
---
>   // split the calculation to just 1 of 3 possible mutually exclusive ranges
844c840,854
<   return (1.0 - PT1) * AmpIns + PT1 * AmpInt * (1.0 - PT2) + PT2 * AmpMRD;
---
>   if (!StepFunc_boolean(f, p->fInsJoin))	// Inspiral range
>   {
> 	  double AmpIns = AmpPreFac * AmpInsAnsatz(f, powers_of_f, prefactors);
> 	  return AmpIns;
>   }
> 
>   if (StepFunc_boolean(f, p->fMRDJoin))	// MRD range
>   {
> 	  double AmpMRD = AmpPreFac * AmpMRDAnsatz(f, p);
> 	  return AmpMRD;
>   }
> 
>   //	Intermediate range
>   double AmpInt = AmpPreFac * AmpIntAnsatz(f, p);
>   return AmpInt;
851c861
< // alpha_i i=1,2,3 are the phenomenological intermediate coefficients depending on eta and chiPN
---
> // alpha_i i=1,2,3,4,5 are the phenomenological intermediate coefficients depending on eta and chiPN
853a864,866
> /**
>  * alpha 1 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
860,863c873,876
<   return 48.268391497848555 + 611.7245082528094*eta
<     + (-22.52115933057628 + 2432.0201299154805*eta - 6046.652884557147*eta2)*xi
<     + (-54.362482633751085 + 3011.8243021641515*eta - 9368.252485211071*eta2)*xi2
<     + (-19.68404253845273 + 1002.5518994042775*eta - 3362.9647886372677*eta2)*xi3;
---
>   return 43.31514709695348 + 638.6332679188081*eta
>     + (-32.85768747216059 + 2415.8938269370315*eta - 5766.875169379177*eta2)*xi
>     + (-61.85459307173841 + 2953.967762459948*eta - 8986.29057591497*eta2)*xi2
>     + (-21.571435779762044 + 981.2158224673428*eta - 3239.5664895930286*eta2)*xi3;
865a879,881
> /**
>  * alpha 2 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
872,875c888,891
<   return -0.0673058164684716 - 0.1830627533897372*eta
<     + (-0.18049467080235737 + 1.1177063913620364*eta - 2.9518177020311915*eta2)*xi
<     + (-0.16615004046059806 + 1.7202871344838704*eta - 4.7026420500401205*eta2)*xi2
<     + (-0.04865897674674206 + 0.6093863685081735*eta - 1.7372061063559312*eta2)*xi3;
---
>   return -0.07020209449091723 - 0.16269798450687084*eta
>   + (-0.1872514685185499 + 1.138313650449945*eta - 2.8334196304430046*eta2)*xi
>   + (-0.17137955686840617 + 1.7197549338119527*eta - 4.539717148261272*eta2)*xi2
>   + (-0.049983437357548705 + 0.6062072055948309*eta - 1.682769616644546*eta2)*xi3;
877a894,896
> /**
>  * alpha 3 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
884,887c903,906
<   return 6.6200489338307085 - 380.80778662617956*eta
<     + (7.990338219795906 - 1554.1611800117628*eta + 3689.0921582110873*eta2)*xi
<     + (19.552335169497248 - 1775.9434000999295*eta + 5262.501198452011*eta2)*xi2
<     + (8.970735925928109 - 574.9441185334387*eta + 1841.0002392874653*eta2)*xi3;
---
>   return 9.5988072383479 - 397.05438595557433*eta
>   + (16.202126189517813 - 1574.8286986717037*eta + 3600.3410843831093*eta2)*xi
>   + (27.092429659075467 - 1786.482357315139*eta + 5152.919378666511*eta2)*xi2
>   + (11.175710130033895 - 577.7999423177481*eta + 1808.730762932043*eta2)*xi3;
889a909,911
> /**
>  * alpha 4 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
896,899c918,921
<   return -0.03717271633074854 + 1.4261077580289205*eta
<     + (-0.10487146504736497 + 1.0535635483450132*eta - 0.20431576108236085*eta2)*xi
<     + (-0.09032850971624289 + 0.8708538997789368*eta + 0.02651866135290333*eta2)*xi2
<     + (-0.026912018722678448 + 0.26839255388193417*eta - 0.05860768899388999*eta2)*xi3;
---
>   return -0.02989487384493607 + 1.4022106448583738*eta
>   + (-0.07356049468633846 + 0.8337006542278661*eta + 0.2240008282397391*eta2)*xi
>   + (-0.055202870001177226 + 0.5667186343606578*eta + 0.7186931973380503*eta2)*xi2
>   + (-0.015507437354325743 + 0.15750322779277187*eta + 0.21076815715176228*eta2)*xi3;
901a924,926
> /**
>  * alpha 5 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
908,911c933,936
<   return 0.9929836969310366 + 0.003010359365293129*eta
<   + (-0.11319782076414776 + 1.9896055092224239*eta - 6.024331489827541*eta2)*xi
<   + (-0.13174717365370286 + 2.6346685770150726*eta - 8.278336740553794*eta2)*xi2
<   + (-0.044075227973024274 + 0.9030871993168443*eta - 2.860732570370078*eta2)*xi3;
---
>   return 0.9974408278363099 - 0.007884449714907203*eta
>   + (-0.059046901195591035 + 1.3958712396764088*eta - 4.516631601676276*eta2)*xi
>   + (-0.05585343136869692 + 1.7516580039343603*eta - 5.990208965347804*eta2)*xi2
>   + (-0.017945336522161195 + 0.5965097794825992*eta - 2.0608879367971804*eta2)*xi3;
914,915c939,952
< static double PhiMRDAnsatzInt(double f, IMRPhenomDPhaseCoefficients *p) {
<   return -(p->alpha2/f) + (4*p->alpha3*pow(f,0.75))/3. + p->alpha1*f + p->alpha4*atan((f - p->alpha5*p->fRD)/p->fDM);
---
> /**
>  * Ansatz for the merger-ringdown phase Equation 14 arXiv:1508.07253
>  */
> static double PhiMRDAnsatzInt(double f, IMRPhenomDPhaseCoefficients *p)
> {
>   double sqrootf = sqrt(f);
>   double fpow1_5 = f * sqrootf;
>   // check if this is any faster: 2 sqrts instead of one pow(x,0.75)
>   double fpow0_75 = sqrt(fpow1_5); // pow(f,0.75);
> 
>   return -(p->alpha2/f)
> 		 + (4.0/3.0) * (p->alpha3 * fpow0_75)
> 		 + p->alpha1 * f
> 		 + p->alpha4 * atan((f - p->alpha5 * p->fRD) / p->fDM);
917a955,957
> /**
>  * First frequency derivative of PhiMRDAnsatzInt
>  */
919c959
<   return (p->alpha1 + p->alpha2/pow(f,2) + p->alpha3/pow(f,0.25) + p->alpha4/(p->fDM*(1 + pow(f - p->alpha5*p->fRD,2)/pow(p->fDM,2)))) / p->eta;
---
>   return (p->alpha1 + p->alpha2/pow_2_of(f) + p->alpha3/pow(f,0.25) + p->alpha4/(p->fDM*(1 + pow_2_of(f - p->alpha5 * p->fRD)/pow_2_of(p->fDM)))) / p->eta;
929a970,972
> /**
>  * beta 1 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
936,939c979,982
<   return 97.45117083987036 - 41.31509513566375*eta
<     + (148.39440087200862 - 1358.654044408998*eta + 2610.1336681598723*eta2)*xi
<     + (131.6877588301213 - 1346.3392425741838*eta + 2636.2940288867408*eta2)*xi2
<     + (38.57251427350905 - 392.6296853455257*eta + 770.252899105536*eta2)*xi3;
---
>   return 97.89747327985583 - 42.659730877489224*eta
>   + (153.48421037904913 - 1417.0620760768954*eta + 2752.8614143665027*eta2)*xi
>   + (138.7406469558649 - 1433.6585075135881*eta + 2857.7418952430758*eta2)*xi2
>   + (41.025109467376126 - 423.680737974639*eta + 850.3594335657173*eta2)*xi3;
941a985,987
> /**
>  * beta 2 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
948,951c994,997
<   return -3.2804577873466485 - 9.06185751848799*eta
<     + (-12.414871795376841 + 55.49086816210587*eta - 106.12827149099643*eta2)*xi
<     + (-11.957149752470606 + 76.85798857225546*eta - 155.4568382340443*eta2)*xi2
<     + (-3.414799615653319 + 25.58891148247438*eta - 54.44356409784692*eta2)*xi3;
---
>   return -3.282701958759534 - 9.051384468245866*eta
>   + (-12.415449742258042 + 55.4716447709787*eta - 106.05109938966335*eta2)*xi
>   + (-11.953044553690658 + 76.80704618365418*eta - 155.33172948098394*eta2)*xi2
>   + (-3.4129261592393263 + 25.572377569952536*eta - 54.408036707740465*eta2)*xi3;
953a1000,1002
> /**
>  * beta 3 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
960,963c1009,1012
<   return -0.000025165874934707377 + 0.00001979585325937374*eta
<     + (-0.000018380049120626495 + 0.000021869365408771506*eta + 0.00008271002269128104*eta2)*xi
<     + (7.162864746777629e-6 - 0.000055897084288544904*eta + 0.00019176840794129924*eta2)*xi2
<     + (5.4509322526231396e-6 - 0.00003224698772106724*eta + 0.00007984258587881925*eta2)*xi3;
---
>   return -0.000025156429818799565 + 0.000019750256942201327*eta
>   + (-0.000018370671469295915 + 0.000021886317041311973*eta + 0.00008250240316860033*eta2)*xi
>   + (7.157371250566708e-6 - 0.000055780000112270685*eta + 0.00019142082884072178*eta2)*xi2
>   + (5.447166261464217e-6 - 0.00003220610095021982*eta + 0.00007974016714984341*eta2)*xi3;
965a1015,1017
> /**
>  * ansatz for the intermediate phase defined by Equation 16 arXiv:1508.07253
>  */
967c1019,1022
<   return  p->beta1*Mf - p->beta3/(3.*pow(Mf,3)) + p->beta2*log(Mf);
---
>   // 1./eta in paper omitted and put in when need in the functions:
>   // ComputeIMRPhenDPhaseConnectionCoefficients
>   // IMRPhenDPhase
>   return  p->beta1*Mf - p->beta3/(3.*pow_3_of(Mf)) + p->beta2*log(Mf);
969a1025,1028
> /**
>  * First frequency derivative of PhiIntAnsatz
>  * (this time with 1./eta explicitly factored in)
>  */
971c1030
<   return (p->beta1 + p->beta3/pow(Mf,4) + p->beta2/Mf) / p->eta;
---
>   return (p->beta1 + p->beta3/pow_4_of(Mf) + p->beta2/Mf) / p->eta;
973a1033,1036
> /**
>  * temporary instance of DPhiIntAnsatz used when computing
>  * coefficients to make the phase C(1) continuous between regions.
>  */
981c1044
<   return C2Int + (beta1 + beta3/pow(ff,4) + beta2/ff)/eta;
---
>   return C2Int + (beta1 + beta3/pow_4_of(ff) + beta2/ff)/eta;
988a1052,1054
> /**
>  * sigma 1 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
995,998c1061,1064
<   return 2096.155693064352 + 1464.8669504930606*eta
<     + (1307.4284854073637 + 18366.582650093205*eta - 43679.41361741789*eta2)*xi
<     + (-840.5072830340943 + 32136.410168522973*eta - 108834.93282891942*eta2)*xi2
<     + (449.7311701253021 + 8385.049840384685*eta - 44612.56586161423*eta2)*xi3;
---
>   return 2096.551999295543 + 1463.7493168261553*eta
>   + (1312.5493286098522 + 18307.330017082117*eta - 43534.1440746107*eta2)*xi
>   + (-833.2889543511114 + 32047.31997183187*eta - 108609.45037520859*eta2)*xi2
>   + (452.25136398112204 + 8353.439546391714*eta - 44531.3250037322*eta2)*xi3;
1000a1067,1069
> /**
>  * sigma 2 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
1007,1010c1076,1079
<   return -10114.056476682446 - 44631.01107848535*eta
<     + (-6541.308770527784 - 266959.2342301296*eta + 686328.3232181441*eta2)*xi
<     + (3405.6372141416923 - 437507.720946488*eta + 1.6318171313072182e6*eta2)*xi2
<     + (-7462.6485633155735 - 114585.25183484034*eta + 674402.4691673126*eta2)*xi3;
---
>   return -10114.056472621156 - 44631.01109458185*eta
>   + (-6541.308761668722 - 266959.23419307504*eta + 686328.3229317984*eta2)*xi
>   + (3405.6372187679685 - 437507.7208209015*eta + 1.6318171307344697e6*eta2)*xi2
>   + (-7462.648563007646 - 114585.25177153319*eta + 674402.4689098676*eta2)*xi3;
1012a1082,1084
> /**
>  * sigma 3 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
1019,1022c1091,1094
<   return 22933.658292557113 + 230960.008073928*eta
<     + (14961.084015996932 + 1.1940181344003242e6*eta - 3.1042239706327254e6*eta2)*xi
<     + (-3038.1665950966894 + 1.8720322854868704e6*eta - 7.309145014733551e6*eta2)*xi2
<     + (42738.22871637542 + 467502.01890796213*eta - 3.0648534997008806e6*eta2)*xi3;
---
>   return 22933.658273436497 + 230960.00814979506*eta
>   + (14961.083974183695 + 1.1940181342318142e6*eta - 3.1042239693052764e6*eta2)*xi
>   + (-3038.166617199259 + 1.8720322849093592e6*eta - 7.309145012085539e6*eta2)*xi2
>   + (42738.22871475411 + 467502.018616601*eta - 3.064853498512499e6*eta2)*xi3;
1024a1097,1099
> /**
>  * sigma 4 phenom coefficient. See corresponding row in Table 5 arXiv:1508.07253
>  */
1031,1034c1106,1109
<   return -14621.715252090613 - 377812.8578198768*eta
<     + (-9608.682697135695 - 1.7108925259726832e6*eta + 4.332924603450101e6*eta2)*xi
<     + (-22366.683297514493 - 2.5019716395126972e6*eta + 1.0274495906301545e7*eta2)*xi2
<     + (-85360.30079323666 - 570025.3446157051*eta + 4.396844348659892e6*eta2)*xi3;
---
>   return -14621.71522218357 - 377812.8579387104*eta
>   + (-9608.682631509726 - 1.7108925257214056e6*eta + 4.332924601416521e6*eta2)*xi
>   + (-22366.683262266528 - 2.5019716386377467e6*eta + 1.0274495902259542e7*eta2)*xi2
>   + (-85360.30079034246 - 570025.3441737515*eta + 4.396844346849777e6*eta2)*xi3;
1037,1054c1112,1121
< static double PhiInsAnsatzInt(double Mf, IMRPhenomDPhaseCoefficients *p) {
<   double eta = p->eta;
<   double chi1 = p->chi1;
<   double chi2 = p->chi2;
<   double sigma1 = p->sigma1;
<   double sigma2 = p->sigma2;
<   double sigma3 = p->sigma3;
<   double sigma4 = p->sigma4;
< 
<   // Obtain LAL TaylorF2 phasing coefficients which are tested in ../test/PNCoefficients.c.
<   // FIXME: MP: we probably only want to call XLALSimInspiralTaylorF2AlignedPhasing() once per waveform
<   // and save the coefficients somewhere.
<   // E.g., we could just store the pointer to the PNPhasingSeries struct in IMRPhenomDPhaseCoefficients!
<   // PNPhasingSeries *pn = NULL;
<   // // Convention m1 >= m2
<   // double m1 = 0.5 * (1.0 + sqrt(1.0 - 4.0*eta));
<   // double m2 = 0.5 * (1.0 - sqrt(1.0 - 4.0*eta));
<   // XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1, chi2, 1, 1, LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
---
> /**
>  * Ansatz for the inspiral phase.
>  * We call the LAL TF2 coefficients here.
>  * The exact values of the coefficients used are given
>  * as comments in the top of this file
>  * Defined by Equation 27 and 28 arXiv:1508.07253
>  */
> static double PhiInsAnsatzInt(double Mf, UsefulPowers * powers_of_Mf, PhiInsPrefactors * prefactors, IMRPhenomDPhaseCoefficients *p, PNPhasingSeries *pn)
> {
> 	XLAL_CHECK(0 != pn, XLAL_EFAULT, "pn is NULL");
1057c1124
<   const double v = cbrt(Pi*Mf);
---
>   const double v = powers_of_Mf->third * powers_of_pi.third;
1059,1064d1125
<   const double v2 = v * v;
<   const double v3 = v * v2;
<   const double v4 = v * v3;
<   const double v5 = v * v4;
<   const double v6 = v * v5;
<   // const double v7 = v * v6;
1066,1076c1127,1136
<   // double phasing = 0.0;
<   // phasing += pn->v[7] * v7;
<   // phasing += (pn->v[6] + pn->vlogv[6] * logv) * v6;
<   // phasing += (pn->v[5] + pn->vlogv[5] * logv) * v5;
<   // phasing += pn->v[4] * v4;
<   // phasing += pn->v[3] * v3;
<   // phasing += pn->v[2] * v2;
<   // phasing += pn->v[0]; // * v^0
<   // phasing /= v5;
<   // phasing -= LAL_PI_4;
<   // LALFree(pn);
---
>   double phasing = prefactors->initial_phasing;
> 
>   phasing += prefactors->two_thirds	* powers_of_Mf->two_thirds;
>   phasing += prefactors->third * powers_of_Mf->third;
>   phasing += prefactors->third_with_logv * logv * powers_of_Mf->third;
>   phasing += prefactors->logv * logv;
>   phasing += prefactors->minus_third / powers_of_Mf->third;
>   phasing += prefactors->minus_two_thirds / powers_of_Mf->two_thirds;
>   phasing += prefactors->minus_one / Mf;
>   phasing += prefactors->minus_five_thirds / powers_of_Mf->five_thirds; // * v^0
1079,1122c1139,1142
<   // phasing += (
<   //           (sigma1/Pi) * v3
<   //         + (3.0/(4.0*pow(Pi,4.0/3.0))*sigma2) * v4
<   //         + (3.0/(5.0*pow(Pi,5.0/3.0))*sigma3) * v5
<   //         + (1.0/(2.0*Pi*Pi)*sigma4) * v6
<   //         ) / eta;
< 
<   // Note: MP: this is the CForm of the TF2 phase from Mathematica
<   // Ultimately, we want to use the expression above using LAL TF2 coefficients.
<   // FIXME: optimize
<   double eta2 = eta*eta;
<   double Pi2 = Pi*Pi;
<   double phasing = (6065*(chi1 + chi2))/1728. - (35*(chi1 - chi2)*sqrt(1 - 4*eta))/192. \
< - (732985*(chi1 + chi2))/(193536.*eta) - (732985*(chi1 - chi2)*sqrt(1 \
< - 4*eta))/(193536.*eta) + (85*(chi1 + chi2)*eta)/192. - (161*Pi)/384. \
< + (38645*Pi)/(32256.*eta) + 3/(128.*eta*v5) + 55/(384.*v3) + \
< 3715/(32256.*eta*v3) - (19*(chi1 + chi2))/(64.*v2) + (113*(chi1 + \
< chi2))/(256.*eta*v2) + (113*(chi1 - chi2)*sqrt(1 - \
< 4*eta))/(256.*eta*v2) - (3*Pi)/(8.*eta*v2) + 27145/(21504.*v) + \
< (75*pow(chi1 - chi2,2))/(64.*v) + (15*pow(chi1 + \
< chi2,2))/(1024.*v) + 15293365/(2.1676032e7*eta*v) - (1215*pow(chi1 \
< - chi2,2))/(4096.*eta*v) - (1215*pow(chi1 + chi2,2))/(4096.*eta*v) \
< - (1215*(chi1 - chi2)*(chi1 + chi2)*sqrt(1 - 4*eta))/(2048.*eta*v) + \
< (3085*eta)/(3072.*v) - (15737765635*v)/1.30056192e8 + \
< (11583231236531*v)/(2.0028653568e11*eta) + (76055*eta*v)/73728. - \
< (127825*eta2*v)/55296. - (107*EulerGamma*v)/(14.*eta) - (195*(chi1 + \
< chi2)*Pi*v)/32. + (1135*(chi1 + chi2)*Pi*v)/(128.*eta) + (1135*(chi1 \
< - chi2)*sqrt(1 - 4*eta)*Pi*v)/(128.*eta) + (2255*Pi2*v)/512. - \
< (5*Pi2*v)/eta + (10566655595*(chi1 + chi2)*v2)/6.5028096e7 + \
< (26804935*(chi1 - chi2)*sqrt(1 - 4*eta)*v2)/516096. - \
< (25150083775*(chi1 + chi2)*v2)/(2.60112384e8*eta) - \
< (25150083775*(chi1 - chi2)*sqrt(1 - 4*eta)*v2)/(2.60112384e8*eta) - \
< (1042165*(chi1 + chi2)*eta*v2)/258048. - (1985*(chi1 - chi2)*sqrt(1 - \
< 4*eta)*eta*v2)/4096. + (5345*(chi1 + chi2)*eta2*v2)/3072. + \
< (378515*Pi*v2)/64512. + (77096675*Pi*v2)/(1.0838016e7*eta) - \
< (74045*eta*Pi*v2)/32256. + ((sigma1*v3)/Pi + \
< (3*sigma2*v4)/(4.*pow(Pi,1.3333333333333333)) + \
< (3*sigma3*v5)/(5.*pow(Pi,1.6666666666666667)) + \
< (sigma4*v6)/(2.*Pi2))/eta - (107*v*log(2))/(7.*eta) + (6065*(chi1 + \
< chi2)*logv)/576. - (35*(chi1 - chi2)*sqrt(1 - 4*eta)*logv)/64. - \
< (732985*(chi1 + chi2)*logv)/(64512.*eta) - (732985*(chi1 - \
< chi2)*sqrt(1 - 4*eta)*logv)/(64512.*eta) + (85*(chi1 + \
< chi2)*eta*logv)/64. - (65*Pi*logv)/128. + \
< (38645*Pi*logv)/(10752.*eta) - (107*v*logv)/(14.*eta);
---
>   phasing += ( prefactors->one * Mf + prefactors->four_thirds * powers_of_Mf->four_thirds
> 			   + prefactors->five_thirds * powers_of_Mf->five_thirds
> 			   + prefactors->two * powers_of_Mf->two
> 			 ) / p->eta;
1127,1130c1147,1181
< static double DPhiInsAnsatzInt(double Mf, IMRPhenomDPhaseCoefficients *p) {
<   double eta = p->eta;
<   double chi1 = p->chi1;
<   double chi2 = p->chi2;
---
> static int init_phi_ins_prefactors(PhiInsPrefactors * prefactors, IMRPhenomDPhaseCoefficients* p, PNPhasingSeries *pn)
> {
> 	XLAL_CHECK(0 != p, XLAL_EFAULT, "p is NULL");
> 	XLAL_CHECK(0 != prefactors, XLAL_EFAULT, "prefactors is NULL");
> 
> 	double sigma1 = p->sigma1;
> 	double sigma2 = p->sigma2;
> 	double sigma3 = p->sigma3;
> 	double sigma4 = p->sigma4;
> 	double Pi = LAL_PI;
> 
>   // PN phasing series
> 	prefactors->initial_phasing = pn->v[5] - LAL_PI_4;
> 	prefactors->two_thirds = pn->v[7] * powers_of_pi.two_thirds;
> 	prefactors->third = pn->v[6] * powers_of_pi.third;
> 	prefactors->third_with_logv = pn->vlogv[6] * powers_of_pi.third;
> 	prefactors->logv = pn->vlogv[5];
> 	prefactors->minus_third = pn->v[4] / powers_of_pi.third;
> 	prefactors->minus_two_thirds = pn->v[3] / powers_of_pi.two_thirds;
> 	prefactors->minus_one = pn->v[2] / Pi;
> 	prefactors->minus_five_thirds = pn->v[0] / powers_of_pi.five_thirds; // * v^0
> 
>   // higher order terms that were calibrated for PhenomD
> 	prefactors->one = sigma1;
> 	prefactors->four_thirds = sigma2 * 3.0/4.0;
> 	prefactors->five_thirds = sigma3 * 3.0/5.0;
> 	prefactors->two = sigma4 / 2.0;
> 
> 	return XLAL_SUCCESS;
> }
> 
> /**
>  * First frequency derivative of PhiInsAnsatzInt
>  */
> static double DPhiInsAnsatzInt(double Mf, IMRPhenomDPhaseCoefficients *p, PNPhasingSeries *pn) {
1135,1144c1186
< 
<   // Obtain LAL TaylorF2 phasing coefficients which are tested in ../test/PNCoefficients.c.
<   // FIXME: MP: we probably only want to call XLALSimInspiralTaylorF2AlignedPhasing() once per waveform
<   // and save the coefficients somewhere.
<   // E.g., we could just store the pointer to the PNPhasingSeries struct in IMRPhenomDPhaseCoefficients!
<   // PNPhasingSeries *pn = NULL;
<   // // Convention m1 >= m2
<   // double m1 = 0.5 * (1.0 + sqrt(1.0 - 4.0*eta));
<   // double m2 = 0.5 * (1.0 - sqrt(1.0 - 4.0*eta));
<   // XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1, chi2, 1, 1, LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
---
>   double Pi = LAL_PI;
1159,1168c1201,1209
<   // double Dphasing = 0.0;
<   // Dphasing += +2.0 * pn->v[7] * v7;
<   // Dphasing += (pn->v[6] + pn->vlogv[6] * (1.0 + logv)) * v6;
<   // Dphasing += pn->vlogv[5] * v5;
<   // Dphasing += -1.0 * pn->v[4] * v4;
<   // Dphasing += -2.0 * pn->v[3] * v3;
<   // Dphasing += -3.0 * pn->v[2] * v2;
<   // Dphasing += -5.0 * pn->v[0];
<   // Dphasing /= v8 * 3.0/Pi;
<   // LALFree(pn);
---
>   double Dphasing = 0.0;
>   Dphasing += +2.0 * pn->v[7] * v7;
>   Dphasing += (pn->v[6] + pn->vlogv[6] * (1.0 + logv)) * v6;
>   Dphasing += pn->vlogv[5] * v5;
>   Dphasing += -1.0 * pn->v[4] * v4;
>   Dphasing += -2.0 * pn->v[3] * v3;
>   Dphasing += -3.0 * pn->v[2] * v2;
>   Dphasing += -5.0 * pn->v[0];
>   Dphasing /= v8 * 3.0/Pi;
1171,1213c1212,1217
<   // Dphasing += (
<   //         sigma1
<   //       + (pow(Pi, -1.0/3.0)*sigma2) * v
<   //       + (pow(Pi, -2.0/3.0)*sigma3) * v2
<   //       + (sigma4/Pi) * v3
<   //       ) / eta;
< 
<   // Note: MP: this is the CForm of the TF2 phase derivative from Mathematica
<   // Ultimately, we want to use the expression above using LAL TF2 coefficients.
<   // optimized CForm
<   double eta2 = eta*eta;
<   double Pi2 = Pi*Pi;
<   double Pi3 = Pi*Pi2;
<   double Dphasing = (-5*Pi)/(128.*eta*v8) - (55*Pi)/(384.*v6) - \
< (3715*Pi)/(32256.*eta*v6) + (19*(chi1 + chi2)*Pi)/(96.*v5) - \
< (113*(chi1 + chi2)*Pi)/(384.*eta*v5) - (113*(chi1 - chi2)*sqrt(1 - \
< 4*eta)*Pi)/(384.*eta*v5) + Pi2/(4.*eta*v5) - (27145*Pi)/(64512.*v4) - \
< (25*pow(chi1 - chi2,2)*Pi)/(64.*v4) - (5*pow(chi1 + \
< chi2,2)*Pi)/(1024.*v4) - (15293365*Pi)/(6.5028096e7*eta*v4) + \
< (405*pow(chi1 - chi2,2)*Pi)/(4096.*eta*v4) + (405*pow(chi1 + \
< chi2,2)*Pi)/(4096.*eta*v4) + (405*(chi1 - chi2)*(chi1 + chi2)*sqrt(1 \
< - 4*eta)*Pi)/(2048.*eta*v4) - (3085*eta*Pi)/(9216.*v4) + (6065*(chi1 \
< + chi2)*Pi)/(1728.*v3) - (35*(chi1 - chi2)*sqrt(1 - \
< 4*eta)*Pi)/(192.*v3) - (732985*(chi1 + chi2)*Pi)/(193536.*eta*v3) - \
< (732985*(chi1 - chi2)*sqrt(1 - 4*eta)*Pi)/(193536.*eta*v3) + \
< (85*(chi1 + chi2)*eta*Pi)/(192.*v3) - (65*Pi2)/(384.*v3) + \
< (38645*Pi2)/(32256.*eta*v3) - (15737765635*Pi)/(3.90168576e8*v2) + \
< (10052469856691*Pi)/(6.0085960704e11*eta*v2) + \
< (76055*eta*Pi)/(221184.*v2) - (127825*eta2*Pi)/(165888.*v2) - \
< (107*EulerGamma*Pi)/(42.*eta*v2) - (65*(chi1 + chi2)*Pi2)/(32.*v2) + \
< (1135*(chi1 + chi2)*Pi2)/(384.*eta*v2) + (1135*(chi1 - chi2)*sqrt(1 - \
< 4*eta)*Pi2)/(384.*eta*v2) + (2255*Pi3)/(1536.*v2) - \
< (5*Pi3)/(3.*eta*v2) + (10566655595*(chi1 + chi2)*Pi)/(9.7542144e7*v) \
< + (26804935*(chi1 - chi2)*sqrt(1 - 4*eta)*Pi)/(774144.*v) - \
< (25150083775*(chi1 + chi2)*Pi)/(3.90168576e8*eta*v) - \
< (25150083775*(chi1 - chi2)*sqrt(1 - 4*eta)*Pi)/(3.90168576e8*eta*v) - \
< (1042165*(chi1 + chi2)*eta*Pi)/(387072.*v) - (1985*(chi1 - \
< chi2)*sqrt(1 - 4*eta)*eta*Pi)/(6144.*v) + (5345*(chi1 + \
< chi2)*eta2*Pi)/(4608.*v) + (378515*Pi2)/(96768.*v) + \
< (77096675*Pi2)/(1.6257024e7*eta*v) - (74045*eta*Pi2)/(48384.*v) + \
< (sigma1 + (sigma2*v)/pow(Pi,0.3333333333333333) + \
< (sigma3*v2)/pow(Pi,0.6666666666666666) + (sigma4*v3)/Pi)/eta - \
< (107*Pi*log(2))/(21.*eta*v2) - (107*Pi*logv)/(42.*eta*v2);
---
>   Dphasing += (
>           sigma1
>         + sigma2 * v / powers_of_pi.third
>         + sigma3 * v2 / powers_of_pi.two_thirds
>         + (sigma4/Pi) * v3
>         ) / p->eta;
1220c1224,1228
< static IMRPhenomDPhaseCoefficients* ComputeIMRPhenomDPhaseCoefficients(double eta, double chi1, double chi2) {
---
> /**
>  * A struct containing all the parameters that need to be calculated
>  * to compute the phenomenological phase
>  */
> static IMRPhenomDPhaseCoefficients* ComputeIMRPhenomDPhaseCoefficients(double eta, double chi1, double chi2, double finspin) {
1246,1247c1254,1255
<   p->fRD = fring(eta, chi1, chi2);
<   p->fDM = fdamp(eta, chi1, chi2);
---
>   p->fRD = fring(eta, chi1, chi2, finspin);
>   p->fDM = fdamp(eta, chi1, chi2, finspin);
1252c1260,1266
< static void ComputeIMRPhenDPhaseConnectionCoefficients(IMRPhenomDPhaseCoefficients *p) {
---
> /**
>  * This function aligns the three phase parts (inspiral, intermediate and merger-rindown)
>  * such that they are c^1 continuous at the transition frequencies
>  * Defined in VIII. Full IMR Waveforms arXiv:1508.07253
>  */
> static void ComputeIMRPhenDPhaseConnectionCoefficients(IMRPhenomDPhaseCoefficients *p, PNPhasingSeries *pn, PhiInsPrefactors * prefactors)
> {
1256c1270,1271
<   p->fInsJoin=0.018;
---
>   // Defined in VIII. Full IMR Waveforms arXiv:1508.07253
>   p->fInsJoin=PHI_fJoin_INS;
1265c1280
<   double DPhiIns = DPhiInsAnsatzInt(p->fInsJoin, p);
---
>   double DPhiIns = DPhiInsAnsatzInt(p->fInsJoin, p, pn);
1268c1283,1286
<   p->C1Int = PhiInsAnsatzInt(p->fInsJoin, p)
---
> 
>   UsefulPowers powers_of_fInsJoin;
>   init_useful_powers(&powers_of_fInsJoin, p->fInsJoin);
>   p->C1Int = PhiInsAnsatzInt(p->fInsJoin, &powers_of_fInsJoin, prefactors, p, pn)
1286c1304,1310
< static double IMRPhenDPhase(double f, IMRPhenomDPhaseCoefficients *p) {
---
> /**
>  * This function computes the IMR phase given phenom coefficients.
>  * Defined in VIII. Full IMR Waveforms arXiv:1508.07253
>  */
> static double IMRPhenDPhase(double f, IMRPhenomDPhaseCoefficients *p, PNPhasingSeries *pn, UsefulPowers *powers_of_f, PhiInsPrefactors * prefactors)
> {
>   // Defined in VIII. Full IMR Waveforms arXiv:1508.07253
1288,1291d1311
<   // FIXME: could avoid evaluating two of those when we are far enough away from one of the transition frequencies
<   double PhiIns = PhiInsAnsatzInt(f, p);
<   double PhiInt = 1.0/p->eta * PhiIntAnsatz(f, p) + p->C1Int + p->C2Int * f;
<   double PhiMRD = 1.0/p->eta * PhiMRDAnsatzInt(f, p) + p->C1MRD + p->C2MRD * f;
1293,1296c1313,1325
<   double df1 = 0.0001; // frequency window length for Planck taper
<   double df2 = 0.005; // frequency window length for Planck taper
<   double PT1 = PlanckTaper(f, p->fInsJoin, p->fInsJoin + df1);
<   double PT2 = PlanckTaper(f, p->fMRDJoin, p->fMRDJoin + df2);
---
>   // split the calculation to just 1 of 3 possible mutually exclusive ranges
> 
>   if (!StepFunc_boolean(f, p->fInsJoin))	// Inspiral range
>   {
> 	  double PhiIns = PhiInsAnsatzInt(f, powers_of_f, prefactors, p, pn);
> 	  return PhiIns;
>   }
> 
>   if (StepFunc_boolean(f, p->fMRDJoin))	// MRD range
>   {
> 	  double PhiMRD = 1.0/p->eta * PhiMRDAnsatzInt(f, p) + p->C1MRD + p->C2MRD * f;
> 	  return PhiMRD;
>   }
1298c1327,1346
<   return (1.0 - PT1) * PhiIns + PT1 * PhiInt * (1.0 - PT2) + PT2 * PhiMRD;
---
>   //	Intermediate range
>   double PhiInt = 1.0/p->eta * PhiIntAnsatz(f, p) + p->C1Int + p->C2Int * f;
>   return PhiInt;
> }
> 
> /**
>  * Subtract 3PN spin-spin term below as this is in LAL's TaylorF2 implementation
>  * (LALSimInspiralPNCoefficients.c -> XLALSimInspiralPNPhasing_F2), but
>  * was not available when PhenomD was tuned.
>  */
> static double Subtract3PNSS(double m1, double m2, double M, double chi1, double chi2) {
>   REAL8 eta = m1 * m2 / (M * M);
>   REAL8 chi1sq = chi1 * chi1;
>   REAL8 chi2sq = chi2 * chi2;
>   REAL8 m1M = m1 / M;
>   REAL8 m2M = m2 / M;
>   REAL8 pn_ss3 =  (326.75L/1.12L + 557.5L/1.8L*eta)*eta*chi1*chi2;
>   pn_ss3 += ((4703.5L/8.4L+2935.L/6.L*m1M-120.L*m1M*m1M) + (-4108.25L/6.72L-108.5L/1.2L*m1M+125.5L/3.6L*m1M*m1M)) *m1M*m1M * chi1sq;
>   pn_ss3 += ((4703.5L/8.4L+2935.L/6.L*m2M-120.L*m2M*m2M) + (-4108.25L/6.72L-108.5L/1.2L*m2M+125.5L/3.6L*m2M*m2M)) *m2M*m2M * chi2sq;
>   return pn_ss3;
Only in .: LALSimIMRPhenomD_internals.h
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomD.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenom.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenom.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPhenomP.c ./LALSimIMRPhenomP.c
3,5d2
<  *  Reuses code found in:
<  *    - LALSimIMRPhenomC
<  *    - LALSimInspiralSpinTaylorF2
22a20,25
> #ifdef __GNUC__
> #define UNUSED __attribute__ ((unused))
> #else
> #define UNUSED
> #endif
> 
24a28
> #include <float.h>
37a42,43
> #include <lal/LALStdlib.h>
> #include <lal/LALStddef.h>
40c46,50
< #include "LALSimIMRPhenomC_internals.c" /* This is ugly, but allows us to reuse internal PhenomC functions without making those functions XLAL */
---
> /* This is ugly, but allows us to reuse internal IMRPhenomC and IMRPhenomD functions without making those functions XLAL */
> #include "LALSimIMRPhenomC_internals.c"
> #include "LALSimIMRPhenomD_internals.c"
> 
> #include "LALSimIMRPhenomP.h"
46,159c56
< 
< /* ************************** PhenomP internal function prototypes *****************************/
< 
< /* PhenomC parameters for modified ringdown: Uses final spin formula of Barausse & Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009 */
< static BBHPhenomCParams *ComputeIMRPhenomCParamsRDmod(
<   const REAL8 m1,   /**< Mass of companion 1 (solar masses) */
<   const REAL8 m2,   /**< Mass of companion 2 (solar masses) */
<   const REAL8 chi,  /**< Reduced aligned spin of the binary chi = (m1*chi1 + m2*chi2)/M */
<   const REAL8 chip  /**< Dimensionless spin in the orbital plane */
< );
< 
< typedef struct tagNNLOanglecoeffs {
<     REAL8 alphacoeff1; /* Coefficient of omega^(-1)   in alphaNNLO */
<     REAL8 alphacoeff2; /* Coefficient of omega^(-2/3) in alphaNNLO */
<     REAL8 alphacoeff3; /* Coefficient of omega^(-1/3) in alphaNNLO */
<     REAL8 alphacoeff4; /* Coefficient of log(omega)   in alphaNNLO */
<     REAL8 alphacoeff5; /* Coefficient of omega^(1/3)  in alphaNNLO */
< 
<     REAL8 epsiloncoeff1; /* Coefficient of omega^(-1)   in epsilonNNLO */
<     REAL8 epsiloncoeff2; /* Coefficient of omega^(-2/3) in epsilonNNLO */
<     REAL8 epsiloncoeff3; /* Coefficient of omega^(-1/3) in epsilonNNLO */
<     REAL8 epsiloncoeff4; /* Coefficient of log(omega)   in epsilonNNLO */
<     REAL8 epsiloncoeff5; /* Coefficient of omega^(1/3)  in epsilonNNLO */
< } NNLOanglecoeffs;
< 
< static void ComputeNNLOanglecoeffs(
<   NNLOanglecoeffs *angcoeffs,  /**< Output: Structure to store results */
<   const REAL8 q,               /**< Mass-ratio (convention q>1) */
<   const REAL8 chil,            /**< Dimensionless aligned spin of the largest BH */
<   const REAL8 chip             /**< Dimensionless spin component in the orbital plane */
< );
< 
< typedef struct tagSpinWeightedSphericalHarmonic_l2 {
<   COMPLEX16 Y2m2, Y2m1, Y20, Y21, Y22;
< } SpinWeightedSphericalHarmonic_l2;
< 
< /* Internal core function to calculate PhenomP polarizations for a sequence of frequences. */
< static int PhenomPCore(
<   COMPLEX16FrequencySeries **hptilde,   /**< Output: Frequency-domain waveform h+ */
<   COMPLEX16FrequencySeries **hctilde,   /**< Output: Frequency-domain waveform hx */
<   const REAL8 chi_eff,                  /**< Effective aligned spin */
<   const REAL8 chip,                     /**< Effective spin in the orbital plane */
<   const REAL8 eta,                      /**< Symmetric mass-ratio */
<   const REAL8 thetaJ,                   /**< Angle between J0 and line of sight (z-direction) */
<   const REAL8 Mtot_SI,                  /**< Total mass of binary (kg) */
<   const REAL8 distance,                 /**< Distance of source (m) */
<   const REAL8 alpha0,                   /**< Initial value of alpha angle (azimuthal precession angle) */
<   const REAL8 phic,                     /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   const REAL8 f_ref,                    /**< Reference frequency */
<   const REAL8Sequence *freqs,           /**< Frequency points at which to evaluate the waveform (Hz) */
<   double deltaF
<   /**< If deltaF > 0, the frequency points given in freqs are uniformly spaced with
<    * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
<    * Then we will use deltaF = 0 to create the frequency series we return. */
< );
< 
< /* Internal core function to calculate PhenomP polarizations for a single frequency. */
< static int PhenomPCoreOneFrequency(
<   const REAL8 fHz,                        /**< Frequency (Hz) */
<   const REAL8 eta,                        /**< Symmetric mass ratio */
<   const REAL8 chi_eff,                    /**< Dimensionless effective total aligned spin */
<   const REAL8 chip,                       /**< Dimensionless spin in the orbital plane */
<   const REAL8 distance,                   /**< Distance of source (m) */
<   const REAL8 M,                          /**< Total mass (Solar masses) */
<   const REAL8 phic,                       /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   BBHPhenomCParams *PCparams,             /**< Internal PhenomC parameters */
<   NNLOanglecoeffs *angcoeffs,             /**< Struct with PN coeffs for the NNLO angles */
<   SpinWeightedSphericalHarmonic_l2 *Y2m,  /**< Struct of l=2 spherical harmonics of spin weight -2 */
<   const REAL8 alphaoffset,                /**< f_ref dependent offset for alpha angle */
<   const REAL8 epsilonoffset,              /**< f_ref dependent offset for epsilon angle */
<   COMPLEX16 *hp,                          /**< Output: \f$\tilde h_+\f$ */
<   COMPLEX16 *hc,                          /**< Output: \f$\tilde h_+\f$ */
<   REAL8 *phasing                          /**< Output: overall phasing */
< );
< 
< /* Simple 2PN version of L, without any spin terms expressed as a function of v */
< static REAL8 L2PNR(
<   const REAL8 v,   /**< Cubic root of (Pi * Frequency (geometric)) */
<   const REAL8 eta  /**< Symmetric mass-ratio */
< );
< 
< static void WignerdCoefficients(
<   const REAL8 v,          /**< Cubic root of (Pi * Frequency (geometric)) */
<   const REAL8 SL,         /**< Dimensionfull aligned spin */
<   const REAL8 eta,        /**< Symmetric mass-ratio */
<   const REAL8 Sp,         /**< Dimensionfull spin component in the orbital plane */
<   REAL8 *cos_beta_half,   /**< Output: cos(beta/2) */
<   REAL8 *sin_beta_half    /**< Output: sin(beta/2) */
< );
< 
< static REAL8 FinalSpinBarausse2009_all_spin_on_larger_BH(
<   const REAL8 nu,     /**< Symmetric mass-ratio */
<   const REAL8 chi,    /**< Reduced aligned spin of the binary chi = (m1*chi1 + m2*chi2)/M */
<   const REAL8 chip    /**< Dimensionless spin in the orbital plane */
< );
< 
< #if 0
< static REAL8 FinalSpinBarausse2009_aligned_spin_equally_distributed(
<   const REAL8 nu,     /**< Symmetric mass-ratio */
<   const REAL8 chi,    /**< Reduced aligned spin of the binary chi = (m1*chi1 + m2*chi2)/M */
<   const REAL8 chip    /**< Dimensionless spin in the orbital plane */
< );
< #endif
< 
< static REAL8 FinalSpinBarausse2009(  /* Barausse & Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009, arXiv:0904.2577 */
<   const REAL8 nu,               /**< Symmetric mass-ratio */
<   const REAL8 a1,               /**< |a_1| norm of dimensionless spin vector for BH 1 */
<   const REAL8 a2,               /**< |a_2| norm of dimensionless spin vector for BH 2 */
<   const REAL8 cos_alpha,        /**< \f$cos(alpha) = \hat a_1 . \hat a_2\f$ (Eq. 7) */
<   const REAL8 cos_beta_tilde,   /**< \f$cos(\tilde beta)  = \hat a_1 . \hat L\f$ (Eq. 9) */
<   const REAL8 cos_gamma_tilde   /**< \f$cos(\tilde gamma) = \hat a_2 . \hat L\f$ (Eq. 9)*/
< );
< 
< static size_t NextPow2(const size_t n); /* Return the closest higher power of 2. */
---
> const double sqrt_6 = 2.44948974278317788;
172c69
<  * @brief Functions for producing PhenomP waveforms for precessing binaries,
---
>  * @brief Functions for producing IMRPhenomP waveforms for precessing binaries,
173a71,79
>  *
>  * @note Two versions of IMRPhenomP are available (selected by IMRPhenomP_version):
>  *    * version 1 ("IMRPhenomP"): based on IMRPhenomC
>  *      (outdated, not reviewed!)
>  *    * version 2 ("IMRPhenomPv2"): based on IMRPhenomD
>  *      (to be used, currently under review as of Dec 2015)
>  *
>  * Each IMRPhenomP version inherits its range of validity
>  * over the parameter space from the respective aligned-spin waveform.
175a82,91
> /**
>  * Function to map LAL parameters
>  * (masses, 6 spin components and Lhat at f_ref)
>  * into IMRPhenomP intrinsic parameters
>  * (chi1_l, chi2_l, chip, thetaJ, alpha0).
>  *
>  * All input masses and frequencies should be in SI units.
>  *
>  * See Fig. 1. in arxiv:1408.1810 for a diagram of the angles.
>  */
177,181c93,97
<     REAL8 *chi_eff,                 /**< Output: Effective aligned spin */
<     REAL8 *chip,                    /**< Output: Effective spin in the orbital plane */
<     REAL8 *eta,                     /**< Output: Symmetric mass-ratio */
<     REAL8 *thetaJ,                  /**< Output: Angle between J0 and line of sight (z-direction) */
<     REAL8 *alpha0,                  /**< Output: Initial value of alpha angle (azimuthal precession angle) */
---
>     REAL8 *chi1_l,                  /**< [out] Dimensionless aligned spin on companion 1 */
>     REAL8 *chi2_l,                  /**< [out] Dimensionless aligned spin on companion 2 */
>     REAL8 *chip,                    /**< [out] Effective spin in the orbital plane */
>     REAL8 *thetaJ,                  /**< [out] Angle between J0 and line of sight (z-direction) */
>     REAL8 *alpha0,                  /**< [out] Initial value of alpha angle (azimuthal precession angle) */
193c109,111
<     const REAL8 s2z)                /**< Initial value of s2z: dimensionless spin of BH 2 */
---
>     const REAL8 s2z,                /**< Initial value of s2z: dimensionless spin of BH 2 */
>     IMRPhenomP_version_type IMRPhenomP_version /**< IMRPhenomP(v1) uses IMRPhenomC, IMRPhenomPv2 uses IMRPhenomD */
> )
195d112
<   // See Fig. 1. in arxiv:1408.1810 for diagram of the angles.
199,206c116,127
<   if (!chi_eff)  XLAL_ERROR(XLAL_EFAULT);
<   if (!chip)     XLAL_ERROR(XLAL_EFAULT);
<   if (!eta)      XLAL_ERROR(XLAL_EFAULT);
<   if (!thetaJ)   XLAL_ERROR(XLAL_EFAULT);
<   if (!alpha0)   XLAL_ERROR(XLAL_EFAULT);
< 
<   if (f_ref <= 0)
<     XLAL_ERROR(XLAL_EDOM, "Reference frequency must be positive.\n");
---
>   XLAL_CHECK(chi1_l != NULL, XLAL_EFAULT);
>   XLAL_CHECK(chi2_l != NULL, XLAL_EFAULT);
>   XLAL_CHECK(chip != NULL, XLAL_EFAULT);
>   XLAL_CHECK(thetaJ != NULL, XLAL_EFAULT);
>   XLAL_CHECK(alpha0 != NULL, XLAL_EFAULT);
> 
>   XLAL_CHECK(f_ref > 0, XLAL_EDOM, "Reference frequency must be positive.\n");
>   XLAL_CHECK(m1_SI > 0, XLAL_EDOM, "m1 must be positive.\n");
>   XLAL_CHECK(m2_SI > 0, XLAL_EDOM, "m2 must be positive.\n");
>   XLAL_CHECK(fabs(lnhatx*lnhatx + lnhaty*lnhaty + lnhatz*lnhatz - 1) < 1e-10, XLAL_EDOM, "Lnhat must be a unit vector.\n");
>   XLAL_CHECK(fabs(s1x*s1x + s1y*s1y + s1z*s1z) <= 1.0, XLAL_EDOM, "|S1/m1^2| must be <= 1.\n");
>   XLAL_CHECK(fabs(s2x*s2x + s2y*s2y + s2z*s2z) <= 1.0, XLAL_EDOM, "|S2/m2^2| must be <= 1.\n");
213c134
<   *eta = m1 * m2 / (M*M);    /* Symmetric mass-ratio */
---
>   const REAL8 eta = m1 * m2 / (M*M);    /* Symmetric mass-ratio */
216,217c137,138
<   const REAL8 chi1_l = lnhatx*s1x + lnhaty*s1y + lnhatz*s1z; /* Dimensionless aligned spin on BH 1 */
<   const REAL8 chi2_l = lnhatx*s2x + lnhaty*s2y + lnhatz*s2z; /* Dimensionless aligned spin on BH 2 */
---
>   *chi1_l = lnhatx*s1x + lnhaty*s1y + lnhatz*s1z; /* Dimensionless aligned spin on BH 1 */
>   *chi2_l = lnhatx*s2x + lnhaty*s2y + lnhatz*s2z; /* Dimensionless aligned spin on BH 2 */
220,225c141,146
<   const REAL8 S1_perp_x = (s1x - chi1_l*lnhatx) * m1_2;
<   const REAL8 S1_perp_y = (s1y - chi1_l*lnhaty) * m1_2;
<   const REAL8 S1_perp_z = (s1z - chi1_l*lnhatz) * m1_2;
<   const REAL8 S2_perp_x = (s2x - chi2_l*lnhatx) * m2_2;
<   const REAL8 S2_perp_y = (s2y - chi2_l*lnhaty) * m2_2;
<   const REAL8 S2_perp_z = (s2z - chi2_l*lnhatz) * m2_2;
---
>   const REAL8 S1_perp_x = (s1x - *chi1_l*lnhatx) * m1_2;
>   const REAL8 S1_perp_y = (s1y - *chi1_l*lnhaty) * m1_2;
>   const REAL8 S1_perp_z = (s1z - *chi1_l*lnhatz) * m1_2;
>   const REAL8 S2_perp_x = (s2x - *chi2_l*lnhatx) * m2_2;
>   const REAL8 S2_perp_y = (s2y - *chi2_l*lnhaty) * m2_2;
>   const REAL8 S2_perp_z = (s2z - *chi2_l*lnhatz) * m2_2;
229,230d149
<   *chi_eff = (m1*chi1_l + m2*chi2_l) / M; /* Effective aligned spin */
< 
237c156
<   *chip = num / den; /*  chip = max(A1 Sp1, A2 Sp2) / (A_i m_i^2) for i index of larger BH */
---
>   *chip = num / den; /*  chip = max(A1 Sp1, A2 Sp2) / (A_i m_i^2) for i index of larger BH (See Eqn. 32 in technical document) */
244c163,176
<   const REAL8 L0 = M*M * L2PNR(v_ref, *eta); /* Use 2PN approximation for L. */
---
>   REAL8 L0 = 0.0;
>   switch (IMRPhenomP_version) {
>     case IMRPhenomPv1_V:
>       L0 = M*M * L2PNR_v1(v_ref, eta); /* Use 2PN approximation for L. */
>       break;
>     case IMRPhenomPv2_V:
>       L0 = M*M * L2PNR(v_ref, eta);   /* Use 2PN approximation for L. */
>       break;
>     default:
>       XLALPrintError( "XLAL Error - %s: Unknown IMRPhenomP version!\nAt present only v1 and v2 are available.\n", __func__);
>       XLAL_ERROR( XLAL_EINVAL );
>       break;
>     }
> 
250c182,189
<   *thetaJ = acos(Jz0 / J0); /* Angle between J0 and line of sight (z-direction) */
---
>   /* Compute thetaJ, the angle between J0 and line of sight (z-direction) */
>   if (J0 < 1e-10) {
>     XLAL_PRINT_WARNING("Warning: |J0| < 1e-10. Setting thetaJ = 0.\n");
>     *thetaJ = 0;
>   } else {
>     *thetaJ = acos(Jz0 / J0);
>   }
> 
252c191
<   if (Jx0 == 0.0 && Jy0 == 0.0)
---
>   if (Jx0 < DBL_MIN && Jy0 < DBL_MIN)
277a217,230
> /**
>  * Driver routine to compute the precessing inspiral-merger-ringdown
>  * phenomenological waveform IMRPhenomP in the frequency domain.
>  *
>  * Reference:
>  * - Hannam et al., arXiv:1308.3271 [gr-qc]
>  *
>  * \ref XLALSimIMRPhenomPCalculateModelParameters should be called first
>  * to map LAL parameters into IMRPhenomP intrinsic parameters
>  * (chi1_l, chi2_l, chip, thetaJ, alpha0).
>  *
>  * This function can be used for equally-spaced frequency series.
>  * For unequal spacing, use \ref XLALSimIMRPhenomPFrequencySequence instead.
>  */
279,292c232,247
<   COMPLEX16FrequencySeries **hptilde,   /**< Output: Frequency-domain waveform h+ */
<   COMPLEX16FrequencySeries **hctilde,   /**< Output: Frequency-domain waveform hx */
<   const REAL8 chi_eff,                  /**< Effective aligned spin */
<   const REAL8 chip,                     /**< Effective spin in the orbital plane */
<   const REAL8 eta,                      /**< Symmetric mass-ratio */
<   const REAL8 thetaJ,                   /**< Angle between J0 and line of sight (z-direction) */
<   const REAL8 Mtot_SI,                  /**< Total mass of binary (kg) */
<   const REAL8 distance,                 /**< Distance of source (m) */
<   const REAL8 alpha0,                   /**< Initial value of alpha angle (azimuthal precession angle) */
<   const REAL8 phic,                     /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   const REAL8 deltaF,                   /**< Sampling frequency (Hz) */
<   const REAL8 f_min,                    /**< Starting GW frequency (Hz) */
<   const REAL8 f_max,                    /**< End frequency; 0 defaults to ringdown cutoff freq */
<   const REAL8 f_ref)                    /**< Reference frequency */
---
>   COMPLEX16FrequencySeries **hptilde,         /**< [out] Frequency-domain waveform h+ */
>   COMPLEX16FrequencySeries **hctilde,         /**< [out] Frequency-domain waveform hx */
>   const REAL8 chi1_l,                         /**< Dimensionless aligned spin on companion 1 */
>   const REAL8 chi2_l,                         /**< Dimensionless aligned spin on companion 2 */
>   const REAL8 chip,                           /**< Effective spin in the orbital plane */
>   const REAL8 thetaJ,                         /**< Angle between J0 and line of sight (z-direction) */
>   const REAL8 m1_SI,                          /**< Mass of companion 1 (kg) */
>   const REAL8 m2_SI,                          /**< Mass of companion 2 (kg) */
>   const REAL8 distance,                       /**< Distance of source (m) */
>   const REAL8 alpha0,                         /**< Initial value of alpha angle (azimuthal precession angle) */
>   const REAL8 phic,                           /**< Orbital phase at the peak of the underlying non precessing model (rad) */
>   const REAL8 deltaF,                         /**< Sampling frequency (Hz) */
>   const REAL8 f_min,                          /**< Starting GW frequency (Hz) */
>   const REAL8 f_max,                          /**< End frequency; 0 defaults to ringdown cutoff freq */
>   const REAL8 f_ref,                          /**< Reference frequency */
>   IMRPhenomP_version_type IMRPhenomP_version) /**< IMRPhenomP(v1) uses IMRPhenomC, IMRPhenomPv2 uses IMRPhenomD */
298c253
<   // Use fLow, fHigh, deltaF to compute freqs sequence
---
>   // Use f_min, f_max, deltaF to compute freqs sequence
301a257
>   XLAL_CHECK(freqs != NULL, XLAL_EFAULT);
306,307c262,264
<       chi_eff, chip, eta, thetaJ, Mtot_SI, distance, alpha0, phic, f_ref, freqs, deltaF);
< 
---
>       chi1_l, chi2_l, chip, thetaJ, m1_SI, m2_SI, distance, alpha0, phic, f_ref, freqs, deltaF, IMRPhenomP_version);
>   XLAL_CHECK(retcode == XLAL_SUCCESS, XLAL_EFUNC, "Failed to generate IMRPhenomP waveform.");
>   XLALDestroyREAL8Sequence(freqs);
310a268,282
> /**
>  * Driver routine to compute the precessing inspiral-merger-ringdown
>  * phenomenological waveform IMRPhenomP in the frequency domain.
>  *
>  * Reference:
>  * - Hannam et al., arXiv:1308.3271 [gr-qc]
>  *
>  * \ref XLALSimIMRPhenomPCalculateModelParameters should be called first
>  * to map LAL parameters into IMRPhenomP intrinsic parameters
>  * (chi1_l, chi2_l, chip, thetaJ, alpha0).
>  *
>  * This function can be used for user-specified,
>  * potentially unequally-spaced frequency series.
>  * For equal spacing with a given deltaF, use \ref XLALSimIMRPhenomP instead.
>  */
312,323c284,297
<   COMPLEX16FrequencySeries **hptilde,   /**< Output: Frequency-domain waveform h+ */
<   COMPLEX16FrequencySeries **hctilde,   /**< Output: Frequency-domain waveform hx */
<   const REAL8Sequence *freqs,           /**< Frequency points at which to evaluate the waveform (Hz) */
<   const REAL8 chi_eff,                  /**< Effective aligned spin */
<   const REAL8 chip,                     /**< Effective spin in the orbital plane */
<   const REAL8 eta,                      /**< Symmetric mass-ratio */
<   const REAL8 thetaJ,                   /**< Angle between J0 and line of sight (z-direction) */
<   const REAL8 Mtot_SI,                  /**< Total mass of binary (kg) */
<   const REAL8 distance,                 /**< Distance of source (m) */
<   const REAL8 alpha0,                   /**< Initial value of alpha angle (azimuthal precession angle) */
<   const REAL8 phic,                     /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   const REAL8 f_ref)                    /**< Reference frequency */
---
>   COMPLEX16FrequencySeries **hptilde,         /**< [out] Frequency-domain waveform h+ */
>   COMPLEX16FrequencySeries **hctilde,         /**< [out] Frequency-domain waveform hx */
>   const REAL8Sequence *freqs,                 /**< Frequency points at which to evaluate the waveform (Hz) */
>   const REAL8 chi1_l,                         /**< Dimensionless aligned spin on companion 1 */
>   const REAL8 chi2_l,                         /**< Dimensionless aligned spin on companion 2 */
>   const REAL8 chip,                           /**< Effective spin in the orbital plane */
>   const REAL8 thetaJ,                         /**< Angle between J0 and line of sight (z-direction) */
>   const REAL8 m1_SI,                          /**< Mass of companion 1 (kg) */
>   const REAL8 m2_SI,                          /**< Mass of companion 2 (kg) */
>   const REAL8 distance,                       /**< Distance of source (m) */
>   const REAL8 alpha0,                         /**< Initial value of alpha angle (azimuthal precession angle) */
>   const REAL8 phic,                           /**< Orbital phase at the peak of the underlying non precessing model (rad) */
>   const REAL8 f_ref,                          /**< Reference frequency */
>   IMRPhenomP_version_type IMRPhenomP_version) /**< IMRPhenomP(v1) uses IMRPhenomC, IMRPhenomPv2 uses IMRPhenomD */
332,333c306,307
<       chi_eff, chip, eta, thetaJ, Mtot_SI, distance, alpha0, phic, f_ref, freqs, 0);
< 
---
>       chi1_l, chi2_l, chip, thetaJ, m1_SI, m2_SI, distance, alpha0, phic, f_ref, freqs, 0, IMRPhenomP_version);
>   XLAL_CHECK(retcode == XLAL_SUCCESS, XLAL_EFUNC, "Failed to generate IMRPhenomP waveform.");
340c314,321
< /* Internal core function to calculate PhenomP polarizations for a sequence of frequences. */
---
> 
> /**
>  * Internal core function to calculate
>  * plus and cross polarizations of the PhenomP model
>  * for a set of frequencies.
>  * This can handle either user-specified frequency points
>  * or create an equally-spaced frequency series.
>  */
342,355c323,337
<   COMPLEX16FrequencySeries **hptilde,   /**< Output: Frequency-domain waveform h+ */
<   COMPLEX16FrequencySeries **hctilde,   /**< Output: Frequency-domain waveform hx */
<   const REAL8 chi_eff,                  /**< Effective aligned spin */
<   const REAL8 chip,                     /**< Effective spin in the orbital plane */
<   const REAL8 eta,                      /**< Symmetric mass-ratio */
<   const REAL8 thetaJ,                   /**< Angle between J0 and line of sight (z-direction) */
<   const REAL8 Mtot_SI,                  /**< Total mass of binary (kg) */
<   const REAL8 distance,                 /**< Distance of source (m) */
<   const REAL8 alpha0,                   /**< Initial value of alpha angle (azimuthal precession angle) */
<   const REAL8 phic,                     /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   const REAL8 f_ref,                    /**< Reference frequency */
<   const REAL8Sequence *freqs_in,        /**< Frequency points at which to evaluate the waveform (Hz) */
<   double deltaF
<   /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
---
>   COMPLEX16FrequencySeries **hptilde,        /**< [out] Frequency-domain waveform h+ */
>   COMPLEX16FrequencySeries **hctilde,        /**< [out] Frequency-domain waveform hx */
>   const REAL8 chi1_l_in,                     /**< Dimensionless aligned spin on companion 1 */
>   const REAL8 chi2_l_in,                     /**< Dimensionless aligned spin on companion 2 */
>   const REAL8 chip,                          /**< Effective spin in the orbital plane */
>   const REAL8 thetaJ,                        /**< Angle between J0 and line of sight (z-direction) */
>   const REAL8 m1_SI_in,                      /**< Mass of companion 1 (kg) */
>   const REAL8 m2_SI_in,                      /**< Mass of companion 2 (kg) */
>   const REAL8 distance,                      /**< Distance of source (m) */
>   const REAL8 alpha0,                        /**< Initial value of alpha angle (azimuthal precession angle) */
>   const REAL8 phic,                          /**< Orbital phase at the peak of the underlying non precessing model (rad) */
>   const REAL8 f_ref,                         /**< Reference frequency */
>   const REAL8Sequence *freqs_in,             /**< Frequency points at which to evaluate the waveform (Hz) */
>   double deltaF,                             /**< Sampling frequency (Hz).
>    * If deltaF > 0, the frequency points given in freqs are uniformly spaced with
357a340
>   IMRPhenomP_version_type IMRPhenomP_version /**< IMRPhenomP(v1) uses IMRPhenomC, IMRPhenomPv2 uses IMRPhenomD */
359a343,356
>   /* Check inputs for sanity */
>   XLAL_CHECK(NULL != hptilde, XLAL_EFAULT);
>   XLAL_CHECK(NULL != hctilde, XLAL_EFAULT);
>   XLAL_CHECK(*hptilde == NULL, XLAL_EFAULT);
>   XLAL_CHECK(*hctilde == NULL, XLAL_EFAULT);
>   XLAL_CHECK(deltaF >= 0, XLAL_EDOM, "deltaF must be non-negative.\n");
>   XLAL_CHECK(m1_SI_in > 0, XLAL_EDOM, "m1 must be positive.\n");
>   XLAL_CHECK(m2_SI_in > 0, XLAL_EDOM, "m2 must be positive.\n");
>   XLAL_CHECK(f_ref > 0, XLAL_EDOM, "Reference frequency must be non-negative.\n");
>   XLAL_CHECK(distance > 0, XLAL_EDOM, "distance must be positive.\n");
>   XLAL_CHECK(fabs(chi1_l_in) <= 1.0, XLAL_EDOM, "Aligned spin chi1_l=%g must be < 1 in magnitude!\n", chi1_l_in);
>   XLAL_CHECK(fabs(chi2_l_in) <= 1.0, XLAL_EDOM, "Aligned spin chi2_l=%g must be < 1 in magnitude!\n", chi2_l_in);
>   XLAL_CHECK(fabs(chip) <= 1.0, XLAL_EDOM, "In-plane spin chip =%g must be < 1 in magnitude!\n", chip);
> 
362a360,388
>   /* Phenomenological parameters */
>   IMRPhenomDAmplitudeCoefficients *pAmp = NULL;
>   IMRPhenomDPhaseCoefficients *pPhi = NULL;
>   BBHPhenomCParams *PCparams = NULL;
>   PNPhasingSeries *pn = NULL;
>   gsl_interp_accel *acc = NULL;
>   gsl_spline *phiI = NULL;
>   REAL8Sequence *freqs = NULL;
>   REAL8 *phis=NULL;
>   int errcode = XLAL_SUCCESS;
> 
>   // Enforce convention m2 >= m1
>   REAL8 chi1_l, chi2_l;
>   REAL8 m1_SI, m2_SI;
>   if (m2_SI_in >= m1_SI_in) {
>     m1_SI = m1_SI_in;
>     m2_SI = m2_SI_in;
>     chi1_l = chi1_l_in;
>     chi2_l = chi2_l_in;
>   }
>   else { // swap bodies 1 <-> 2
>     m1_SI = m2_SI_in;
>     m2_SI = m1_SI_in;
>     chi1_l = chi2_l_in;
>     chi2_l = chi1_l_in;
>   }
> 
>   errcode = init_useful_powers(&powers_of_pi, LAL_PI);
>   XLAL_CHECK(XLAL_SUCCESS == errcode, errcode, "init_useful_powers() failed.");
364,365d389
<   XLAL_PRINT_INFO("*** PhenomPCore() ***");
<   
367c391
<   if (!freqs_in) XLAL_ERROR(XLAL_EFAULT);
---
>   if (!freqs_in || !freqs_in->data) XLAL_ERROR(XLAL_EFAULT);
369a394,395
>   XLAL_CHECK(f_min > 0, XLAL_EDOM, "Minimum frequency must be positive.\n");
>   XLAL_CHECK(f_max >= 0, XLAL_EDOM, "Maximum frequency must be non-negative.\n");
371c397,400
<   const REAL8 M = Mtot_SI / LAL_MSUN_SI;  /* External units: SI; internal units: solar masses */
---
>   /* External units: SI; internal units: solar masses */
>   const REAL8 m1 = m1_SI / LAL_MSUN_SI;
>   const REAL8 m2 = m2_SI / LAL_MSUN_SI;
>   const REAL8 M = m1 + m2;
373,375c402,403
<   const REAL8 q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta)/(2.0*eta); /* Mass-ratio */
<   const REAL8 m1 = M * 1.0 / (1+q);
<   const REAL8 m2 = M * q / (1+q);
---
>   const REAL8 q = m2 / m1; /* q >= 1 */
>   const REAL8 eta = m1 * m2 / (M*M);    /* Symmetric mass-ratio */
377d404
<   const REAL8 v0 = cbrt(piM * f_ref);
381,401c408,412
<   /* Check inputs for sanity */
<   if (*hptilde)       XLAL_ERROR(XLAL_EFAULT);
<   if (*hctilde)       XLAL_ERROR(XLAL_EFAULT);
<   if (deltaF < 0)    XLAL_ERROR(XLAL_EDOM);
<   if (M <= 0)         XLAL_ERROR(XLAL_EDOM);
<   if (f_min <= 0)     XLAL_ERROR(XLAL_EDOM);
<   if (f_max < 0)      XLAL_ERROR(XLAL_EDOM);
<   if (distance <= 0)  XLAL_ERROR(XLAL_EDOM);
< 
<   if (f_ref <= 0)
<       XLAL_ERROR(XLAL_EDOM, "Reference frequency must be positive.\n");
< 
<   if (eta < 0.0453515) /* q = 20 */
<       XLAL_ERROR(XLAL_EDOM, "Mass ratio is way outside the calibration range. m1/m2 should be <= 20.\n");
<   else if (eta < 0.16)  /* q = 4 */
<       XLAL_PRINT_WARNING("Warning: The model is only calibrated for m1/m2 <= 4.\n");
< 
<   /* If spins are above 0.9 or below -0.9, throw an error. */
<   /* The rationale behind this is given at this page: https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomCdevel-SanityCheck01 */
<   if (chi_eff > 0.9 || chi_eff < -0.9)
<       XLAL_ERROR(XLAL_EDOM, "Effective spin chi_eff = %g outside the range [-0.9,0.9] is not supported!\n", chi_eff);
---
>   // Note:
>   // * IMRPhenomP uses chi_eff both in the aligned part and the twisting
>   // * IMRPhenomPv2 uses chi1_l, chi2_l in the aligned part and chi_eff in the twisting
>   const REAL8 chi_eff = (m1*chi1_l + m2*chi2_l) / M; /* Effective aligned spin */
>   const REAL8 chil = (1.0+q)/q * chi_eff; /* dimensionless aligned spin of the largest BH */
403,404c414,436
<   if (fabs(chip) > 1)
<     XLAL_ERROR(XLAL_EDOM, "In-plane spin chip =%g is super extremal!\n", chip);
---
>   switch (IMRPhenomP_version) {
>     case IMRPhenomPv1_V:
>       XLAL_PRINT_WARNING("Warning: IMRPhenomP(v1) is unreviewed.\n");
>       if (eta < 0.0453515) /* q = 20 */
>           XLAL_ERROR(XLAL_EDOM, "IMRPhenomP(v1): Mass ratio is way outside the calibration range. m1/m2 should be <= 20.\n");
>       else if (eta < 0.16)  /* q = 4 */
>           XLAL_PRINT_WARNING("IMRPhenomP(v1): Warning: The model is only calibrated for m1/m2 <= 4.\n");
>       /* If spins are above 0.9 or below -0.9, throw an error. */
>       /* The rationale behind this is given at this page: https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomCdevel-SanityCheck01 */
>       if (chi_eff > 0.9 || chi_eff < -0.9)
>           XLAL_ERROR(XLAL_EDOM, "IMRPhenomP(v1): Effective spin chi_eff = %g outside the range [-0.9,0.9] is not supported!\n", chi_eff);
>       break;
>     case IMRPhenomPv2_V:
>       if (q > 18.0)
>         XLAL_PRINT_WARNING("IMRPhenomPv2: Warning: The model is calibrated up to m1/m2 <= 18.\n");
>       else if (q > 100.0)
>           XLAL_ERROR(XLAL_EDOM, "IMRPhenomPv2: Mass ratio q > 100 which is way outside the calibration range q <= 18.\n");
>       break;
>     default:
>       XLALPrintError( "XLAL Error - %s: Unknown IMRPhenomP version!\nAt present only v1 and v2 are available.\n", __func__);
>       XLAL_ERROR( XLAL_EINVAL );
>       break;
>     }
406,407c438
<   const REAL8 chil = (1.0+q)/q * chi_eff; /* dimensionless aligned spin of the largest BH */
<   NNLOanglecoeffs angcoeffs;
---
>   NNLOanglecoeffs angcoeffs; /* Next-to-next-to leading order PN coefficients for Euler angles alpha and epsilon */
413c444
<   const REAL8 omega_ref_cbrt = v0;
---
>   const REAL8 omega_ref_cbrt = cbrt(piM * f_ref); // == v0
438,444c469,493
<   /* Phenomenological parameters */
<   BBHPhenomCParams *PCparams;
<   //PCparams = ComputeIMRPhenomCParams(m1, m2, chi_eff); /* original PhenomC */
<   PCparams = ComputeIMRPhenomCParamsRDmod(m1, m2, chi_eff, chip); /* PhenomC with ringdown using Barausse 2009 formula for final spin */
<   if (!PCparams) XLAL_ERROR(XLAL_EFUNC);
<   if (PCparams->fCut <= f_min)
<       XLAL_ERROR(XLAL_EDOM, "(fCut = 0.15M) <= f_min\n");
---
>   REAL8 fCut = 0.0;
>   REAL8 finspin = 0.0;
>   REAL8 f_final = 0.0;
> 
>   switch (IMRPhenomP_version) {
>     case IMRPhenomPv1_V:
>       XLAL_PRINT_INFO("*** IMRPhenomP version 1: based on IMRPhenomC ***");
>       // PhenomC with ringdown using Barausse 2009 formula for final spin
>       PCparams = ComputeIMRPhenomCParamsRDmod(m1, m2, chi_eff, chip);
>       if (!PCparams) {
>         errcode = XLAL_EFUNC;
>         goto cleanup;
>       }
>       fCut = PCparams->fCut;
>       f_final = PCparams->fRingDown;
>       break;
>     case IMRPhenomPv2_V:
>       XLAL_PRINT_INFO("*** IMRPhenomP version 2: based on IMRPhenomD ***");
>       // PhenomD uses FinalSpin0815() to calculate the final spin if the spins are aligned.
>       // We use a generalized version of FinalSpin0815() that includes the in-plane spin chip.
>       finspin = FinalSpinIMRPhenomD_all_in_plane_spin_on_larger_BH(m1, m2, chi1_l, chi2_l, chip);
>       if( fabs(finspin) > 1.0 ) {
>         XLAL_PRINT_WARNING("Warning: final spin magnitude %g > 1. Setting final spin magnitude = 1.", finspin);
>         finspin = copysign(1.0, finspin);
>       }
446,451c495,502
<   /* Default f_max to params->fCut */
<   REAL8 f_max_prime = f_max ? f_max : PCparams->fCut;
<   f_max_prime = (f_max_prime > PCparams->fCut) ? PCparams->fCut : f_max_prime;
<   if (f_max_prime <= f_min)
<       XLAL_ERROR(XLAL_EDOM, "f_max <= f_min\n");
<   XLAL_PRINT_INFO("f_max_prime = %g\tfcut = %g\tv = %g\n", f_max_prime, PCparams->fCut, cbrt(piM * f_max_prime));
---
>       // IMRPhenomD assumes that m1 >= m2.
>       pAmp = ComputeIMRPhenomDAmplitudeCoefficients(eta, chi2_l, chi1_l, finspin);
>       pPhi = ComputeIMRPhenomDPhaseCoefficients(eta, chi2_l, chi1_l, finspin);
>       XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1_l, chi2_l, 1.0, 1.0, LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
>       if (!pAmp || !pPhi || !pn) {
>         errcode = XLAL_EFUNC;
>         goto cleanup;
>       }
452a504,535
>       // Subtract 3PN spin-spin term below as this is in LAL's TaylorF2 implementation
>       // (LALSimInspiralPNCoefficients.c -> XLALSimInspiralPNPhasing_F2), but
>       // was not available when PhenomD was tuned.
>       pn->v[6] -= (Subtract3PNSS(m1, m2, M, chi1_l, chi2_l) * pn->v[0]);
> 
>       PhiInsPrefactors phi_prefactors;
>       errcode = init_phi_ins_prefactors(&phi_prefactors, pPhi, pn);
>       XLAL_CHECK(XLAL_SUCCESS == errcode, errcode, "init_phi_ins_prefactors failed");
> 
>       ComputeIMRPhenDPhaseConnectionCoefficients(pPhi, pn, &phi_prefactors);
>       // This should be the same as the ending frequency in PhenomD
>       fCut = f_CUT / m_sec;
>       f_final = pAmp->fRD / m_sec;
>       break;
>     default:
>       XLALPrintError( "XLAL Error - %s: Unknown IMRPhenomP version!\nAt present only v1 and v2 are available.\n", __func__);
>       errcode = XLAL_EINVAL;
>       goto cleanup;
>       break;
>   }
> 
>   if (fCut <= f_min)
>     XLAL_ERROR(XLAL_EDOM, "fCut = %.2f/M <= f_min\n", fCut);
> 
>   /* Default f_max to params->fCut */
>   REAL8 f_max_prime = f_max ? f_max : fCut;
>   f_max_prime = (f_max_prime > fCut) ? fCut : f_max_prime;
>   if (f_max_prime <= f_min){
>     XLALPrintError("f_max <= f_min\n");
>     errcode = XLAL_EDOM;
>     goto cleanup;
>   }
455d537
<   XLAL_PRINT_INFO("f_max / deltaF = %g\n", f_max_prime / deltaF);
460d541
<   REAL8Sequence *freqs = NULL;
463,464c544
<     n = NextPow2(f_max_prime / deltaF) + 1;
<     if (f_max_prime < f_max)                       /* Resize waveform if user wants f_max larger than cutoff frequency */
---
>     if (f_max_prime < f_max)  /* Resize waveform if user wants f_max larger than cutoff frequency */
465a546,547
>     else
>       n = NextPow2(f_max_prime / deltaF) + 1;
468c550,551
<     XLALGPSAdd(&ligotimegps_zero, -1. / deltaF); // shift by overall length in time
---
>     XLAL_CHECK(XLALGPSAdd(&ligotimegps_zero, -1. / deltaF), XLAL_EFUNC,
>     "Failed to shift coalescence time by -1.0/deltaF with deltaF=%g.", deltaF); // shift by overall length in time
470a554,557
>     if(!*hptilde) {
>       errcode = XLAL_ENOMEM;
>       goto cleanup;
>     }
471a559,562
>     if(!*hctilde) {
>       errcode = XLAL_ENOMEM;
>       goto cleanup;
>     }
477c568,573
<     for (UINT4 i=i_min; i<i_max; i++, L_fCut++)
---
>     if (!freqs) {
>       errcode = XLAL_EFUNC;
>       XLALPrintError("Frequency array allocation failed.");
>       goto cleanup;
>     }
>     for (UINT4 i=i_min; i<i_max; i++)
479c575
< 
---
>     L_fCut = freqs->length;
484a581,584
>     if(!*hptilde) {
>       errcode = XLAL_ENOMEM;
>       goto cleanup;
>     }
485a586,589
>     if(!*hctilde) {
>       errcode = XLAL_ENOMEM;
>       goto cleanup;
>     }
490a595
>     {
492c597,602
<         XLAL_ERROR(XLAL_EDOM, "Frequency sequence must be strictly increasing!\n");
---
>       {
>         XLALPrintError("Frequency sequence must be strictly increasing!\n");
>         errcode = XLAL_EDOM;
>         goto cleanup;
>       }
>     }
494a605,609
>     if (!freqs) {
>       XLALPrintError( "Frequency array allocation failed.");
>       errcode = XLAL_ENOMEM;
>       goto cleanup;
>     }
497c612
<       if (freqs_in->data[i] <= PCparams->fCut) {
---
>       if (freqs_in->data[i] <= fCut) {
508,509d622
<   if (!(*hptilde) || !(*hctilde))
<     XLAL_ERROR(XLAL_EFUNC);
511,519c624,629
<   /* Test output */
<   XLAL_PRINT_INFO("eta: %g\n", eta);
<   XLAL_PRINT_INFO("m1: %g\n", m1);
<   XLAL_PRINT_INFO("m2: %g\n", m2);
<   XLAL_PRINT_INFO("chi: %g\n", chi_eff);
<   XLAL_PRINT_INFO("chip: %g\n", chip);
<   XLAL_PRINT_INFO("thetaJ: %g\n", thetaJ);
<   XLAL_PRINT_INFO("ind_mix = (int)(f_mix / deltaF) = %d\n", (int)(f_min / deltaF));
<   XLAL_PRINT_INFO("ind_max = (int)(f_max / deltaF) = %d\n", (int)(f_max_prime / deltaF));
---
>   phis = XLALMalloc(L_fCut*sizeof(REAL8)); // array for waveform phase
>   if(!phis) {
>     errcode = XLAL_ENOMEM;
>     goto cleanup;
>   }
>   REAL8 phasing = 0;
521c631,632
<   int errcode = XLAL_SUCCESS;
---
>   AmpInsPrefactors amp_prefactors;
>   PhiInsPrefactors phi_prefactors;
523,524c634,639
<   REAL8 *phis = XLALMalloc(L_fCut*sizeof(REAL8)); // array for waveform phase
<   REAL8 phasing = 0;
---
>   if (IMRPhenomP_version == IMRPhenomPv2_V) {
>     errcode = init_amp_ins_prefactors(&amp_prefactors, pAmp);
>     XLAL_CHECK(XLAL_SUCCESS == errcode, errcode, "init_amp_ins_prefactors() failed.");
>     errcode = init_phi_ins_prefactors(&phi_prefactors, pPhi, pn);
>     XLAL_CHECK(XLAL_SUCCESS == errcode, errcode, "init_phi_ins_prefactors() failed.");
>   }
545,546c660,661
<     per_thread_errcode = PhenomPCoreOneFrequency(f, eta, chi_eff, chip, distance, M, phic,
<                               PCparams, &angcoeffs, &Y2m,
---
>     per_thread_errcode = PhenomPCoreOneFrequency(f, eta, chi1_l, chi2_l, chip, distance, M, phic,
>                               pAmp, pPhi, PCparams, pn, &angcoeffs, &Y2m,
548c663
<                               &hp_val, &hc_val, &phasing);
---
>                               &hp_val, &hc_val, &phasing, IMRPhenomP_version, &amp_prefactors, &phi_prefactors);
565c680
<   if (deltaF>0) {
---
>   if (deltaF>=0) {
567,568c682,683
<     gsl_interp_accel *acc = gsl_interp_accel_alloc();
<     gsl_spline *phiI = gsl_spline_alloc(gsl_interp_cspline, L_fCut);
---
>     acc = gsl_interp_accel_alloc();
>     phiI = gsl_spline_alloc(gsl_interp_cspline, L_fCut);
572,574d686
<     REAL8 f_final = PCparams->fRingDown; // This isn't quite the same as the SEOBNRv2 ringdown frequency
<     XLAL_PRINT_INFO("f_ringdown = %g\n", f_final);
< 
579c691,695
<       XLAL_ERROR(XLAL_EDOM, "f_ringdown < f_min\n");
---
>     {
>       XLALPrintError("f_ringdown < f_min\n");
>       errcode = XLAL_EDOM;
>       goto cleanup;
>     }
583d698
<     XLAL_PRINT_INFO("t_corr = %g\n", t_corr);
587a703
>       COMPLEX16 phase_corr = cexp(-2*LAL_PI * I * f * t_corr);
589,590c705,706
<       ((*hptilde)->data->data)[j] *= cexp(-2*LAL_PI * I * f * t_corr);
<       ((*hctilde)->data->data)[j] *= cexp(-2*LAL_PI * I * f * t_corr);
---
>       ((*hptilde)->data->data)[j] *= phase_corr;
>       ((*hctilde)->data->data)[j] *= phase_corr;
593,595d708
<     gsl_spline_free(phiI);
<     gsl_interp_accel_free(acc);
<     XLALFree(phis);
597,598c710,724
<   XLALFree(PCparams);
<   XLALDestroyREAL8Sequence(freqs);
---
> 
>   cleanup:
>   if(phis) XLALFree(phis);
>   if(phiI) gsl_spline_free(phiI);
>   if(acc) gsl_interp_accel_free(acc);
> 
>   if(PCparams) XLALFree(PCparams);
>   if(pAmp) XLALFree(pAmp);
>   if(pPhi) XLALFree(pPhi);
>   if(pn) XLALFree(pn);
> 
>   if(freqs) XLALDestroyREAL8Sequence(freqs);
> 
>   if(!*hptilde) XLALFree(hptilde);
>   if(!*hctilde) XLALFree(hctilde);
608c734,791
< /* Internal core function to calculate PhenomP polarizations for a single frequency. */
---
> /**
>  * \f[
>  * \newcommand{\hP}{h^\mathrm{P}}
>  * \newcommand{\PAmp}{A^\mathrm{P}}
>  * \newcommand{\PPhase}{\phi^\mathrm{P}}
>  * \newcommand{\chieff}{\chi_\mathrm{eff}}
>  * \newcommand{\chip}{\chi_\mathrm{p}}
>  * \f]
>  * Internal core function to calculate
>  * plus and cross polarizations of the PhenomP model
>  * for a single frequency.
>  *
>  * The general expression for the modes \f$\hP_{2m}(t)\f$
>  * is given by Eq. 1 of arXiv:1308.3271.
>  * We calculate the frequency domain l=2 plus and cross polarizations separately
>  * for each m = -2, ... , 2.
>  *
>  * The expression of the polarizations times the \f$Y_{lm}\f$
>  * in code notation are:
>  * \f{equation*}{
>  * \left(\tilde{h}_{2m}\right)_+ = e^{-2i \epsilon}
>  * \left(e^{-i m \alpha} d^2_{-2,m} (-2Y_{2m})
>  * + e^{+i m \alpha} d^2_{2,m} (-2Y_{2m})^*\right) \cdot \hP / 2 \,,
>  * \f}
>  * \f{equation*}{
>  * \left(\tilde{h}_{2m}\right)_x = e^{-2i \epsilon}
>  * \left(e^{-i m \alpha} d^2_{-2,m} (-2Y_{2m})
>  * - e^{+i m \alpha} d^2_{2,m} (-2Y_{2m})^*\right) \cdot \hP / 2 \,,
>  * \f}
>  * where the \f$d^l_{m',m}\f$ are Wigner d-matrices evaluated at \f$-\beta\f$,
>  * and \f$\hP\f$ is the Phenom[C,D] frequency domain model:
>  * \f{equation*}{
>  * \hP(f) = \PAmp(f) e^{-i \PPhase(f)} \,.
>  * \f}
>  *
>  * Note that in arXiv:1308.3271, the angle \f$\beta\f$ (beta) is called iota.
>  *
>  * For IMRPhenomP(v1) we put all spin on the larger BH,
>  * convention: \f$m_2 \geq m_1\f$.
>  * Hence:
>  * \f{eqnarray*}{
>  * \chieff      &=& \left( m_1 \cdot \chi_1 + m_2 \cdot \chi_2 \right)/M \,,\\
>  * \chi_l       &=& \chieff / m_2 \quad (\text{for } M=1) \,,\\
>  * S_L          &=& m_2^2 \chi_l = m_2 \cdot M \cdot \chieff
>  *               = \frac{q}{1+q} \cdot \chieff \quad (\text{for } M=1) \,.
>  * \f}
>  *
>  * For IMRPhenomPv2 we use both aligned spins:
>  * \f{equation*}{
>  * S_L = \chi_1 \cdot m_1^2 + \chi_2 \cdot m_2^2 \,.
>  * \f}
>  *
>  * For both IMRPhenomP(v1) and IMRPhenomPv2 we put the in-plane spin on the larger BH:
>  * \f{equation*}{
>  * S_\mathrm{perp} = \chip \cdot m_2^2
>  * \f}
>  * (perpendicular spin).
>  */
610,635c793,820
<   const REAL8 fHz,                        /**< Frequency (Hz) */
<   const REAL8 eta,                        /**< Symmetric mass ratio */
<   const REAL8 chi_eff,                    /**< Dimensionless effective total aligned spin */
<   const REAL8 chip,                       /**< Dimensionless spin in the orbital plane */
<   const REAL8 distance,                   /**< Distance of source (m) */
<   const REAL8 M,                          /**< Total mass (Solar masses) */
<   const REAL8 phic,                       /**< Orbital phase at the peak of the underlying non precessing model (rad) */
<   BBHPhenomCParams *PCparams,             /**< Internal PhenomC parameters */
<   NNLOanglecoeffs *angcoeffs,  		        /**< Struct with PN coeffs for the NNLO angles */
<   SpinWeightedSphericalHarmonic_l2 *Y2m,  /**< Struct of l=2 spherical harmonics of spin weight -2 */
<   const REAL8 alphaoffset,                /**< f_ref dependent offset for alpha angle (azimuthal precession angle) */
<   const REAL8 epsilonoffset,              /**< f_ref dependent offset for epsilon angle */
<   COMPLEX16 *hp,                          /**< Output: \tilde h_+ */
<   COMPLEX16 *hc,                          /**< Output: \tilde h_+ */
<   REAL8 *phasing)                         /**< Output: overall phasing */
< {
< 
<   /* Calculate PhenomC amplitude and phase for a given frequency. */
<   REAL8 phPhenomC = 0.0;
<   REAL8 aPhenomC  = 0.0;
<   int errcode = IMRPhenomCGenerateAmpPhase( &aPhenomC, &phPhenomC, fHz, eta, PCparams );
<   if( errcode != XLAL_SUCCESS )
<     XLAL_ERROR(XLAL_EFUNC);
<   phPhenomC -= 2.*phic; /* Note: phic is orbital phase */
<   REAL8 amp0 = M * LAL_MRSUN_SI * M * LAL_MTSUN_SI / distance;
<   COMPLEX16 hPC = amp0 * aPhenomC * cexp(-I*phPhenomC); /* Assemble PhenomC waveform. */
---
>   const REAL8 fHz,                            /**< Frequency (Hz) */
>   const REAL8 eta,                            /**< Symmetric mass ratio */
>   const REAL8 chi1_l,                         /**< Dimensionless aligned spin on companion 1 */
>   const REAL8 chi2_l,                         /**< Dimensionless aligned spin on companion 2 */
>   const REAL8 chip,                           /**< Dimensionless spin in the orbital plane */
>   const REAL8 distance,                       /**< Distance of source (m) */
>   const REAL8 M,                              /**< Total mass (Solar masses) */
>   const REAL8 phic,                           /**< Orbital phase at the peak of the underlying non precessing model (rad) */
>   IMRPhenomDAmplitudeCoefficients *pAmp,      /**< Internal IMRPhenomD amplitude coefficients */
>   IMRPhenomDPhaseCoefficients *pPhi,          /**< Internal IMRPhenomD phase coefficients */
>   BBHPhenomCParams *PCparams,                 /**< Internal PhenomC parameters */
>   PNPhasingSeries *PNparams,                  /**< PN inspiral phase coefficients */
>   NNLOanglecoeffs *angcoeffs,                 /**< Struct with PN coeffs for the NNLO angles */
>   SpinWeightedSphericalHarmonic_l2 *Y2m,      /**< Struct of l=2 spherical harmonics of spin weight -2 */
>   const REAL8 alphaoffset,                    /**< f_ref dependent offset for alpha angle (azimuthal precession angle) */
>   const REAL8 epsilonoffset,                  /**< f_ref dependent offset for epsilon angle */
>   COMPLEX16 *hp,                              /**< [out] plus polarization \f$\tilde h_+\f$ */
>   COMPLEX16 *hc,                              /**< [out] cross polarization \f$\tilde h_x\f$ */
>   REAL8 *phasing,                             /**< [out] overall phasing */
>   IMRPhenomP_version_type IMRPhenomP_version, /**< IMRPhenomP(v1) uses IMRPhenomC, IMRPhenomPv2 uses IMRPhenomD */
>   AmpInsPrefactors *amp_prefactors,           /**< pre-calculated (cached for saving runtime) coefficients for amplitude. See LALSimIMRPhenomD_internals.c*/
>   PhiInsPrefactors *phi_prefactors            /**< pre-calculated (cached for saving runtime) coefficients for phase. See LALSimIMRPhenomD_internals.*/)
> {
>   XLAL_CHECK(angcoeffs != NULL, XLAL_EFAULT);
>   XLAL_CHECK(hp != NULL, XLAL_EFAULT);
>   XLAL_CHECK(hc != NULL, XLAL_EFAULT);
>   XLAL_CHECK(Y2m != NULL, XLAL_EFAULT);
>   XLAL_CHECK(phasing != NULL, XLAL_EFAULT);
639,645c824,827
<   /*
<    * We put all spin on the larger BH. Here m2 >= m1.
<    * chi_eff = (m1*0 + m2*chi2)/M
<    * chil = chi2 = chi_eff / m2 (for M=1)
<    * SL = m2^2 chi2 = m2*M*chi = q/(1+q) * chi (for M=1)
<    * Sp = chip*m2^2
<    */
---
>   REAL8 aPhenom = 0.0;
>   REAL8 phPhenom = 0.0;
>   int errcode = XLAL_SUCCESS;
>   UsefulPowers powers_of_f;
648,649c830,831
<   const REAL8 m2 = q/(1.0+q);         /* Compute the mass of the larger BH for unit total mass M=1. */
<   const REAL8 SL = chi_eff*m2;        /* Dimensionfull aligned spin of the largest BH. */
---
>   const REAL8 m1 = 1.0/(1.0+q);       /* Mass of the smaller BH for unit total mass M=1. */
>   const REAL8 m2 = q/(1.0+q);         /* Mass of the larger BH for unit total mass M=1. */
650a833,834
>   REAL8 SL;                           /* Dimensionfull aligned spin. */
>   const REAL8 chi_eff = (m1*chi1_l + m2*chi2_l); /* effective spin for M=1 */
651a836,860
>   /* Calculate Phenom amplitude and phase for a given frequency. */
>   switch (IMRPhenomP_version) {
>     case IMRPhenomPv1_V:
>       XLAL_CHECK(PCparams != NULL, XLAL_EFAULT);
>       errcode = IMRPhenomCGenerateAmpPhase( &aPhenom, &phPhenom, fHz, eta, PCparams );
>       if( errcode != XLAL_SUCCESS ) XLAL_ERROR(XLAL_EFUNC);
>       SL = chi_eff*m2;        /* Dimensionfull aligned spin of the largest BH. SL = m2^2 chil = m2*M*chi_eff */
>       break;
>     case IMRPhenomPv2_V:
>       XLAL_CHECK(pAmp != NULL, XLAL_EFAULT);
>       XLAL_CHECK(pPhi != NULL, XLAL_EFAULT);
>       XLAL_CHECK(PNparams != NULL, XLAL_EFAULT);
>       XLAL_CHECK(amp_prefactors != NULL, XLAL_EFAULT);
>       XLAL_CHECK(phi_prefactors != NULL, XLAL_EFAULT);
>       errcode = init_useful_powers(&powers_of_f, f);
>       XLAL_CHECK(errcode == XLAL_SUCCESS, errcode, "init_useful_powers failed for f");
>       aPhenom = IMRPhenDAmplitude(f, pAmp, &powers_of_f, amp_prefactors);
>       phPhenom = IMRPhenDPhase(f, pPhi, PNparams, &powers_of_f, phi_prefactors);
>       SL = chi1_l*m1*m1 + chi2_l*m2*m2;        /* Dimensionfull aligned spin. */
>       break;
>     default:
>       XLALPrintError( "XLAL Error - %s: Unknown IMRPhenomP version!\nAt present only v1 and v2 are available.\n", __func__);
>       XLAL_ERROR( XLAL_EINVAL );
>       break;
>   }
653,662c862,864
<   /*
<    * Calculate plus and cross polarizations of the PhenomP model for individual m's.
<    * The general expression for the modes h^P_{2m}(t) is given by Eq. 1 of arXiv:1308.3271.
<    * We calculate the frequency domain l=2 plus and cross polarizations separately for each m = -2, ... , 2.
<    * The expression of the polarizations times the Ylm's in code notation are:
<    *    \tilde (h_2m)_+ = e^{-2i epsilon} (e^{-i m alpha} d^2_{-2,m} (-2Y_2m) + e^{+i m alpha} d^2_{2,m} (-2Y_2m)^*) * hPC / 2
<    *    \tilde (h_2m)_x = e^{-2i epsilon} (e^{-i m alpha} d^2_{-2,m} (-2Y_2m) - e^{+i m alpha} d^2_{2,m} (-2Y_2m)^*) * hPC / 2
<    * where the d^l_{m',m} are Wigner d-matrices evaluated at - beta, and hPC is the PhenomC frequency domain model hPC(f) = PCAmp(f) e^{-i PCPhase(f)}.
<    *
<    */
---
>   phPhenom -= 2.*phic; /* Note: phic is orbital phase */
>   REAL8 amp0 = M * LAL_MRSUN_SI * M * LAL_MTSUN_SI / distance;
>   COMPLEX16 hP = amp0 * aPhenom * cexp(-I*phPhenom); /* Assemble IMRPhenom waveform. */
684c886,898
<   WignerdCoefficients(omega_cbrt, SL, eta, Sperp, &cBetah, &sBetah);
---
>   switch (IMRPhenomP_version) {
>     case IMRPhenomPv1_V:
>       WignerdCoefficients_SmallAngleApproximation(&cBetah, &sBetah, omega_cbrt, SL, eta, Sperp);
>       break;
>     case IMRPhenomPv2_V:
>       WignerdCoefficients(&cBetah, &sBetah, omega_cbrt, SL, eta, Sperp);
>       break;
>   default:
>     XLALPrintError( "XLAL Error - %s: Unknown IMRPhenomP version!\nAt present only v1 and v2 are available.\n", __func__);
>     XLAL_ERROR( XLAL_EINVAL );
>     break;
>   }
> 
693c907
<     The expressions below agree with refX and Mathematica
---
>     The expressions below agree with refX [Goldstein?] and Mathematica
697c911
<   COMPLEX16 d2[5]   = {sBetah4, 2*cBetah*sBetah3, sqrt(6.0)*sBetah2*cBetah2, 2*cBetah3*sBetah, cBetah4};
---
>   COMPLEX16 d2[5]   = {sBetah4, 2*cBetah*sBetah3, sqrt_6*sBetah2*cBetah2, 2*cBetah3*sBetah, cBetah4};
718,720c932,934
<   COMPLEX16 eps_phase_hPC = cexp(-2*I*epsilon) * hPC / 2.0;
<   *hp = eps_phase_hPC * hp_sum;
<   *hc = eps_phase_hPC * hc_sum;
---
>   COMPLEX16 eps_phase_hP = cexp(-2*I*epsilon) * hP / 2.0;
>   *hp = eps_phase_hP * hp_sum;
>   *hc = eps_phase_hP * hc_sum;
722,723c936,937
<   //*phasing = -phPhenomC -2*epsilon; // ignore alpha contributions
<   *phasing = -phPhenomC; // ignore alpha and epsilon contributions
---
>   // Return phasing for time-shift correction
>   *phasing = -phPhenom; // ignore alpha and epsilon contributions
728c942,945
< 
---
> /**
>  * Next-to-next-to-leading order PN coefficients
>  * for Euler angles \f$\alpha\f$ and \f$\epsilon\f$.
>  */
730c947
<   NNLOanglecoeffs *angcoeffs, /**< Output: Structure to store results */
---
>   NNLOanglecoeffs *angcoeffs, /**< [out] Structure to store results */
759a977
>   XLAL_CHECK_VOID(angcoeffs != NULL, XLAL_EFAULT);
811c1029,1036
< 
---
> /**
>  * Simple 2PN version of the orbital angular momentum L,
>  * without any spin terms expressed as a function of v.
>  * For IMRPhenomP(v2).
>  *
>  *  Reference:
>  *  - Boh&eacute; et al, 1212.5520v2 Eq 4.7 first line
>  */
815a1041,1058
>   const REAL8 eta2 = eta*eta;
>   const REAL8 x = v*v;
>   const REAL8 x2 = x*x;
>   return (eta*(1.0 + (1.5 + eta/6.0)*x + (3.375 - (19.0*eta)/8. - eta2/24.0)*x2)) / sqrt(x);
> }
> 
> /**
>  * Simple 2PN version of the orbital angular momentum L,
>  * without any spin terms expressed as a function of v.
>  * For IMRPhenomP(v1).
>  *
>  * Reference:
>  *  - Kidder, Phys. Rev. D 52, 821847 (1995), Eq. 2.9
>  */
> static REAL8 L2PNR_v1(
>   const REAL8 v,   /**< Cubic root of (Pi * Frequency (geometric)) */
>   const REAL8 eta) /**< Symmetric mass-ratio */
> {
820a1064
>   const REAL8 b = (4.75 + eta/9.)*eta*v4;
822,823d1065
<   /* Simple 2PN version of L, without any spin terms expressed as a function of v:
<   [Kidder, Phys. Rev. D 52, 821847 (1995), Eq. 2.9] */
825c1067
<   return mu*sqrt((1 - ((3 - eta)*v2)/3. + (4.75 + eta/9.)*eta*v4)/v2)*
---
>   return mu*sqrt((1 - ((3 - eta)*v2)/3. + b)/v2)*
827,829c1069,1071
<       ((14 - 41*eta + 4*eta2)*v4)/(4.*pow(1 - ((3 - eta)*v2)/3. + (4.75 + eta/9.)*eta*v4,2)) +
<       ((3 + eta)*v2)/(1 - ((3 - eta)*v2)/3. + (4.75 + eta/9.)*eta*v4) +
<       ((7 - 10*eta - 9*eta2)*v4)/(2.*(1 - ((3 - eta)*v2)/3. + (4.75 + eta/9.)*eta*v4)));
---
>       ((14 - 41*eta + 4*eta2)*v4)/(4.*pow_2_of(1 - ((3 - eta)*v2)/3. + b)) +
>       ((3 + eta)*v2)/(1 - ((3 - eta)*v2)/3. + b) +
>       ((7 - 10*eta - 9*eta2)*v4)/(2.*(1 - ((3 - eta)*v2)/3. + b)));
831a1074,1083
> /** Expressions used for the WignerD symbol
>   * with full expressions for the angles.
>   * Used for IMRPhenomP(v2):
>   * \f{equation}{
>   * \cos(\beta) = \hat J . \hat L
>   *             = \left( 1 + \left( S_\mathrm{p} / (L + S_L) \right)^2 \right)^{-1/2}
>   *             = \left( L + S_L \right) / \sqrt{ \left( L + S_L \right)^2 + S_p^2 }
>   *             = \mathrm{sign}\left( L + S_L \right) \cdot \left( 1 + \left( S_p / \left(L + S_L\right)\right)^2 \right)^{-1/2}
>   * \f}
>  */
832a1085,1086
>   REAL8 *cos_beta_half, /**< [out] cos(beta/2) */
>   REAL8 *sin_beta_half, /**< [out] sin(beta/2) */
836c1090,1119
<   const REAL8 Sp,       /**< Dimensionfull spin component in the orbital plane */
---
>   const REAL8 Sp)       /**< Dimensionfull spin component in the orbital plane */
> {
>   XLAL_CHECK_VOID(cos_beta_half != NULL, XLAL_EFAULT);
>   XLAL_CHECK_VOID(sin_beta_half != NULL, XLAL_EFAULT);
>   /* We define the shorthand s := Sp / (L + SL) */
>   const REAL8 L = L2PNR(v, eta);
>   if (L + SL < 0.0)
>     XLAL_PRINT_WARNING("Warning: IMRPhenomP L + SL < 0. The waveform might not be accurate here.\n");
>     // We ignore the sign of L + SL below.
>   REAL8 s = Sp / (L + SL);  /* s := Sp / (L + SL) */
>   REAL8 s2 = s*s;
>   REAL8 cos_beta = 1.0 / sqrt(1.0 + s2);
>   *cos_beta_half = + sqrt( (1.0 + cos_beta) / 2.0 );  /* cos(beta/2) */
>   *sin_beta_half = + sqrt( (1.0 - cos_beta) / 2.0 );  /* sin(beta/2) */
> }
> 
> /** Expressions used for the WignerD symbol
>   * with small angle approximation.
>   * Used for IMRPhenomP(v1):
>   * \f{equation}{
>   * \cos(\beta) = \hat J . \hat L
>   *             = \left(1 + \left( S_\mathrm{p} / (L + S_L)\right)^2 \right)^{-1/2}
>   * \f}
>   * We use the expression
>   * \f{equation}{
>   * \cos(\beta/2) \approx (1 + s^2 / 4 )^{-1/2} \,,
>   * \f}
>   * where \f$s := S_p / (L + S_L)\f$.
>  */
> static void WignerdCoefficients_SmallAngleApproximation(
838c1121,1125
<   REAL8 *sin_beta_half) /**< Output: sin(beta/2) */
---
>   REAL8 *sin_beta_half, /**< Output: sin(beta/2) */
>   const REAL8 v,        /**< Cubic root of (Pi * Frequency (geometric)) */
>   const REAL8 SL,       /**< Dimensionfull aligned spin */
>   const REAL8 eta,      /**< Symmetric mass-ratio */
>   const REAL8 Sp)       /**< Dimensionfull spin component in the orbital plane */
840,842c1127,1129
<   /* cos(beta) = \hat J . \hat L = (1 + (Sp / (L + SL))^2 )^(-1/2) */
<   /* We use the expression cos(beta/2) \approx (1 + s^2 / 4 )^(-1/2) where s := Sp / (L + SL) */
<   REAL8 s = Sp / (L2PNR(v, eta) + SL);  /* s := Sp / (L + SL) */
---
>   XLAL_CHECK_VOID(cos_beta_half != NULL, XLAL_EFAULT);
>   XLAL_CHECK_VOID(sin_beta_half != NULL, XLAL_EFAULT);
>   REAL8 s = Sp / (L2PNR_v1(v, eta) + SL);  /* s := Sp / (L + SL) */
848,850c1135,1148
< static REAL8 FinalSpinBarausse2009_all_spin_on_larger_BH(
<   const REAL8 nu,     /**< Symmetric mass-ratio */
<   const REAL8 chi,    /**< Reduced aligned spin of the binary chi = (m1*chi1 + m2*chi2)/M */
---
> /**
>  * Wrapper for final-spin formula based on:
>  * - IMRPhenomD's FinalSpin0815() for aligned spins.
>  *
>  * We use their convention m1>m2
>  * and put <b>all in-plane spin on the larger BH</b>.
>  *
>  * In the aligned limit return the FinalSpin0815 value.
>  */
> static REAL8 FinalSpinIMRPhenomD_all_in_plane_spin_on_larger_BH(
>   const REAL8 m1,     /**< Mass of companion 1 (solar masses) */
>   const REAL8 m2,     /**< Mass of companion 2 (solar masses) */
>   const REAL8 chi1_l, /**< Aligned spin of BH 1 */
>   const REAL8 chi2_l, /**< Aligned spin of BH 2 */
853,867c1151,1152
<   /* Use convention m1>m2 as in arXiv:0904.2577 */
<   /* Put all spin on larger BH: a1 = (chip, 0, chi), a2 = (0,0,0), L = (0,0,1) */
<   const REAL8 a1_x = chip;
<   const REAL8 a1_y = 0;
<   const REAL8 a1_z = chi;
<   const REAL8 a2_x = 0;
<   const REAL8 a2_y = 0;
<   const REAL8 a2_z = 0;
< 
<   const REAL8 a1 = sqrt(a1_x*a1_x + a1_y*a1_y + a1_z*a1_z);
<   const REAL8 a2 = sqrt(a2_x*a2_x + a2_y*a2_y + a2_z*a2_z);
< 
<   const REAL8 cos_alpha = (a1*a2 == 0) ? 0.0 : a1_z*a2_z/(a1*a2); /* cos(alpha) = \hat a1 . \hat a2 (Eq. 7) */
<   const REAL8 cos_beta_tilde  = (a1 == 0) ? 0.0 : a1_z/a1;  /* \cos(\tilde \beta)  = \hat a1 . \hat L  (Eq. 9) */
<   const REAL8 cos_gamma_tilde = (a2 == 0) ? 0.0 : a2_z/a2;  /* \cos(\tilde \gamma) = \hat a2 . \hat L (Eq. 9) */
---
>   const REAL8 M = m1+m2;
>   const REAL8 eta = m1*m2/(M*M);
869c1154,1166
<   return FinalSpinBarausse2009(nu, a1, a2, cos_alpha, cos_beta_tilde, cos_gamma_tilde);
---
>   REAL8 af_parallel, q_factor;
>   if (m1 >= m2) {
>     q_factor = m1/M;
>     af_parallel = FinalSpin0815(eta, chi1_l, chi2_l);
>   }
>   else {
>     q_factor = m2/M;
>     af_parallel = FinalSpin0815(eta, chi2_l, chi1_l);
>   }  
> 
>   REAL8 Sperp = chip * q_factor*q_factor;
>   REAL8 af = copysign(1.0, af_parallel) * sqrt(Sperp*Sperp + af_parallel*af_parallel);
>   return af;
872,873c1169,1179
< #if 0
< static REAL8 FinalSpinBarausse2009_aligned_spin_equally_distributed(
---
> /**
>  * Wrapper for final-spin formula based on:
>  * - Barausse \& Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009,
>  * arXiv:0904.2577
>  *
>  * We use their convention m1>m2
>  * and put <b>all spin on the larger BH</b>:
>  *
>  * a1 = (chip, 0, chi), a2 = (0,0,0), L = (0,0,1)
>  */
> static REAL8 FinalSpinBarausse2009_all_spin_on_larger_BH(
875c1181
<   const REAL8 chi,    /**< Reduced aligned spin of the binary chi = (m1*chi1 + m2*chi2)/M */
---
>   const REAL8 chi,    /**< Effective aligned spin of the binary:  chi = (m1*chi1 + m2*chi2)/M  */
878,879c1184
<   /* Use convention m1>m2 as in arXiv:0904.2577 */
<   /* Put all spin on larger BH: a1 = (chip, 0, chi), a2 = (0,0,0), L = (0,0,1) */
---
> 
885c1190
<   const REAL8 a2_z = chi;
---
>   const REAL8 a2_z = 0;
896d1200
< #endif
898c1202,1209
< static REAL8 FinalSpinBarausse2009(  /* Barausse & Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009, arXiv:0904.2577 */
---
> /**
>  * Final-spin formula based on:
>  * - Barausse \& Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009,
>  * arXiv:0904.2577
>  *
>  * We use their convention m1>m2.
>  */
> static REAL8 FinalSpinBarausse2009(
902,904c1213,1215
<   const REAL8 cos_alpha,        /**< cos(alpha) = \hat a_1 . \hat a_2 (Eq. 7) */
<   const REAL8 cos_beta_tilde,   /**< cos(\tilde beta)  = \hat a_1 . \hat L (Eq. 9) */
<   const REAL8 cos_gamma_tilde)  /**< cos(\tilde gamma) = \hat a_2 . \hat L (Eq. 9)*/
---
>   const REAL8 cos_alpha,        /**< \f$\cos(\alpha) = \hat a_1 . \hat a_2\f$ (Eq. 7) */
>   const REAL8 cos_beta_tilde,   /**< \f$\cos(\tilde \beta)  = \hat a_1 . \hat L\f$ (Eq. 9) */
>   const REAL8 cos_gamma_tilde)  /**< \f$\cos(\tilde \gamma) = \hat a_2 . \hat L\f$ (Eq. 9)*/
906c1217
<   REAL8 q = (2*nu)/(1 + sqrt(1 - 4*nu) - 2*nu); /* Use convention q = m2/m1 <= 1 as in arXiv:0904.2577 */
---
>   REAL8 q = (2*nu)/(1 + sqrt(1 - 4*nu) - 2*nu);
938,939c1249,1255
< /* PhenomC parameters for modified ringdown: Uses final spin formula of Barausse & Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009 */
< static BBHPhenomCParams *ComputeIMRPhenomCParamsRDmod(
---
> /**
>  * PhenomC parameters for modified ringdown,
>  * uses final spin formula of:
>  * - Barausse \& Rezzolla, Astrophys.J.Lett.704:L40-L44, 2009,
>  * arXiv:0904.2577
>  */
> UNUSED static BBHPhenomCParams *ComputeIMRPhenomCParamsRDmod(
956,957c1272,1273
<     XLAL_PRINT_ERROR("Error: magnitude of final spin > 1!");
<     XLAL_ERROR_NULL( XLAL_EDOM );
---
>     XLAL_PRINT_WARNING("Warning: final spin magnitude %g > 1. Setting final spin magnitude = 1.", finspin);
>     finspin = copysign(1.0, finspin);
Only in .: LALSimIMRPhenomP.h
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomP.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPhenomP.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRPSpinInspiralRD.c ./LALSimIMRPSpinInspiralRD.c
81,102c81,101
<   REAL8 wdotSO15s1, wdotSO15s2; ///< non-dynamical 1.5PN SO corrections
<   REAL8 wdotSS2; ///< non-dynamical 2PN SS correction
<   REAL8 wdotSSO2; ///< non-dynamical 2PN SS correction
<   REAL8 wdotQM2S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
<   REAL8 wdotQM2S1L; ///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
<   REAL8 wdotQM2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
<   REAL8 wdotQM2S2L; ///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
<   REAL8 wdotSSselfS1; ///< non-dynamical S1^2 2PN self-spin correction
<   REAL8 wdotSSselfS1L; ///< non-dynamical (S1.L)^2 self-spin correction
<   REAL8 wdotSSselfS2; ///< non-dynamical S2^2 2PN self-spin correction
<   REAL8 wdotSSselfS2L; ///< non-dynamical (S2.L)^2 self-spin correction
<   REAL8 wdotSO25s1, wdotSO25s2; ///< non-dynamical 2.5PN SO corrections
<   REAL8 wdotSO3s1, wdotSO3s2; ///< non-dynamical 3PN SO corrections
<   REAL8 ESO15s1, ESO15s2; ///< non-dynamical 1.5PN SO corrections
<   REAL8 ESS2,ESSO2; ///< non-dynamical 2PN SS correction
<   REAL8 EQM2S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
<   REAL8 EQM2S1L;///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
<   REAL8 EQM2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
<   REAL8 EQM2S2L;///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
<   REAL8 ESO25s1, ESO25s2; ///< non-dynamical 2.5PN SO corrections
<   REAL8 LNhatSO15s1, LNhatSO15s2; ///< non-dynamical 1.5PN SO corrections
<   REAL8 LNhatSS2; ///< non-dynamical 2PN SS correction
---
>   REAL8 wdot3S1O, wdot3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 wdot4S1S2; ///< non-dynamical 2PN SS correction
>   REAL8 wdot4S1OS2O; ///< non-dynamical 2PN SS correction
>   REAL8 wdot4S1S1,wdot4S2S2; ///< non-dynamical 2PN SS correction
>   REAL8 wdot4S1OS1O,wdot4S2OS2O; ///< non-dynamical 2PN SS correction
>   REAL8 wdot4QMS1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
>   REAL8 wdot4QMS1O; ///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
>   REAL8 wdot4QMS2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
>   REAL8 wdot4QMS2O; ///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
>   REAL8 wdot5S1O, wdot5S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 wdot6S1O, wdot6S2O; ///< non-dynamical 3PN SO corrections
>   REAL8 E3S1O, E3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 E4S1S2,E4S1OS2O; ///< non-dynamical 2PN SS correction
>   REAL8 E4QMS1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS1O;///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS2O;///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
>   REAL8 E5S1O, E5S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 E6S1O, E6S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 LNhat3S1O, LNhat3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 LNhat4SS; ///< non-dynamical 2PN SS correction
107,110c106,110
<   REAL8 S1dot15, S2dot15;  ///< UNDOCUMENTED
<   REAL8 Sdot2S1S2,Sdot2LS1LS2;  ///< UNDOCUMENTED
<   REAL8 S1dot2LS1LS1,S2dot2LS2LS2;  ///< UNDOCUMENTED
<   REAL8 S1dot25, S2dot25;  ///< UNDOCUMENTED
---
>   REAL8 S1dot3, S2dot3;  ///< UNDOCUMENTED
>   REAL8 Sdot4S2,Sdot4S2O;  ///< UNDOCUMENTED
>   REAL8 S1dot4QMS1O,S2dot4QMS2O;  ///< UNDOCUMENTED
>   REAL8 S1dot5, S2dot5;  ///< UNDOCUMENTED
>   REAL8 S1dot6, S2dot6;  ///< UNDOCUMENTED
166c166,171
<                                          LALSimInspiralSpinOrder spinO,                 /**< Spin interaction */
---
> 					 REAL8 lambda1,      /**< Tidal par1*/
>                                          REAL8 lambda2,      /**< Tidal par2*/
>                                          REAL8 quadparam1,   /**< Quad-monop par1*/
> 					 REAL8 quadparam2,   /**< Quad-monop par2*/
> 					 LALSimInspiralSpinOrder spinO,                 /**< Spin interaction */
>                                          LALSimInspiralTidalOrder tideO,                /**< Tidal iteraction interaction */
204,205c209,210
<       params->wdotSO3s1   = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(params->m1ByM);
<       params->wdotSO3s2   = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(params->m2ByM);
---
>       params->wdot6S1O   = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(params->m1ByM);
>       params->wdot6S2O   = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(params->m2ByM);
210,215c215,220
<       params->ESO25s1     = XLALSimInspiralPNEnergy_5PNSOCoeff(params->m1ByM);
<       params->ESO25s2     = XLALSimInspiralPNEnergy_5PNSOCoeff(params->m1ByM);
<       params->wdotSO25s1  = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(params->m1ByM);
<       params->wdotSO25s2  = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(params->m2ByM);
<       params->S1dot25     = XLALSimInspiralSpinDot_5PNCoeff(params->m1ByM);
<       params->S2dot25     = XLALSimInspiralSpinDot_5PNCoeff(params->m2ByM);
---
>       params->E5S1O     = XLALSimInspiralPNEnergy_5PNSOCoeff(params->m1ByM);
>       params->E5S2O     = XLALSimInspiralPNEnergy_5PNSOCoeff(params->m1ByM);
>       params->wdot5S1O  = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(params->m1ByM);
>       params->wdot5S2O  = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(params->m2ByM);
>       params->S1dot5    = XLALSimInspiralSpinDot_5PNCoeff(params->m1ByM);
>       params->S2dot5    = XLALSimInspiralSpinDot_5PNCoeff(params->m2ByM);
219,235c224,244
<       params->Ecoeff[4]   = XLALSimInspiralPNEnergy_4PNCoeff(params->eta);
<       params->wdotSS2     = XLALSimInspiralTaylorT4wdot_4PNS1S2Coeff(params->eta);
<       params->wdotSSO2    = XLALSimInspiralTaylorT4wdot_4PNS1S2OCoeff(params->eta);
<       params->ESS2        = XLALSimInspiralPNEnergy_4PNS1S2Coeff(params->eta);
<       params->ESSO2       = XLALSimInspiralPNEnergy_4PNS1S2OCoeff(params->eta);
<       params->wdotSSselfS1 = XLALSimInspiralTaylorT4wdot_4PNSelfSSCoeff(params->m1ByM);
<       params->wdotSSselfS1L= XLALSimInspiralTaylorT4wdot_4PNSelfSSOCoeff(params->m1ByM);
<       params->wdotSSselfS2 = XLALSimInspiralTaylorT4wdot_4PNSelfSSCoeff(params->m2ByM);
<       params->wdotSSselfS2L= XLALSimInspiralTaylorT4wdot_4PNSelfSSOCoeff(params->m2ByM);
<       params->EQM2S1  = XLALSimInspiralPNEnergy_4PNQM2SCoeff(params->m1ByM);
<       params->EQM2S2  = XLALSimInspiralPNEnergy_4PNQM2SCoeff(params->m2ByM);
<       params->EQM2S1L = XLALSimInspiralPNEnergy_4PNQM2SOCoeff(params->m1ByM);
<       params->EQM2S2L = XLALSimInspiralPNEnergy_4PNQM2SOCoeff(params->m2ByM);
<       params->Sdot2S1S2   = XLALSimInspiralSpinDot_4PNCoeffS1S2;
<       params->Sdot2LS1LS2 = XLALSimInspiralSpinDot_4PNCoeffLS1LS2;
<       params->S1dot2LS1LS1 = XLALSimInspiralSpinDot_4PNCoeffLSOSself(params->m1ByM);
<       params->S2dot2LS2LS2 = XLALSimInspiralSpinDot_4PNCoeffLSOSself(params->m2ByM);
---
>       params->Ecoeff[4]     = XLALSimInspiralPNEnergy_4PNCoeff(params->eta);
>       params->wdot4S1S2     = XLALSimInspiralTaylorT4wdot_4PNS1S2Coeff(params->eta);
>       params->wdot4S1OS2O   = XLALSimInspiralTaylorT4wdot_4PNS1S2OCoeff(params->eta);
>       params->E4S1S2      = XLALSimInspiralPNEnergy_4PNS1S2Coeff(params->eta);
>       params->E4S1OS2O    = XLALSimInspiralPNEnergy_4PNS1S2OCoeff(params->eta);
>       params->wdot4S1S1     = XLALSimInspiralTaylorT4wdot_4PNSelf2SCoeff(params->m1ByM);
>       params->wdot4S1OS1O   = XLALSimInspiralTaylorT4wdot_4PNSelf2SOCoeff(params->m1ByM);
>       params->wdot4S2S2     = XLALSimInspiralTaylorT4wdot_4PNSelf2SCoeff(params->m2ByM);
>       params->wdot4S2OS2O   = XLALSimInspiralTaylorT4wdot_4PNSelf2SOCoeff(params->m2ByM);
>       params->wdot4QMS1     = quadparam1*XLALSimInspiralTaylorT4wdot_4PNQM2SCoeff(params->m1ByM);
>       params->wdot4QMS1O    = quadparam1*XLALSimInspiralTaylorT4wdot_4PNQM2SOCoeff(params->m1ByM);
>       params->wdot4QMS2     = quadparam2*XLALSimInspiralTaylorT4wdot_4PNQM2SCoeff(params->m2ByM);
>       params->wdot4QMS2O    = quadparam2*XLALSimInspiralTaylorT4wdot_4PNQM2SOCoeff(params->m2ByM);
>       params->E4QMS1      = quadparam1*XLALSimInspiralPNEnergy_4PNQM2SCoeff(params->m1ByM);
>       params->E4QMS2      = quadparam2*XLALSimInspiralPNEnergy_4PNQM2SCoeff(params->m2ByM);
>       params->E4QMS1O     = quadparam1*XLALSimInspiralPNEnergy_4PNQM2SOCoeff(params->m1ByM);
>       params->E4QMS2O     = quadparam2*XLALSimInspiralPNEnergy_4PNQM2SOCoeff(params->m2ByM);
>       params->Sdot4S2     = XLALSimInspiralSpinDot_4PNS2Coeff;
>       params->Sdot4S2O    = XLALSimInspiralSpinDot_4PNS2OCoeff;
>       params->S1dot4QMS1O  = quadparam1*XLALSimInspiralSpinDot_4PNQMSOCoeff(params->m1ByM);
>       params->S2dot4QMS2O  = quadparam2*XLALSimInspiralSpinDot_4PNQMSOCoeff(params->m2ByM);
240,245c249,254
<       params->wdotSO15s1 = XLALSimInspiralTaylorT4wdot_3PNSOCoeff(params->m1ByM);
<       params->wdotSO15s2 = XLALSimInspiralTaylorT4wdot_3PNSOCoeff(params->m1ByM);
<       params->ESO15s1    = XLALSimInspiralPNEnergy_3PNSOCoeff(params->m1ByM);
<       params->ESO15s2    = XLALSimInspiralPNEnergy_3PNSOCoeff(params->m1ByM);
<       params->S1dot15    = XLALSimInspiralSpinDot_3PNCoeff(params->m1ByM);
<       params->S2dot15    = XLALSimInspiralSpinDot_3PNCoeff(params->m2ByM);
---
>       params->wdot3S1O  = XLALSimInspiralTaylorT4wdot_3PNSOCoeff(params->m1ByM);
>       params->wdot3S2O  = XLALSimInspiralTaylorT4wdot_3PNSOCoeff(params->m1ByM);
>       params->E3S1O     = XLALSimInspiralPNEnergy_3PNSOCoeff(params->m1ByM);
>       params->E3S2O     = XLALSimInspiralPNEnergy_3PNSOCoeff(params->m1ByM);
>       params->S1dot3    = XLALSimInspiralSpinDot_3PNCoeff(params->m1ByM);
>       params->S2dot3    = XLALSimInspiralSpinDot_3PNCoeff(params->m2ByM);
278,283c287,292
<       params->ESO15s1     = 0.;
<       params->ESO15s2     = 0.;
<       params->wdotSO15s1  = 0.;
<       params->wdotSO15s1  = 0.;
<       params->S1dot15     = 0.;
<       params->S2dot15     = 0.;
---
>       params->E6S1O      = 0.;
>       params->E6S2O      = 0.;
>       params->wdot6S1O   = 0.;
>       params->wdot6S1O   = 0.;
>       params->S1dot6     = 0.;
>       params->S2dot6     = 0.;
287,291c296,301
<       params->wdotSS2 = 0.;
<       params->EQM2S1  = 0.;
<       params->EQM2S2  = 0.;
<       params->EQM2S1L = 0.;
<       params->EQM2S2L = 0.;
---
>       params->wdot4S1S2   = 0.;
>       params->wdot4S1OS2O = 0.;
>       params->E4QMS1  = 0.;
>       params->E4QMS2  = 0.;
>       params->E4QMS1O = 0.;
>       params->E4QMS2O = 0.;
295,300c305,310
<       params->ESO25s1       = 0.;
<       params->ESO25s2       = 0.;
<       params->wdotSO25s1    = 0.;
<       params->wdotSO25s1    = 0.;
<       params->S1dot25       = 0.;
<       params->S2dot25       = 0.;
---
>       params->E5S1O       = 0.;
>       params->E5S2O       = 0.;
>       params->wdot5S1O    = 0.;
>       params->wdot5S2O    = 0.;
>       params->S1dot5      = 0.;
>       params->S2dot5      = 0.;
304,305c314,315
<       params->wdotSO3s1   = 0.;
<       params->wdotSO3s2   = 0.;
---
>       params->wdot6S1O   = 0.;
>       params->wdot6S2O   = 0.;
311a322,339
> 
>   switch( tideO ) {
>     case LAL_SIM_INSPIRAL_TIDAL_ORDER_ALL:
>     case LAL_SIM_INSPIRAL_TIDAL_ORDER_6PN:
>       params->wdottidal6pn = lambda1 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(params->m1ByM) + lambda2 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(params->m2ByM);
>       params->Etidal6pn =  lambda1*XLALSimInspiralPNEnergy_12PNTidalCoeff(params->m1ByM) + lambda2*XLALSimInspiralPNEnergy_12PNTidalCoeff(params->m2ByM);
>     case LAL_SIM_INSPIRAL_TIDAL_ORDER_5PN:
>       params->wdottidal5pn = lambda1 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(params->m1ByM) + lambda2 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(params->m2ByM);
>       params->Etidal5pn = lambda1*XLALSimInspiralPNEnergy_10PNTidalCoeff(params->m1ByM) + lambda2*XLALSimInspiralPNEnergy_10PNTidalCoeff(params->m2ByM);
>     case LAL_SIM_INSPIRAL_TIDAL_ORDER_0PN:
>       break;
>     default:
>       XLALPrintError("XLAL Error - %s: Invalid tidal PN order %d\n",
> 		     __func__, tideO );
>       XLAL_ERROR(XLAL_EINVAL);
>       break;
>   }
> 
377a406,408
>   domega+= omega*v7* ( params->wdottidal5pn + v2 * ( params->wdottidal6pn ) );
>   energy+= omega*v7* ( params->Etidal5pn + v2 * params->Etidal6pn);
> 
384c415
<   domega += omega * (params->wdotSO15s1 * LNhS1 + params->wdotSO15s2 * LNhS2); // see e.g. Buonanno et al. gr-qc/0211087
---
>   domega += omega * (params->wdot3S1O * LNhS1 + params->wdot3S2O * LNhS2); // see e.g. Buonanno et al. gr-qc/0211087
386c417
<   energy += omega * (params->ESO15s1 * LNhS1 + params->ESO15s2 * LNhS2);  // see e.g. Blanchet et al. gr-qc/0605140
---
>   energy += omega * (params->E3S1O * LNhS1 + params->E3S2O * LNhS2);  // see e.g. Blanchet et al. gr-qc/0605140
392,393c423,424
<   domega += v4 * ( params->wdotSS2 * S1S2 + params->wdotSSO2 * LNhS1 * LNhS2);  // see e.g. Buonanno et al. arXiv:0810.5336
<   domega += v4 * ( params->wdotSSselfS1L * LNhS1*LNhS1 + params->wdotSSselfS1L * LNhS2*LNhS2 + params->wdotSSselfS1 * S1S1 + params->wdotSSselfS2 * S2S2 );
---
>   domega += v4 * ( params->wdot4S1S2 * S1S2 + params->wdot4S1OS2O * LNhS1 * LNhS2);  // see e.g. Buonanno et al. arXiv:0810.5336
>   domega += v4 * ( params->wdot4QMS1O * LNhS1*LNhS1 + params->wdot4QMS2O * LNhS2*LNhS2 + params->wdot4QMS1 * S1S1 + params->wdot4QMS2 * S2S2 );
396,397c427,428
<   energy += v4 * (params->ESS2 * S1S2 + params->ESSO2 * LNhS1 * LNhS2);    // see e.g. Buonanno et al. as above
<   energy += v4 * (params->EQM2S1 * S1S1 + params->EQM2S2 * S2S2 + params->EQM2S1L * LNhS1 * LNhS1 + params->EQM2S2L * LNhS2 * LNhS2);   // see Racine et al. as above
---
>   energy += v4 * (params->E4S1S2 * S1S2 + params->E4S1OS2O * LNhS1 * LNhS2);    // see e.g. Buonanno et al. as above
>   energy += v4 * (params->E4QMS1 * S1S1 + params->E4QMS2 * S2S2 + params->E4QMS1O * LNhS1 * LNhS1 + params->E4QMS2O * LNhS2 * LNhS2);   // see Racine et al. as above
400,401c431,432
<   domega += v5 * (params->wdotSO25s1 * LNhS1 + params->wdotSO25s2 * LNhS2);   //see (8.3) of Blanchet et al.
<   energy += v5 * (params->ESO25s1 * LNhS1 + params->ESO25s2 * LNhS2);    //see (7.9) of Blanchet et al.
---
>   domega += v5 * (params->wdot5S1O * LNhS1 + params->wdot5S2O * LNhS2);   //see (8.3) of Blanchet et al.
>   energy += v5 * (params->E5S1O * LNhS1 + params->E5S2O * LNhS2);    //see (7.9) of Blanchet et al.
403c434
<   domega += omega*omega * (params->wdotSO3s1 * LNhS1 + params->wdotSO3s2 * LNhS2); // see (6.5) of arXiv:1104.5659
---
>   domega += omega*omega * (params->wdot6S1O * LNhS1 + params->wdot6S2O * LNhS2); // see (6.5) of arXiv:1104.5659
416,418c447,449
<   dS1x = params->S1dot15 * v5 * cross1x;
<   dS1y = params->S1dot15 * v5 * cross1y;
<   dS1z = params->S1dot15 * v5 * cross1z;
---
>   dS1x = params->S1dot3 * v5 * cross1x;
>   dS1y = params->S1dot3 * v5 * cross1y;
>   dS1z = params->S1dot3 * v5 * cross1z;
426,428c457,459
<   dS1x += v6 * (params->Sdot2S1S2*tmpx + params->Sdot2LS1LS2 * LNhS2 * cross1x);
<   dS1y += v6 * (params->Sdot2S1S2*tmpy + params->Sdot2LS1LS2 * LNhS2 * cross1y);
<   dS1z += v6 * (params->Sdot2S1S2*tmpz + params->Sdot2LS1LS2 * LNhS2 * cross1z);
---
>   dS1x += v6 * (params->Sdot4S2*tmpx + params->Sdot4S2O * LNhS2 * cross1x);
>   dS1y += v6 * (params->Sdot4S2*tmpy + params->Sdot4S2O * LNhS2 * cross1y);
>   dS1z += v6 * (params->Sdot4S2*tmpz + params->Sdot4S2O * LNhS2 * cross1z);
430,432c461,463
<   dS1x += v6 * LNhS1 * cross1x * params->S1dot2LS1LS1;
<   dS1y += v6 * LNhS1 * cross1y * params->S1dot2LS1LS1;
<   dS1z += v6 * LNhS1 * cross1z * params->S1dot2LS1LS1;
---
>   dS1x += v6 * LNhS1 * cross1x * params->S1dot4QMS1O;
>   dS1y += v6 * LNhS1 * cross1y * params->S1dot4QMS1O;
>   dS1z += v6 * LNhS1 * cross1z * params->S1dot4QMS1O;
435,437c466,468
<   dS1x += params->S1dot25 * v7 * cross1x;
<   dS1y += params->S1dot25 * v7 * cross1y;
<   dS1z += params->S1dot25 * v7 * cross1z;
---
>   dS1x += params->S1dot5 * v7 * cross1x;
>   dS1y += params->S1dot5 * v7 * cross1y;
>   dS1z += params->S1dot5 * v7 * cross1z;
444,446c475,477
<   dS2x = params->S2dot15 * v5 * cross2x;
<   dS2y = params->S2dot15 * v5 * cross2y;
<   dS2z = params->S2dot15 * v5 * cross2z;
---
>   dS2x = params->S2dot3 * v5 * cross2x;
>   dS2y = params->S2dot3 * v5 * cross2y;
>   dS2z = params->S2dot3 * v5 * cross2z;
449,451c480,482
<   dS2x += v6 * (-params->Sdot2S1S2*tmpx + params->Sdot2LS1LS2 * LNhS1 * cross2x);
<   dS2y += v6 * (-params->Sdot2S1S2*tmpy + params->Sdot2LS1LS2 * LNhS1 * cross2y);
<   dS2z += v6 * (-params->Sdot2S1S2*tmpz + params->Sdot2LS1LS2 * LNhS1 * cross2z);
---
>   dS2x += v6 * (-params->Sdot4S2*tmpx + params->Sdot4S2O * LNhS1 * cross2x);
>   dS2y += v6 * (-params->Sdot4S2*tmpy + params->Sdot4S2O * LNhS1 * cross2y);
>   dS2z += v6 * (-params->Sdot4S2*tmpz + params->Sdot4S2O * LNhS1 * cross2z);
453,455c484,486
<   dS2x += v6 * LNhS2 * cross2x * params->S2dot2LS2LS2;
<   dS2y += v6 * LNhS2 * cross2y * params->S2dot2LS2LS2;
<   dS2z += v6 * LNhS2 * cross2z * params->S2dot2LS2LS2;
---
>   dS2x += v6 * LNhS2 * cross2x * params->S2dot4QMS2O;
>   dS2y += v6 * LNhS2 * cross2y * params->S2dot4QMS2O;
>   dS2z += v6 * LNhS2 * cross2z * params->S2dot4QMS2O;
458,460c489,491
<   dS2x += params->S2dot25 * v7 * cross2x;
<   dS2y += params->S2dot25 * v7 * cross2y;
<   dS2z += params->S2dot25 * v7 * cross2z;
---
>   dS2x += params->S2dot5 * v7 * cross2x;
>   dS2y += params->S2dot5 * v7 * cross2y;
>   dS2z += params->S2dot5 * v7 * cross2z;
1239,1249c1270,1284
< static INT4 XLALSimIMRPhenSpinInitialize(REAL8 mass1,                              /* in Msun units */
<                                         REAL8 mass2,                              /* in Msun units */
<                                         REAL8 *yinit,
<                                         REAL8 fStart,                             /* in Hz*/
<                                         REAL8 fEnd,                               /* in Hz*/
<                                         REAL8 deltaT,
<                                         INT4 phaseO,
<                                         LALSimInspiralPhenSpinTaylorT4Coeffs *params,
<                                         LALSimInspiralWaveformFlags      *waveFlags,
<                                         LALSimInspiralTestGRParam        *testGRparams,
<                                         Approximant approx)
---
> static INT4 XLALSimIMRPhenSpinInitialize(REAL8 mass1,                              /**< in Msun units */
>                                          REAL8 mass2,                              /**< in Msun units */
>                                          REAL8 lambda1,       /**< Tidal par1*/
>                                          REAL8 lambda2,       /**< Tidal par2*/
>                                          REAL8 quadparam1,    /**< Quad-monopole  par1*/
>                                          REAL8 quadparam2,    /**< Quad-monopole  par2*/
> 					 REAL8 *yinit,        /**< Initial values*/
>                                          REAL8 fStart,                             /**< in Hz*/
>                                          REAL8 fEnd,                               /**< in Hz*/
> 					 REAL8 deltaT,        /**< sampling time (sec)*/
>                                          INT4 phaseO,         /**< (twice) phase order*/
>                                          LALSimInspiralPhenSpinTaylorT4Coeffs *params,        /**< Coefficient holder*/
>                                          LALSimInspiralWaveformFlags      *waveFlags,         /**< Flags*/
>                                          LALSimInspiralTestGRParam        *testGRparams,      /**< Extra pars container*/
>                                          Approximant approx    /**< Approximant*/)
1288c1323
<   if(XLALSimIMRPhenSpinParamsSetup(params,deltaT,fStart,fEnd,mass1,mass2,XLALSimInspiralGetSpinOrder(waveFlags),testGRparams,phaseO)) {
---
>   if(XLALSimIMRPhenSpinParamsSetup(params,deltaT,fStart,fEnd,mass1,mass2,lambda1,lambda2,quadparam1,quadparam2,XLALSimInspiralGetSpinOrder(waveFlags),XLALSimInspiralGetTidalOrder(waveFlags),testGRparams,phaseO)) {
1620a1656,1659
>                                  REAL8 lambda1,        /**< Tidal  par1*/
> 				 REAL8 lambda2,        /**< Tidal  par2*/
> 				 REAL8 quadparam1,     /**< Quad-monopole  par1*/
> 				 REAL8 quadparam2,     /**< Quad-monopole  par1*/
1669c1708
<     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,yinit,f_start,-1.,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylor")))
---
>     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,lambda1,lambda2,quadparam1,quadparam2,yinit,f_start,-1.,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylor")))
1680c1719
<     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,yinit,f_ref,f_start,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylor")))
---
>     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,lambda1,lambda2,quadparam1,quadparam2,yinit,f_ref,f_start,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylor")))
1979c2018,2023
<                                           INT4 phaseO,                            /**< twice post-Newtonian phase order */                                                     INT4 UNUSED ampO,                       /**< twice post-Newtonian amplitude order */
---
>                                           INT4 phaseO,                            /**< twice post-Newtonian phase order */
>                                           INT4 UNUSED ampO,                       /**< twice post-Newtonian amplitude order */
>                                           REAL8 lambda1,        /**< Tidal  par1*/
>                                           REAL8 lambda2,        /**< Tidal  par2*/
>                                           REAL8 quadparam1,     /**< Quad-monopole par1*/
>                                           REAL8 quadparam2,     /**< Quad-monopole par2*/
2027c2071
<     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,yinit,f_start,-1.,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylorRD")))
---
>     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,lambda1,lambda2,quadparam1,quadparam2,yinit,f_start,-1.,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylorRD")))
2039c2083
<     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,yinit,f_ref,f_start,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylorRD")))
---
>     if (XLALSimIMRPhenSpinInitialize(mass1,mass2,lambda1,lambda2,quadparam1,quadparam2,yinit,f_ref,f_start,deltaT,phaseO,&params,waveFlags,testGRparams,XLALGetApproximantFromString("PhenSpinTaylorRD")))
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPSpinInspiralRD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRPSpinInspiralRD.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSEOBNRROMUtilities.c ./LALSimIMRSEOBNRROMUtilities.c
2c2
<  *  Copyright (C) 2014 Michael Puerrer, John Veitch
---
>  *  Copyright (C) 2014, 2015 Michael Puerrer, John Veitch
29c29
<  * LALSimIMRSEOBNRv2ChirpTime.c.
---
>  * LALSimIMRSEOBNRv2ChirpTime.c, LALSimIMRSEOBNRv2ROMDoubleSpinHI.c.
32,33c32,33
<  * data stored in gsl binary vectors and matrices,
<  * parameter space interpolation with B-splines,
---
>  * data stored in gsl binary vectors and matrices, HDF5 files using the LAL interface,
>  * parameter space interpolation with B-splines, fitting to a cubic,
40a41
> #include <gsl/gsl_multifit.h>
41a43,45
> #ifdef LAL_HDF5_ENABLED
> #include <lal/H5FileIO.h>
> #endif
43,44c47,48
< static void err_handler(const char *reason, const char *file, int line, int gsl_errno);
< static int read_vector(const char dir[], const char fname[], gsl_vector *v);
---
> UNUSED static void err_handler(const char *reason, const char *file, int line, int gsl_errno);
> UNUSED static int read_vector(const char dir[], const char fname[], gsl_vector *v);
46a51,58
> #ifdef LAL_HDF5_ENABLED
> UNUSED static int CheckVectorFromHDF5(LALH5File *file, const char name[], const double *v, size_t n);
> UNUSED static int ReadHDF5RealVectorDataset(LALH5File *file, const char *name, gsl_vector **data);
> UNUSED static int ReadHDF5RealMatrixDataset(LALH5File *file, const char *name, gsl_matrix **data);
> UNUSED static void PrintInfoStringAttribute(LALH5File *file, const char attribute[]);
> UNUSED static int ROM_check_version_number(LALH5File *file, 	INT4 version_major_in, INT4 version_minor_in, INT4 version_micro_in);
> #endif
> 
69,70c81,99
< static bool approximately_equal(REAL8 x, REAL8 y, REAL8 epsilon);
< static void nudge(REAL8 *x, REAL8 X, REAL8 epsilon);
---
> UNUSED static gsl_vector *Fit_cubic(const gsl_vector *xi, const gsl_vector *yi);
> 
> UNUSED static bool approximately_equal(REAL8 x, REAL8 y, REAL8 epsilon);
> UNUSED static void nudge(REAL8 *x, REAL8 X, REAL8 epsilon);
> 
> UNUSED static double SEOBNRROM_Ringdown_Mf_From_Mtot_q(
>   const double Mtot_sec,
>   const double q,
>   const double chi1,
>   const double chi2,
>   Approximant apx
> );
> UNUSED static double SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(
>   const double Mtot_sec,
>   const double eta,
>   const double chi1,
>   const double chi2,
>   Approximant apx
> );
84c113
<   
---
> 
86c115
<   if (!f) 
---
>   if (!f)
92c121
<   
---
> 
104c133
<   if (!f) 
---
>   if (!f)
110c139
<   
---
> 
115a145,292
> #ifdef LAL_HDF5_ENABLED
> static int CheckVectorFromHDF5(LALH5File *file, const char name[], const double *v, size_t n) {
>   gsl_vector *temp = NULL;
>   ReadHDF5RealVectorDataset(file, name, &temp);
> 
>   if (temp->size != n)
>     XLAL_ERROR(XLAL_EIO, "Length of data %s disagrees", name);
> 
>   for (size_t i=0; i<temp->size; i++)
>     if (gsl_vector_get(temp, i) != v[i])
>       XLAL_ERROR(XLAL_EIO, "Data %s disagrees", name);
>   gsl_vector_free(temp);
>   return XLAL_SUCCESS;
> }
> 
> static int ReadHDF5RealVectorDataset(LALH5File *file, const char *name, gsl_vector **data) {
> 	LALH5Dataset *dset;
> 	UINT4Vector *dimLength;
> 	size_t n;
> 
> 	if (file == NULL || name == NULL || data == NULL)
> 		XLAL_ERROR(XLAL_EFAULT);
> 
> 	dset = XLALH5DatasetRead(file, name);
> 	if (dset == NULL)
> 		XLAL_ERROR(XLAL_EFUNC);
> 
> 	if (XLALH5DatasetQueryType(dset) != LAL_D_TYPE_CODE) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_ETYPE, "Dataset `%s' is wrong type", name);
> 	}
> 
> 	dimLength = XLALH5DatasetQueryDims(dset);
> 	if (dimLength == NULL) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EFUNC);
> 	}
> 	if (dimLength->length != 1) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EDIMS, "Dataset `%s' must be 1-dimensional", name);
> 	}
> 
> 	n = dimLength->data[0];
> 	XLALDestroyUINT4Vector(dimLength);
> 
> 	if (*data == NULL) {
> 		*data = gsl_vector_alloc(n);
> 		if (*data == NULL) {
> 			XLALH5DatasetFree(dset);
> 			XLAL_ERROR(XLAL_ENOMEM, "gsl_vector_alloc(%zu) failed", n);
> 		}
> 	}
> 	else if ((*data)->size != n) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EINVAL, "Expected gsl_vector `%s' of size %zu", name, n);
> 	}
> 
>   // Now read the data
> 	if (XLALH5DatasetQueryData((*data)->data, dset) < 0) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EFUNC);
> 	}
> 
> 	XLALH5DatasetFree(dset);
> 	return 0;
> }
> 
> static int ReadHDF5RealMatrixDataset(LALH5File *file, const char *name, gsl_matrix **data) {
> 	LALH5Dataset *dset;
> 	UINT4Vector *dimLength;
> 	size_t n1, n2;
> 
> 	if (file == NULL || name == NULL || data == NULL)
> 		XLAL_ERROR(XLAL_EFAULT);
> 
> 	dset = XLALH5DatasetRead(file, name);
> 	if (dset == NULL)
> 		XLAL_ERROR(XLAL_EFUNC);
> 
> 	if (XLALH5DatasetQueryType(dset) != LAL_D_TYPE_CODE) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_ETYPE, "Dataset `%s' is wrong type", name);
> 	}
> 
> 	dimLength = XLALH5DatasetQueryDims(dset);
> 	if (dimLength == NULL) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EFUNC);
> 	}
> 	if (dimLength->length != 2) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EDIMS, "Dataset `%s' must be 2-dimensional", name);
> 	}
> 
> 	n1 = dimLength->data[0];
> 	n2 = dimLength->data[1];
> 	XLALDestroyUINT4Vector(dimLength);
> 
> 	if (*data == NULL) {
> 		*data = gsl_matrix_alloc(n1, n2);
> 		if (*data == NULL) {
> 			XLALH5DatasetFree(dset);
> 			XLAL_ERROR(XLAL_ENOMEM, "gsl_matrix_alloc(%zu, %zu) failed", n1, n2);
> 		}
> 	}
> 	else if ((*data)->size1 != n1 || (*data)->size2 != n2) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EINVAL, "Expected gsl_matrix `%s' of size %zu x %zu", name, n1, n2);
> 	}
> 
>   // Now read the data
> 	if (XLALH5DatasetQueryData((*data)->data, dset) < 0) {
> 		XLALH5DatasetFree(dset);
> 		XLAL_ERROR(XLAL_EFUNC);
> 	}
> 
> 	XLALH5DatasetFree(dset);
> 	return 0;
> }
> 
> static void PrintInfoStringAttribute(LALH5File *file, const char attribute[]) {
>   int len = XLALH5FileQueryStringAttributeValue(NULL, 0, file, attribute) + 1;
>   char *str = XLALMalloc(len);
>   XLALH5FileQueryStringAttributeValue(str, len, file, attribute);
>   XLALPrintInfo("%s\n", str);
>   LALFree(str);
> }
> 
> static int ROM_check_version_number(LALH5File *file, 	INT4 version_major_in, INT4 version_minor_in, INT4 version_micro_in) {
>   INT4 version_major;
>   INT4 version_minor;
>   INT4 version_micro;
> 
>   XLALH5FileQueryScalarAttributeValue(&version_major, file, "version_major");
>   XLALH5FileQueryScalarAttributeValue(&version_minor, file, "version_minor");
>   XLALH5FileQueryScalarAttributeValue(&version_micro, file, "version_micro");
> 
>   if ((version_major_in != version_major) || (version_minor_in != version_minor) || (version_micro_in != version_micro)) {
>     XLAL_ERROR(XLAL_EIO, "Expected ROM data version %d.%d.%d, but got version %d.%d.%d.",
>     version_major_in, version_minor_in, version_micro_in, version_major, version_minor, version_micro);
>   }
>   else {
>     XLALPrintInfo("Reading ROM data version %d.%d.%d.\n", version_major, version_minor, version_micro);
>     return XLAL_SUCCESS;
>   }
> }
> #endif
> 
209a387,422
> // Returns fitting coefficients for cubic y = c[0] + c[1]*x + c[2]*x**2 + c[3]*x**3
> static gsl_vector *Fit_cubic(const gsl_vector *xi, const gsl_vector *yi) {
>   const int n = xi->size; // how many data points are we fitting
>   const int p = 4;        // order of fitting polynomial
> 
>   gsl_matrix *X = gsl_matrix_alloc(n, p); // design matrix
>   gsl_vector *y = gsl_vector_alloc(n);    // data vector
>   gsl_vector *c = gsl_vector_alloc(p);    // coefficient vector
>   gsl_matrix *cov = gsl_matrix_alloc(p, p);
>   double chisq;
> 
>   for (int i=0; i < n; i++) {
>       double xval = gsl_vector_get(xi, i);
>       double xval2 = xval*xval;
>       double xval3 = xval2*xval;
>       gsl_matrix_set(X, i, 0, 1.0);
>       gsl_matrix_set(X, i, 1, xval);
>       gsl_matrix_set(X, i, 2, xval2);
>       gsl_matrix_set(X, i, 3, xval3);
> 
>       double yval = gsl_vector_get(yi, i);
>       gsl_vector_set (y, i, yval);
>     }
> 
>   gsl_multifit_linear_workspace *work = gsl_multifit_linear_alloc(n, p);
>   gsl_multifit_linear(X, y, c, cov, &chisq, work); // perform linear least-squares fit
> 
>   // clean up
>   gsl_multifit_linear_free(work);
>   gsl_matrix_free(X);
>   gsl_matrix_free(cov);
>   gsl_vector_free(y);
> 
>   return c;
> }
> 
229a443,470
> 
> /* compute ringdown frequency for (2,2) mode from total mass and mass ratio */
> static double SEOBNRROM_Ringdown_Mf_From_Mtot_q(
>   const double Mtot_sec,
>   const double q,
>   const double chi1,
>   const double chi2,
>   Approximant apx
> )
> {
>   double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
>   double m1_SI = Mtot_SI * q / (1. + q);
>   double m2_SI = Mtot_SI * 1. / (1. + q);
>   return XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0, 0, chi1, 0, 0, chi2, apx) * Mtot_sec;
> }
> 
> /* compute ringdown frequency for (2,2) mode from total mass and eta */
> static double SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(
>   const double Mtot_sec,
>   const double eta,
>   const double chi1,
>   const double chi2,
>   Approximant apx
> )
> {
>   double q = (1. + sqrt(1. - 4. * eta) - 2. * eta) / (2. * eta);
>   return SEOBNRROM_Ringdown_Mf_From_Mtot_q(Mtot_sec, q, chi1, chi2, apx);
> }
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSEOBNRv1ROMDoubleSpin.c ./LALSimIMRSEOBNRv1ROMDoubleSpin.c
571a572,574
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
582a586,588
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
636,640c642
<   // XLALSimInspiralGetFinalFreq wants masses in SI units, so unfortunately we need to convert back
<   double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   double Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi1, 0,0,chi2, SEOBNRv1) * Mtot_sec;
---
>   double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_q(Mtot_sec, q, chi1, chi2, SEOBNRv1);
686c688,692
<  * @addtogroup LALSimIMRSEOBNRv1ROMDoubleSpin_c
---
>  * @addtogroup LALSimIMRSEOBNRROM_c
>  *
>  * @{
>  *
>  * @name SEOBNRv1 Reduced Order Model (Double Spin)
852a859
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv1ROMDoubleSpin.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv1ROMDoubleSpin.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSEOBNRv1ROMEffectiveSpin.c ./LALSimIMRSEOBNRv1ROMEffectiveSpin.c
576a577,579
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
587a591,593
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
640,644c646
<   // XLALSimInspiralGetFinalFreq wants masses in SI units, so unfortunately we need to convert back
<   double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   double Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi, 0,0,chi, SEOBNRv1) * Mtot_sec;
---
>   double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_q(Mtot_sec, q, chi, chi, SEOBNRv1);
689c691,700
<  * @addtogroup LALSimIMRSEOBNRv1ROMEffectiveSpin_c
---
>  * @addtogroup LALSimIMRSEOBNRROM_c
>  *
>  * @brief Functions for producing SEOBNRv1 and v2 waveforms
>  * using reduced order models.
>  *
>  * @review SEOBNRv1/2_ROM_(Effective/Double)Spin reviewed by Frank Ohme, Sarah Caudill, Michael Puerrer, Ian Harry, John Veitch, Gareth Thomas. Review concluded with git hash 9dc5e84583bfe2707ac20638e7b89bf988d4d482 (July 2015).
>  *
>  * @{
>  *
>  * @name SEOBNRv1 Reduced Order Model (Effective Spin)
836a848
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv1ROMEffectiveSpin.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv1ROMEffectiveSpin.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ChirpTime.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ChirpTime.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSEOBNRv2ROMDoubleSpin.c ./LALSimIMRSEOBNRv2ROMDoubleSpin.c
901a902,904
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
912a916,918
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
917d922
< 
965,970c970
<   // XLALSimInspiralGetFinalFreq wants masses in SI units, so unfortunately we need to convert back
<   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
<   double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   double Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi1, 0,0,chi2, SEOBNRv2) * Mtot_sec;
---
>   double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(Mtot_sec, eta, chi1, chi2, SEOBNRv2);
1014c1014,1018
<  * @addtogroup LALSimIMRSEOBNRv2ROMDoubleSpin_c
---
>  * @addtogroup LALSimIMRSEOBNRROM_c
>  *
>  * @{
>  *
>  * @name SEOBNRv2 Reduced Order Model (Double Spin)
1337a1342
> /** @} */
1436,1440c1441
<   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
<   double Mtot_SI = *Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   *Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi1, 0,0,chi2, SEOBNRv2) * (*Mtot_sec);
---
>   *Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(*Mtot_sec, eta, chi1, chi2, SEOBNRv2);
Only in .: LALSimIMRSEOBNRv2ROMDoubleSpinHI.c
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ROMDoubleSpin.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ROMDoubleSpin.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSEOBNRv2ROMEffectiveSpin.c ./LALSimIMRSEOBNRv2ROMEffectiveSpin.c
611a612,614
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
622a626,628
>     if (!freqs) {
>       XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
>     }
673,678c679
<   // XLALSimInspiralGetFinalFreq wants masses in SI units, so unfortunately we need to convert back
<   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
<   double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   double Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi, 0,0,chi, SEOBNRv2) * Mtot_sec;
---
>   double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(Mtot_sec, eta, chi, chi, SEOBNRv2);
723c724,728
<  * @addtogroup LALSimIMRSEOBNRv2ROMEffectiveSpin_c
---
>  * @addtogroup LALSimIMRSEOBNRROM_c
>  *
>  * @{
>  *
>  * @name SEOBNRv2 Reduced Order Model (Effective Spin)
1001a1007
> /** @} */
1075,1079c1081
<   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
<   double Mtot_SI = *Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
<   double m1_SI = Mtot_SI * 1.0/(1.0+q);
<   double m2_SI = Mtot_SI * q/(1.0+q);
<   *Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi, 0,0,chi, SEOBNRv2) * (*Mtot_sec);
---
>   *Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(*Mtot_sec, eta, chi, chi, SEOBNRv2);
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ROMEffectiveSpin.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSEOBNRv2ROMEffectiveSpin.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinAlignedEOB.c ./LALSimIMRSpinAlignedEOB.c
47a48,53
> /* OPTIMIZED */
> #include "LALSimIMRSpinEOBHamiltonianOptimized.c"
> #include "LALSimIMRSpinEOBComputeAmpPhasefromEOMSoln.c"
> #include "LALSimIMRSpinAlignedEOBGSLOptimizedInterpolation.c"
> #include "LALSimIMRSpinAlignedEOBHcapDerivativeOptimized.c"
> /* END OPTIMIZED */
60,63c66,69
< XLALEOBSpinStopCondition(double UNUSED t,
<                            const double values[],
<                            double dvalues[],
<                            void *funcParams
---
> XLALEOBSpinStopCondition(double UNUSED t, /**<< UNUSED */
>                            const double values[], /**<< Dynamical variables */
>                            double dvalues[],  /**<<1st time-derivatives of dynamical variables */
>                            void *funcParams /**<< physical parameters*/
155a162,164
>  * @review SEOBNRv1 has been reviewd by Riccardo Sturani, B. Sathyaprakash and Prayush Kumar.
>  * The review concluded in fall 2012.
>  *
159a169,171
>  * @review SEOBNRv2 has been reviewed by Riccardo Sturani, Prayush Kumar and Stas Babak.
>  * The review concluded with git hash 5bc6bb861de2eb72ca403b9e0f529d83080490fe (August 2014).
>  *
272a285,289
> 
>   INT4 use_optimized_v2=0;
>   /* If we want SEOBNRv2_opt, then reset SpinAlignedEOBversion=2 and set use_optimized_v2=1 */
>   if(SpinAlignedEOBversion==200) { SpinAlignedEOBversion=2; use_optimized_v2=1; }
> 
298c315
<   if ( SpinAlignedEOBversion == 2 && ( spin1z > 0.99 || spin2z > 0.99 )) 
---
>   if ( (SpinAlignedEOBversion == 2) && ( spin1z > 0.99 || spin2z > 0.99 ))
300c317
<     XLALPrintError( "XLAL Error - %s: Component spin larger than 0.99!\nSEOBNRv2 is only available for spins in the range -1 < a/M < 0.99.\n", __func__);
---
>     XLALPrintError( "XLAL Error - %s: Component spin larger than 0.99!\nSEOBNRv2 and SEOBNRv2_opt are only available for spins in the range -1 < a/M < 0.99.\n", __func__);
328a346,349
>   /* OPTIMIZED */
>   REAL8Vector ampVec, phaseVec; ampVec.data=NULL;phaseVec.data=NULL;
>   /* END OPTIMIZED */
> 
378a400
> 
408c430
<         XLALPrintError( "XLAL Error - %s: Mass ratio larger than 100!\nSEOBNRv2 is only available for mass ratios up to 100.\n", __func__);
---
>         XLALPrintError( "XLAL Error - %s: Mass ratio larger than 100!\nSEOBNRv2 and SEOBNRv2_opt are only available for mass ratios up to 100.\n", __func__);
444c466,468
<   if ( !(values = XLALCreateREAL8Vector( 4 )) )
---
>   UINT4 num_elements_in_values_vector=4;
>   if(use_optimized_v2) num_elements_in_values_vector=6;
>   if ( !(values = XLALCreateREAL8Vector( num_elements_in_values_vector )) )
648c672,673
<   if ( XLALSimIMRSpinEOBInitialConditions( tmpValues, m1, m2, fMin, 0, s1Data, s2Data, &seobParams ) == XLAL_FAILURE )
---
> 
>   if ( XLALSimIMRSpinEOBInitialConditions( tmpValues, m1, m2, fMin, 0, s1Data, s2Data, &seobParams, use_optimized_v2 ) == XLAL_FAILURE )
708,711c733,745
<   if (!(integrator = XLALAdaptiveRungeKutta4Init(4, XLALSpinAlignedHcapDerivative, XLALEOBSpinAlignedStopCondition, EPS_ABS, EPS_REL)))
<   {
<     XLALDestroyREAL8Vector( values );
<     XLAL_ERROR( XLAL_EFUNC );
---
>   if(use_optimized_v2)
>     {
>       if (!(integrator = XLALAdaptiveRungeKutta4InitEighthOrderInstead(4, XLALSpinAlignedHcapDerivativeOptimized, XLALEOBSpinAlignedStopCondition, EPS_ABS, EPS_REL)))
>         {
>           XLALDestroyREAL8Vector( values );
>           XLAL_ERROR( XLAL_EFUNC );
>         }
>   } else {
>     if (!(integrator = XLALAdaptiveRungeKutta4Init(4, XLALSpinAlignedHcapDerivative, XLALEOBSpinAlignedStopCondition, EPS_ABS, EPS_REL)))
>       {
>         XLALDestroyREAL8Vector( values );
>         XLAL_ERROR( XLAL_EFUNC );
>       }
717,718c751,761
<   retLen = XLALAdaptiveRungeKutta4( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaT/mTScaled, &dynamics );
<   if ( retLen == XLAL_FAILURE )
---
>   if(use_optimized_v2) {
>     REAL8Array              *dynamicstmp   = NULL;
>     retLen = XLALAdaptiveRungeKutta4NoInterpolate( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaT/mTScaled, &dynamicstmp );
>     GenerateAmpPhaseFromEOMSoln(retLen,dynamicstmp->data,&seobParams);
>     retLen = SEOBNRv2OptimizedInterpolatorIncludeAmpPhase(dynamicstmp, 0., deltaT/mTScaled, retLen, &dynamics);
>     XLALDestroyREAL8Array( dynamicstmp );
>     /* END OPTIMIZED */
>   } else {
>     retLen = XLALAdaptiveRungeKutta4( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaT/mTScaled, &dynamics );
>   }
>   if ( retLen == XLAL_FAILURE || dynamics == NULL )
728a772,776
>   if(use_optimized_v2) {
>     ampVec.length = phaseVec.length = retLen;
>     ampVec.data   = dynamics->data+5*retLen;
>     phaseVec.data = dynamics->data+6*retLen;
>   }
771,772c819,830
<   retLen = XLALAdaptiveRungeKutta4( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaTHigh/mTScaled, &dynamicsHi );
<   if ( retLen == XLAL_FAILURE )
---
>   if(use_optimized_v2) {
>     /* OPTIMIZED: */
>     REAL8Array              *dynamicsHitmp = NULL;
>     retLen = XLALAdaptiveRungeKutta4NoInterpolate( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaTHigh/mTScaled, &dynamicsHitmp );
>     GenerateAmpPhaseFromEOMSoln(retLen,dynamicsHitmp->data,&seobParams);
>     retLen = SEOBNRv2OptimizedInterpolatorIncludeAmpPhase(dynamicsHitmp, 0., deltaTHigh/mTScaled, retLen, &dynamicsHi);
>     XLALDestroyREAL8Array( dynamicsHitmp );
>     /* END OPTIMIZED */
>   } else {
>     retLen = XLALAdaptiveRungeKutta4( integrator, &seobParams, values->data, 0., 20./mTScaled, deltaTHigh/mTScaled, &dynamicsHi );
>   }
>   if ( retLen == XLAL_FAILURE || dynamicsHi == NULL )
821c879,885
<     omega = XLALSimIMRSpinAlignedEOBCalcOmega( values->data, &seobParams );
---
>     if(use_optimized_v2) {
>       /* OPTIMIZED: */
>       omega = XLALSimIMRSpinAlignedEOBCalcOmegaOptimized( values->data, &seobParams );
>       /* END OPTIMIZED: */
>     } else {
>       omega = XLALSimIMRSpinAlignedEOBCalcOmega( values->data, &seobParams );
>     }
831,837c895,900
<     ham = XLALSimIMRSpinEOBHamiltonian( eta, &cartPosVec, &cartMomVec, &s1VecOverMtMt, &s2VecOverMtMt, sigmaKerr, sigmaStar, seobParams.tortoise, &seobCoeffs );
< 
<     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams )
<            == XLAL_FAILURE )
<     {
<       /* TODO: Clean-up */
<       XLAL_ERROR( XLAL_EFUNC );
---
>     if(use_optimized_v2) {
>       /* OPTIMIZED: */
>       ham = XLALSimIMRSpinEOBHamiltonianOptimized( eta, &cartPosVec, &cartMomVec, &s1VecOverMtMt, &s2VecOverMtMt, sigmaKerr, sigmaStar, seobParams.tortoise, &seobCoeffs );
>       /* END OPTIMIZED: */
>     } else {
>       ham = XLALSimIMRSpinEOBHamiltonian( eta, &cartPosVec, &cartMomVec, &s1VecOverMtMt, &s2VecOverMtMt, sigmaKerr, sigmaStar, seobParams.tortoise, &seobCoeffs );
839a903,909
>     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams, use_optimized_v2 )
>          == XLAL_FAILURE )
>       {
>         /* TODO: Clean-up */
>         XLAL_ERROR( XLAL_EFUNC );
>       }
> 
1105,1111c1175,1176
<   /* TODO - Check vectors were allocated */
<   for ( i = 0; i < (INT4)rVec.length; i++ )
<   {
<     values->data[0] = rVec.data[i];
<     values->data[1] = phiVec.data[i] - sSub;
<     values->data[2] = prVec.data[i];
<     values->data[3] = pPhiVec.data[i];
---
>   if(use_optimized_v2) {
>     for ( i = 0; i < (INT4)rVec.length; i++ ){
1113,1114c1178
<     omega = XLALSimIMRSpinAlignedEOBCalcOmega( values->data, &seobParams );
<     v = cbrt( omega );
---
>       hLM = amp0*ampVec.data[i]*cexp(I*(phaseVec.data[i]+2*sSub));
1116,1132c1180,1181
<     /* Calculate the value of the Hamiltonian */
<     cartPosVec.data[0] = values->data[0];
<     cartMomVec.data[0] = values->data[2];
<     cartMomVec.data[1] = values->data[3] / values->data[0];
< 
<     ham = XLALSimIMRSpinEOBHamiltonian( eta, &cartPosVec, &cartMomVec, &s1VecOverMtMt, &s2VecOverMtMt, sigmaKerr, sigmaStar, seobParams.tortoise, &seobCoeffs );
< 
<     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams )
<            == XLAL_FAILURE )
<     {
<       /* TODO: Clean-up */
<       XLAL_ERROR( XLAL_EFUNC );
<     }
< 
<     if ( XLALSimIMREOBNonQCCorrection( &hNQC, values, omega, &nqcCoeffs ) == XLAL_FAILURE )
<     {
<       XLAL_ERROR( XLAL_EFUNC );
---
>       sigReVec->data[i] = creal(hLM);
>       sigImVec->data[i] = cimag(hLM);
1134,1138c1183,1219
< 
<     hLM *= hNQC;
< 
<     sigReVec->data[i] = amp0 * creal(hLM);
<     sigImVec->data[i] = amp0 * cimag(hLM);
---
>   } else {
>     /* TODO - Check vectors were allocated */
>     for ( i = 0; i < (INT4)rVec.length; i++ )
>       {
>         values->data[0] = rVec.data[i];
>         values->data[1] = phiVec.data[i] - sSub;
>         values->data[2] = prVec.data[i];
>         values->data[3] = pPhiVec.data[i];
> 
>         /* Do not need to add an if(use_optimized_v2), since this is strictly unoptimized code (see if(use_optimized_v2) above) */
>         omega = XLALSimIMRSpinAlignedEOBCalcOmega( values->data, &seobParams );
>         v = cbrt( omega );
> 
>         /* Calculate the value of the Hamiltonian */
>         cartPosVec.data[0] = values->data[0];
>         cartMomVec.data[0] = values->data[2];
>         cartMomVec.data[1] = values->data[3] / values->data[0];
> 
>         ham = XLALSimIMRSpinEOBHamiltonian( eta, &cartPosVec, &cartMomVec, &s1VecOverMtMt, &s2VecOverMtMt, sigmaKerr, sigmaStar, seobParams.tortoise, &seobCoeffs );
> 
>         if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams, /* use_optimized_v2 = */ 0 )
>              == XLAL_FAILURE )
>           {
>             /* TODO: Clean-up */
>             XLAL_ERROR( XLAL_EFUNC );
>           }
> 
>         if ( XLALSimIMREOBNonQCCorrection( &hNQC, values, omega, &nqcCoeffs ) == XLAL_FAILURE )
>           {
>             XLAL_ERROR( XLAL_EFUNC );
>           }
> 
>         hLM *= hNQC;
> 
>         sigReVec->data[i] = amp0 * creal(hLM);
>         sigImVec->data[i] = amp0 * cimag(hLM);
>       }
1198a1280
> 
1557c1639
< 							mSpin1, mSpin2, &seobParams ) == XLAL_FAILURE )
---
> 							mSpin1, mSpin2, &seobParams, use_optimized_v2 ) == XLAL_FAILURE )
2121c2203
<     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams )
---
>     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 2, &seobParams, /* use_optimized_v2 = */ 0 )
2133c2215
<     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 1, &seobParams )
---
>     if ( XLALSimIMRSpinEOBGetSpinFactorizedWaveform( &hLM, values, v, ham, 2, 1, &seobParams, /* use_optimized_v2 = */ 0)
2313d2394
< 
Only in .: LALSimIMRSpinAlignedEOBGSLOptimizedInterpolation.c
Only in .: LALSimIMRSpinAlignedEOBHcapDerivativeOptimized.c
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSpinAlignedEOB.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRSpinAlignedEOB.o
Only in .: LALSimIMRSpinEOBAuxFuncsPrec.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinEOB.c ./LALSimIMRSpinEOB.c
333c333
<   if ( XLALSimIMRSpinEOBInitialConditions( values, m1, m2, fMin, inc, mSpin1, mSpin2, &seobParams ) == XLAL_FAILURE )
---
>   if ( XLALSimIMRSpinEOBInitialConditions( values, m1, m2, fMin, inc, mSpin1, mSpin2, &seobParams, 0 ) == XLAL_FAILURE )
Only in .: LALSimIMRSpinEOBComputeAmpPhasefromEOMSoln.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinEOBFactorizedFlux.c ./LALSimIMRSpinEOBFactorizedFlux.c
46c46
< int UsePrec = 0;
---
> static int UsePrec = 0;
180c180
< 
---
>       INT4 use_optimized_v2 = 0;
182c182
<             l, m, ak ) == XLAL_FAILURE )
---
>             l, m, ak, use_optimized_v2, NULL ) == XLAL_FAILURE )
Only in .: LALSimIMRSpinEOBFactorizedFluxOptimized.c
Only in .: LALSimIMRSpinEOBFactorizedFluxPrec.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinEOBFactorizedWaveform.c ./LALSimIMRSpinEOBFactorizedWaveform.c
56a57,60
> /* OPTIMIZED */
> #include "LALSimIMRSpinEOBHamiltonianOptimized.c"
> /* END OPTIMIZED */
> 
65c69
< static INT4 XLALSimIMRSpinEOBGetSpinFactorizedWaveform(
---
> UNUSED static INT4 XLALSimIMRSpinEOBGetSpinFactorizedWaveform(
72c76,77
<                                 SpinEOBParams         * restrict params
---
>                                 SpinEOBParams         * restrict params,
>                                 INT4                  use_optimized_v2/**< Use optimized v2? */
92c97,99
<                                 SpinEOBParams         * restrict params
---
>                                 SpinEOBParams         * restrict params,
>                                 INT4                  use_optimized_v2,/**< Use optimized v2? */
>                                 REAL8                 * vPhil2m2
733c740,742
<                  SpinEOBParams     * restrict params  /**< Spin EOB parameters */
---
>                  SpinEOBParams     * restrict params, /**< Spin EOB parameters */
>                  INT4                use_optimized_v2,/**< Use optimized v2? */
>                  REAL8             * vPhiInput        /**< Reuse vPhi computed outside for efficiency! */
792c801,810
<           vPhi = XLALSimIMRSpinAlignedEOBNonKeplerCoeff( values->data, params );
---
>           if(!use_optimized_v2)
>             {
>               vPhi = XLALSimIMRSpinAlignedEOBNonKeplerCoeff( values->data, params );
>             }
>           else
>             {
>               /* OPTIMIZED */
>               vPhi = *vPhiInput;
>               /* END OPTIMIZED */
>             }
1350a1369
>   /** TODO The term proportional to eta^2 a^2 in coeffs->rho32v2 is wrong, but it was used in the calibration of SEOBNRv2 */
2408a2428
>   /** TODO The term proportional to eta^2 a^2 in coeffs->rho32v2 is wrong, but it was used in the calibration of SEOBNRv2 */
2734c2754,2755
<                  SpinEOBParams     * restrict params  /**< Spin EOB parameters */
---
>                  SpinEOBParams     * restrict params,  /**< Spin EOB parameters */
>                  INT4                use_optimized_v2 /**< Spin EOB parameters */
2804c2825,2831
< 	  vPhi = XLALSimIMRSpinAlignedEOBNonKeplerCoeff( values->data, params );
---
>           if(use_optimized_v2) {
>             /* OPTIMIZED */
>             vPhi = XLALSimIMRSpinAlignedEOBNonKeplerCoeffOptimized( values->data, params );
>             /* END OPTIMIZED */
>           } else {
>             vPhi = XLALSimIMRSpinAlignedEOBNonKeplerCoeff( values->data, params );
>           }
Only in .: LALSimIMRSpinEOBFactorizedWaveformCoefficientsPrec.c
Only in .: LALSimIMRSpinEOBFactorizedWaveformPrec.c
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinEOB.h ./LALSimIMRSpinEOB.h
2a3,4
> #include <gsl/gsl_spline.h>
> #include <math.h>
14a17,18
> 
> 
19a24,25
> 
> 
65a72
>   int      updateHCoeffs;
93a101
>   REAL8                   prev_dr;
95a104
>   int ignoreflux;
119a129,150
> /* We need to encapsulate the data for the GSL derivative function */
> typedef
> struct tagPrecEulerAnglesIntegration
> {
>    gsl_spline *alpha_spline;
>    gsl_spline *beta_spline;
>    gsl_interp_accel *alpha_acc;
>    gsl_interp_accel *beta_acc;
> }
> PrecEulerAnglesIntegration;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
Only in .: LALSimIMRSpinEOBHamiltonianOptimized.c
Only in .: LALSimIMRSpinEOBHamiltonianPrec.c
Only in .: LALSimIMRSpinEOBHcapExactDerivative.c
Only in .: LALSimIMRSpinEOBHcapNumericalDerivativePrec.c
Only in .: LALSimIMRSpinEOBHcapNumericalDerivativePrec.h
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimIMRSpinEOBInitialConditions.c ./LALSimIMRSpinEOBInitialConditions.c
13a14,17
> /* OPTIMIZED */
> #include "LALSimIMRSpinEOBHamiltonianOptimized.c"
> #include "LALSimIMRSpinEOBHcapExactDerivative.c"
> /* END OPTIMIZED */
314c318
<     XLAL_ERROR( XLAL_EFUNC );
---
>     XLAL_ERROR( XLAL_EDOM );
323c327
<     XLAL_ERROR( XLAL_EFUNC );
---
>     XLAL_ERROR( XLAL_EDOM );
331c335
<     XLAL_ERROR( XLAL_EFUNC );
---
>     XLAL_ERROR( XLAL_EDOM );
349a354,414
> /**
>  * Wrapper for calculating specific derivative of the Hamiltonian in spherical co-ordinates,
>  * dH/dr, dH/dptheta and dH/dpphi.
>  * It only works for the specific co-ord system we use here
>  */
> static double GSLSpinHamiltonianDerivWrapperHybrid( double x,    /**<< Derivative at x */
> 						    void  *params /**<< Function parameters */)
> {
> 
>   HcapSphDeriv2Params *dParams = (HcapSphDeriv2Params *) params;
>   REAL8 sphValues[12];
>   REAL8 cartValues[12];
> 
>   REAL8 dHdr, dHdx, dHdpy, dHdpz;
>   REAL8 r, ptheta, pphi;
> 
>   memcpy( sphValues, dParams->sphValues, sizeof( sphValues ) );
>   sphValues[dParams->varyParam1] = x;
> 
>   SphericalToCartesian( cartValues, cartValues+3, sphValues, sphValues+3 );
>   memcpy( cartValues+6, sphValues+6, 6*sizeof(REAL8) );
> 
>   r      = sphValues[0];
>   ptheta = sphValues[4];
>   pphi   = sphValues[5];
> 
>   /* Return the appropriate derivative according to varyParam2 */
> 
>   switch ( dParams->varyParam2 )
>     {
>     case 0:
>       /* dHdr */
>       //CALEBS: Ham Path to Wrapper (next 3 lines)
>       dHdx  = XLALSpinHcapHybDerivWRTParam( 0, cartValues, dParams->params );
>       dHdpy = XLALSpinHcapHybDerivWRTParam( 4, cartValues, dParams->params );
>       dHdpz = XLALSpinHcapHybDerivWRTParam( 5, cartValues, dParams->params );
> 
>       dHdr      = dHdx - dHdpy * pphi / (r*r) + dHdpz * ptheta / (r*r);
>       //printf( "dHdr = %.16e\n", dHdr );
>       return dHdr;
> 
>       break;
>     case 4:
>       /* dHdptheta */
>       //CALEBS: Ham Path to Wrapper
>       dHdpz = XLALSpinHcapHybDerivWRTParam( 5, cartValues, dParams->params );
>       return - dHdpz / r;
>       break;
>     case 5:
>       /* dHdpphi */
>       //CALEBS: Ham Path to Wrapper
>       dHdpy = XLALSpinHcapHybDerivWRTParam( 4, cartValues, dParams->params );
>       return dHdpy / r;
>       break;
>     default:
>       XLALPrintError( "This option is not supported in the second derivative function!\n" );
>       XLAL_ERROR_REAL8( XLAL_EINVAL );
>       break;
>     }
> }
> 
404c469
<       XLAL_ERROR_REAL8( XLAL_EFUNC );
---
>       XLAL_ERROR_REAL8( XLAL_EINVAL );
408a474,507
> static REAL8 XLALCalculateSphHamiltonianDeriv2Hybrid(                 const int      idx1,     /**<< Derivative w.r.t. index 1 */
> 								      const int      idx2,     /**<< Derivative w.r.t. index 2 */
> 								      const REAL8    values[], /**<< Dynamical variables in spherical coordinates */
> 								      SpinEOBParams *params    /**<< Spin EOB Parameters */
> 								      )
> {
>   static const REAL8 STEP_SIZE = 1.0e-5;
> 
>   REAL8 result;
>   REAL8 UNUSED absErr;
> 
>   HcapSphDeriv2Params dParams;
> 
>   gsl_function F;
>   INT4 UNUSED gslStatus;
> 
>   dParams.sphValues  = values;
>   dParams.varyParam1 = idx1;
>   dParams.varyParam2 = idx2;
>   dParams.params     = params;
> 
>   F.function = GSLSpinHamiltonianDerivWrapperHybrid;
>   F.params   = &dParams;
>   XLAL_CALLGSL( gslStatus = gsl_deriv_central( &F, values[idx1],
> 					       STEP_SIZE, &result, &absErr ) );
> 
>   if ( gslStatus != GSL_SUCCESS )
>     {
>       XLALPrintError( "XLAL Error %s - Failure in GSL function\n", __func__ );
>       XLAL_ERROR_REAL8( XLAL_EDOM );
>     }
>   return result;
> }
> 
459c558
<     XLAL_ERROR_REAL8( XLAL_EFUNC );
---
>     XLAL_ERROR_REAL8( XLAL_EDOM );
506c605,606
<                       SpinEOBParams *params     /**<< Spin EOB parameters */
---
>                       SpinEOBParams *params,    /**<< Spin EOB parameters */
>                       INT4 use_optimized_v2     /**<< Use optimized v2? */
744c844
<       XLAL_ERROR( XLAL_EFUNC );
---
>       XLAL_ERROR( XLAL_EDOM );
814c914
< 
---
>  
834,840c934,945
<   d2Hdr2     = XLALCalculateSphHamiltonianDeriv2( 0, 0, sphValues, params );
<   d2Hdrdpphi = XLALCalculateSphHamiltonianDeriv2( 0, 5, sphValues, params );
< 
<   //printf( "d2Hdr2 = %.16e, d2Hdrdpphi = %.16e\n", d2Hdr2, d2Hdrdpphi );
< 
<   dHdpphi  = XLALSpinHcapNumDerivWRTParam( 4, cartValues, params ) / sphValues[0];
<   
---
>   if(use_optimized_v2) {
>     /* TODO: Full, analytic derivatives have not been computed yet for d2Hdr2 or d2Hdrdpphi,
>      *       so we use hybrid version. */
>     d2Hdr2      = XLALCalculateSphHamiltonianDeriv2Hybrid( 0, 0, sphValues, params );
>     d2Hdrdpphi  = XLALCalculateSphHamiltonianDeriv2Hybrid( 0, 5, sphValues, params );
>     /* Full analytical version of dHdpphi. */
>     dHdpphi     = XLALSpinHcapExactDerivWRTParam( 4, cartValues, params ) / sphValues[0];
>   } else {
>     d2Hdr2     = XLALCalculateSphHamiltonianDeriv2( 0, 0, sphValues, params );
>     d2Hdrdpphi = XLALCalculateSphHamiltonianDeriv2( 0, 5, sphValues, params );
>     dHdpphi  = XLALSpinHcapNumDerivWRTParam( 4, cartValues, params ) / sphValues[0];
>   }
875,876c980,984
<     ham = XLALSimIMRSpinEOBHamiltonian( eta, &qCartVec, &pCartVec, &s1VecNorm, &s2VecNorm, &sKerr, &sStar, params->tortoise, params->seobCoeffs );
< 
---
>     if(use_optimized_v2) {
>        ham = XLALSimIMRSpinEOBHamiltonianOptimized( eta, &qCartVec, &pCartVec, &s1VecNorm, &s2VecNorm, &sKerr, &sStar, params->tortoise, params->seobCoeffs );
>     } else {
>        ham = XLALSimIMRSpinEOBHamiltonian( eta, &qCartVec, &pCartVec, &s1VecNorm, &s2VecNorm, &sKerr, &sStar, params->tortoise, params->seobCoeffs );
>     }
898,900c1006,1010
<     dHdpr         = XLALSpinHcapNumDerivWRTParam( 3, cartValues, params );
< 
< 
---
>     if(use_optimized_v2) {
>       dHdpr         = XLALSpinHcapExactDerivWRTParam( 3, cartValues, params );
>     } else {
>       dHdpr         = XLALSpinHcapNumDerivWRTParam( 3, cartValues, params );
>     }
968a1079,1084
>   
>   gsl_matrix_free(rotMatrix2);
>   gsl_matrix_free(invMatrix2);
>   
>   gsl_matrix_free(rotMatrix);
>   gsl_matrix_free(invMatrix);
Only in .: LALSimIMRSpinEOBInitialConditionsPrec.c
Only in .: LALSimIMRSpinPrecEOB.c
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRTNSEOB.c~
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: .LALSimIMRTNSEOB.c.swl
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: .LALSimIMRTNSEOB.c.swn
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: .LALSimIMRTNSEOB.c.swo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: .LALSimIMRTNSEOB.c.swp
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRTNSEOBFactorizedFlux.c~
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRTNSEOBFactorizedWaveform.c~
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRTNSEOB.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimIMRTNSEOB.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-inject
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-inspiral
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiral.c ./LALSimInspiral.c
27a28
> #include <lal/SphericalHarmonics.h>
116d116
<     INITIALIZE_NAME(TNSEOB),
117a118
> 	INITIALIZE_NAME(TNSEOB),
118a120,121
>     INITIALIZE_NAME(EOBNRv2_ROM),
>     INITIALIZE_NAME(EOBNRv2HM_ROM),
120a124
>     INITIALIZE_NAME(SEOBNRv2_opt),
125a130
>     INITIALIZE_NAME(SEOBNRv2_ROM_DoubleSpin_HI),
133a139
>     INITIALIZE_NAME(IMRPhenomPv2),
141a148
>     INITIALIZE_NAME(NR_hdf5),
232c239
< /* 
---
> /*
249a257
>         case IMRPhenomPv2:
256a265,271
> /*
>  * some helper routines for XLALSimInspiralTD
>  */
> static int XLALSimInspiralTDFromTD(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, REAL8 phiRef, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 S1x, REAL8 S1y, REAL8 S1z, REAL8 S2x, REAL8 S2y, REAL8 S2z, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 z, REAL8 i, REAL8 lambda1, REAL8 lambda2, LALSimInspiralWaveformFlags *waveFlags, LALSimInspiralTestGRParam *nonGRparams, int amplitudeO, int phaseO, Approximant approximant);
> static int XLALSimInspiralTDFromFD(REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, REAL8 phiRef, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 S1x, REAL8 S1y, REAL8 S1z, REAL8 S2x, REAL8 S2y, REAL8 S2z, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 z, REAL8 i, REAL8 lambda1, REAL8 lambda2, LALSimInspiralWaveformFlags *waveFlags, LALSimInspiralTestGRParam *nonGRparams, int amplitudeO, int phaseO, Approximant approximant);
> 
> 
303c318,319
<     REAL8 tmp1, tmp2;
---
>     char* numrel_data_path;
>     //REAL8 tmp1, tmp2;
305c321
<     /* N.B. the quadrupole of a spinning compact body labeled by A is 
---
>     /* N.B. the quadrupole of a spinning compact body labeled by A is
357c373
<  
---
> 
451c467
<     		ABORT_NONZERO_TIDES(waveFlags);
---
> 		ABORT_NONZERO_TIDES(waveFlags);
454c470
<         	    deltaT, m1, m2, f_min, f_ref, r, i, (REAL8) XLALSimInspiralGetTestGRParam( nonGRparams, "e_min"), 
---
> 		    deltaT, m1, m2, f_min, f_ref, r, i, (REAL8) XLALSimInspiralGetTestGRParam( nonGRparams, "e_min"),
506,518c522,534
<          
<         case TNSEOB:
<             /* Waveform-specific sanity checks */
<             if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
<                 ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
<             if( !checkSpinsZero(S1x, S1y, S1z, S2x, S2y, S2z) )
<                 ABORT_NONZERO_SPINS(waveFlags);
<             if( f_ref != 0.)
<                 XLALPrintWarning("XLAL Warning - %s: This approximant does use f_ref. The reference phase will be defined at coalescence.\n", __func__);
<             /* Call the waveform driver routine */
<             ret = XLALSimIMRTNSEOBDominantMode(hplus, hcross, phiRef, deltaT,
<                     m1, m2, f_min, r, i,lambda1,lambda2);
<             break;
---
> 
> 		case TNSEOB:
> 		 /* Waveform-specific sanity checks */
> 		 if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
> 		     ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
> 		 if( !checkSpinsZero(S1x, S1y, S1z, S2x, S2y, S2z) )
>              ABORT_NONZERO_SPINS(waveFlags);
> 		 if( f_ref != 0.)
>              XLALPrintWarning("XLAL Warning - %s: This approximant does use f_ref. The reference phase will be defined at coalescence.\n", __func__);
> 		 /* Call the waveform driver routine */
> 		 ret = XLALSimIMRTNSEOBDominantMode(hplus, hcross, phiRef, deltaT,m1, m2, f_min, r, i,lambda1,lambda2);
> 	     break;
> 
535c551
<             /* Maximum PN amplitude order for precessing waveforms is 
---
>             /* Maximum PN amplitude order for precessing waveforms is
537c553
<             amplitudeO = amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ? 
---
>             amplitudeO = amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ?
551,553c567,569
<         // inclination denotes the angle between the view direction 
<         // and J (J is constant during the evolution, J//z, both N and initial 
<         // L are in the x-z plane) and the spin coordinates are given wrt 
---
>         // inclination denotes the angle between the view direction
>         // and J (J is constant during the evolution, J//z, both N and initial
>         // L are in the x-z plane) and the spin coordinates are given wrt
568c584
<             /* Maximum PN amplitude order for precessing waveforms is 
---
>             /* Maximum PN amplitude order for precessing waveforms is
570c586
<             amplitudeO = amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ? 
---
>             amplitudeO = amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ?
624c640,643
< 		ROTATEY(i,S1x,S1y,S1z);
---
> 		spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
> 	        spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
> 	        iTmp=i;
> 	        XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
657c676
< 					       phaseO, amplitudeO, waveFlags, nonGRparams);
---
> 					       phaseO, amplitudeO, lambda1, lambda2, quadparam1, quadparam2, waveFlags, nonGRparams);
676a696,732
> 	case IMRPhenomD:
> 	    if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
> 		    ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
> 	    if( !checkTransverseSpinsZero(S1x, S1y, S2x, S2y) )
> 		    ABORT_NONZERO_TRANSVERSE_SPINS(waveFlags);
> 	    if( !checkTidesZero(lambda1, lambda2) )
> 		    ABORT_NONZERO_TIDES(waveFlags);
> 	    // generate TD waveforms with zero inclincation so that amplitude can be
> 	    // calculated from hplus and hcross, apply inclination-dependent factors
> 	    // in loop below
> 	    ret = XLALSimInspiralTDFromFD(hplus, hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z,
> 			    S2x, S2y, S2z, f_min, f_ref, r, 0, 0, lambda1, lambda2,
> 			    waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
> 	    REAL8 maxamp=0;
> 	    REAL8TimeSeries *hp = *hplus;
> 	    REAL8TimeSeries *hc = *hcross;
> 	    INT4 maxind=hp->data->length - 1;
> 	    INT4 loopi;
> 	    const REAL8 cfac=cos(i);
> 	    const REAL8 pfac = 0.5 * (1. + cfac*cfac);
> 
> 	    for (loopi=hp->data->length - 1; loopi > -1; loopi--)
> 	    {
> 		    REAL8 ampsqr = (hp->data->data[loopi])*(hp->data->data[loopi]) +
> 			   (hc->data->data[loopi])*(hc->data->data[loopi]);
> 		    if (ampsqr > maxamp)
> 		    {
> 			    maxind=loopi;
> 			    maxamp=ampsqr;
> 		    }
> 		    hp->data->data[loopi] *= pfac;
> 		    hc->data->data[loopi] *= cfac;
> 	    }
> 	    XLALGPSSetREAL8(&(hp->epoch), (-1.) * deltaT * maxind);
> 	    XLALGPSSetREAL8(&(hc->epoch), (-1.) * deltaT * maxind);
> 	    break;
> 
686c742
< 							phaseO, amplitudeO,  waveFlags, nonGRparams);
---
> 							phaseO, amplitudeO, lambda1, lambda2, quadparam1, quadparam2, waveFlags, nonGRparams);
717c773
<             ret = XLALSimIMRSpinAlignedEOBWaveform(hplus, hcross, phiRef, 
---
>             ret = XLALSimIMRSpinAlignedEOBWaveform(hplus, hcross, phiRef,
721,722c777,792
< #if 0
<         DISABLE UNTIL SEOBNRV3 IS USABLE
---
>          case SEOBNRv2_opt:
>              /* Waveform-specific sanity checks */
>              if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
>                  ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
>              if( !checkTransverseSpinsZero(S1x, S1y, S2x, S2y) )
>                  ABORT_NONZERO_TRANSVERSE_SPINS(waveFlags);
>              if( !checkTidesZero(lambda1, lambda2) )
>                  ABORT_NONZERO_TIDES(waveFlags);
>              if( f_ref != 0.)
>                  XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
>              /* Call the waveform driver routine */
>              SpinAlignedEOBversion = 200;
>              ret = XLALSimIMRSpinAlignedEOBWaveform(hplus, hcross, phiRef,
>                      deltaT, m1, m2, f_min, r, i, S1z, S2z, SpinAlignedEOBversion);
>              break;
> 
733a804,807
>             iTmp=i;
>            //XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
>             spin1[0] = S1x; spin1[1] = S1y; spin1[2] = S1z;
>             spin2[0] = S2x; spin2[1] = S2y; spin2[2] = S2z;
736,740d809
<             //SpinAlignedEOBversion = 2;
<             //ret = XLALSimIMRSpinAlignedEOBWaveform(hplus, hcross, phiRef,
<             //        deltaT, m1, m2, f_min, r, i, S1z, S2z, SpinAlignedEOBversion);
<             //ret = XLALSimIMRSpinEOBWaveform(hplus, hcross, phiRef,
<             //        deltaT, m1, m2, f_min, r, i, spin1, spin2 );
742d810
< #endif
753a822,833
>         case NR_hdf5:
>             /* Waveform-specific sanity checks */
> 
>             /* Call the waveform driver routine */
>             numrel_data_path = XLALSimInspiralGetNumrelData(waveFlags);
>             ret = XLALSimInspiralNRWaveformGetHplusHcross(hplus, hcross,
>                     phiRef, i, deltaT, m1, m2, r, f_min, f_ref, S1x, S1y, S1z,
>                     S2x, S2y, S2z, numrel_data_path);
>             XLALFree(numrel_data_path);
>             break;
> 
> 
810a891,893
>     /* Variables for IMRPhenomP and IMRPhenomPv2 */
>     REAL8 chi1_l, chi2_l, chip, thetaJ, alpha0;
> 
951c1034
<             /* Maximum PN amplitude order for precessing waveforms is 
---
>             /* Maximum PN amplitude order for precessing waveforms is
953c1036
<             amplitudeO = 0; /* amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ? 
---
>             amplitudeO = 0; /* amplitudeO <= MAX_PRECESSING_AMP_PN_ORDER ?
1075c1158
<             ret = XLALSimIMRPhenomDGenerateFD(hptilde, phiRef, deltaF, m1, m2,
---
>             ret = XLALSimIMRPhenomDGenerateFD(hptilde, phiRef, f_ref, deltaF, m1, m2,
1087a1171,1196
>         case EOBNRv2_ROM:
>             /* Waveform-specific sanity checks */
>             if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
>                 ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
>             if( !checkSpinsZero(S1x, S1y, S1z, S2x, S2y, S2z) )
>                 ABORT_NONZERO_SPINS(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
> 
>             ret = XLALSimIMREOBNRv2HMROM(hptilde, hctilde,
> 		phiRef, deltaF, f_min, f_max, f_ref, r, i, m1, m2, 0);
>             break;
> 
>         case EOBNRv2HM_ROM:
>             /* Waveform-specific sanity checks */
>             if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
>                 ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
>             if( !checkSpinsZero(S1x, S1y, S1z, S2x, S2y, S2z) )
>                 ABORT_NONZERO_SPINS(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
> 
>             ret = XLALSimIMREOBNRv2HMROM(hptilde, hctilde,
> 		phiRef, deltaF, f_min, f_max, f_ref, r, i, m1, m2, 1);
>             break;
> 
1147a1257,1269
>         case SEOBNRv2_ROM_DoubleSpin_HI:
>             /* Waveform-specific sanity checks */
>             if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
>                 ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
>             if( !checkTransverseSpinsZero(S1x, S1y, S2x, S2y) )
>                 ABORT_NONZERO_TRANSVERSE_SPINS(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
> 
>             ret = XLALSimIMRSEOBNRv2ROMDoubleSpinHI(hptilde, hctilde,
>                     phiRef, deltaF, f_min, f_max, f_ref, r, i, m1, m2, S1z, S2z, -1);
>             break;
> 
1151,1154c1273,1306
< 	    spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
< 	    spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
< 	    iTmp=i;
< 	    XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
---
>             spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
>             spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
>             iTmp=i;
>             XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
>             if( !XLALSimInspiralModesChoiceIsDefault(          /* Default is (2,2) or l=2 modes. */
>                     XLALSimInspiralGetModesChoice(waveFlags) ) )
>                 ABORT_NONDEFAULT_MODES_CHOICE(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
>             LNhatx = sin(i);
>             LNhaty = 0.;
>             LNhatz = cos(i);
>             /* Tranform to model parameters */
>             if(f_ref==0.0)
>                 f_ref = f_min; /* Default reference frequency is minimum frequency */
>             XLALSimIMRPhenomPCalculateModelParameters(
>                 &chi1_l, &chi2_l, &chip, &thetaJ, &alpha0,
>                 m1, m2, f_ref,
>                 LNhatx, LNhaty, LNhatz,
>                 S1x, S1y, S1z,
>                 S2x, S2y, S2z, IMRPhenomPv1_V);
>             /* Call the waveform driver routine */
>             ret = XLALSimIMRPhenomP(hptilde, hctilde,
>               chi1_l, chi2_l, chip, thetaJ,
>               m1, m2, r, alpha0, phiRef, deltaF, f_min, f_max, f_ref, IMRPhenomPv1_V);
>             if (ret == XLAL_FAILURE) XLAL_ERROR(XLAL_EFUNC);
>             break;
> 
>         case IMRPhenomPv2:
>             /* Waveform-specific sanity checks */
>             spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
>             spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
>             iTmp=i;
>             XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
1164d1315
<             REAL8 chi_eff, chip, eta, thetaJ, alpha0;
1168c1319
<                 &chi_eff, &chip, &eta, &thetaJ, &alpha0,
---
>                 &chi1_l, &chi2_l, &chip, &thetaJ, &alpha0,
1172c1323
<                 S2x, S2y, S2z);
---
>                 S2x, S2y, S2z, IMRPhenomPv2_V);
1175,1176c1326,1327
<               chi_eff, chip, eta, thetaJ,
<               m1+m2, r, alpha0, phiRef, deltaF, f_min, f_max, f_ref);
---
>               chi1_l, chi2_l, chip, thetaJ,
>               m1, m2, r, alpha0, phiRef, deltaF, f_min, f_max, f_ref, IMRPhenomPv2_V);
1269c1420,1423
<  * resulting waveform is appropriately conditioned and suitable for injection into data.
---
>  * resulting waveform is appropriately conditioned, suitable for injection into data,
>  * and decomposed into the (2, \f$\pm\f$ 2), spin -2 weighted spherical harmonic modes.
>  * NOTE: This is an algebraic decomposition, and will only be correct for approximants
>  * which use only the dominant 2, \f$\pm\f$ 2 mode.
1287c1441
<  * 
---
>  *
1290c1444,1501
< int XLALSimInspiralTD(
---
> SphHarmTimeSeries* XLALSimInspiralTDModesFromPolarizations(
>     REAL8 deltaT,                               /**< sampling interval (s) */
>     REAL8 m1,                                   /**< mass of companion 1 (kg) */
>     REAL8 m2,                                   /**< mass of companion 2 (kg) */
>     REAL8 S1x,                                  /**< x-component of the dimensionless spin of object 1 */
>     REAL8 S1y,                                  /**< y-component of the dimensionless spin of object 1 */
>     REAL8 S1z,                                  /**< z-component of the dimensionless spin of object 1 */
>     REAL8 S2x,                                  /**< x-component of the dimensionless spin of object 2 */
>     REAL8 S2y,                                  /**< y-component of the dimensionless spin of object 2 */
>     REAL8 S2z,                                  /**< z-component of the dimensionless spin of object 2 */
>     REAL8 f_min,                                /**< starting GW frequency (Hz) */
>     REAL8 f_ref,                                /**< reference GW frequency (Hz) */
>     REAL8 r,                                    /**< distance of source (m) */
>     REAL8 z,                                    /**< redshift of source frame relative to observer frame */
>     REAL8 lambda1,                              /**< (tidal deformability of mass 1) / m1^5 (dimensionless) */
>     REAL8 lambda2,                              /**< (tidal deformability of mass 2) / m2^5 (dimensionless) */
>     LALSimInspiralWaveformFlags *waveFlags,     /**< Set of flags to control special behavior of some waveform families. Pass in NULL (or None in python) for default flags */
>     LALSimInspiralTestGRParam *nonGRparams, 	/**< Linked list of non-GR parameters. Pass in NULL (or None in python) for standard GR waveforms */
>     int amplitudeO,                             /**< twice post-Newtonian amplitude order */
>     int phaseO,                                 /**< twice post-Newtonian order */
>     Approximant approximant                     /**< post-Newtonian approximant to use for waveform production */
>     )
> {
>     REAL8TimeSeries *hplus, *hcross;
>     COMPLEX16TimeSeries *h22,*h2m2;
>     SphHarmTimeSeries *hlm;
>     UINT4 j;
>     int retval;
>     float fac = XLALSpinWeightedSphericalHarmonic(0., 0., -2, 2,2);
> 
>     /* Generate waveform via on-axis emission. Assumes only (2,2) and (2,-2) emission */
>     retval = XLALSimInspiralTD(&hplus, &hcross, 0.0, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, f_ref, r, z, 0.0, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
>     if (retval < 0)
>         XLAL_ERROR_NULL(XLAL_EFUNC);
> 
>     /* Step 1: Create COMPLEX16 TimeSeries and populate them */
>     h22 = XLALCreateCOMPLEX16TimeSeries("h22", &(hplus)->epoch, 0, deltaT, &lalStrainUnit, (hplus)->data->length);
>     h2m2 = XLALCreateCOMPLEX16TimeSeries("h2m2", &(hplus)->epoch, 0, deltaT, &lalStrainUnit, (hplus)->data->length);
>     for (j=0; j< (hplus)->data->length; j++) {
>       h22->data->data[j] = ((hplus)->data->data[j] - I*((hcross)->data->data[j]))/fac;
>       h2m2->data->data[j] = ((hplus)->data->data[j] + I*((hcross)->data->data[j]))/fac;
>     }
> 
>     /* Step 2: Add them into the data */
>     hlm = XLALSphHarmTimeSeriesAddMode(NULL, h22, 2, 2);
>     hlm = XLALSphHarmTimeSeriesAddMode(hlm, h2m2, 2, -2);
> 
>     /* Step 3: Clean up */
>     XLALDestroyREAL8TimeSeries(hplus);
>     XLALDestroyREAL8TimeSeries(hcross);
>     XLALDestroyCOMPLEX16TimeSeries(h22);
>     XLALDestroyCOMPLEX16TimeSeries(h2m2);
> 
>     return hlm;
> }
> 
> /** Helper routines for XLALSimInspiralTD(): performs conditioning of a TD waveform */
> static int XLALSimInspiralTDFromTD(
1315c1526
<     )
---
> )
1324a1536,1538
>     if (!XLALSimInspiralImplementedTDApproximants(approximant))
>         XLAL_ERROR(XLAL_EINVAL, "Invalid approximant: not a TD approximant");
> 
1359c1573,1582
<     /* decide if this is a TD or an FD approximant */
---
>     /* time domain approximant: condition by generating a waveform
>      * with a lower starting frequency and apply tapers in the
>      * region between that lower frequency and the requested
>      * frequency f_min; here compute a new lower frequency */
>     fstart = XLALSimInspiralChirpStartFrequencyBound((1.0 + extra_time_fraction) * tchirp + tmerge + textra, m1, m2);
> 
>     /* generate the waveform in the time domain starting at fstart */
>     retval = XLALSimInspiralChooseTDWaveform(hplus, hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, fstart, f_ref, r, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
>     if (retval < 0)
>         XLAL_ERROR(XLAL_EFUNC);
1361c1584,1586
<     if (XLALSimInspiralImplementedTDApproximants(approximant)) {
---
>     /* condition the time domain waveform by tapering in the extra time
>      * at the beginning and high-pass filtering above original f_min */
>     XLALSimInspiralTDConditionStage1(*hplus, *hcross, extra_time_fraction * tchirp + textra, original_f_min);
1363,1372c1588
<         /* time domain approximant: condition by generating a waveform
<          * with a lower starting frequency and apply tapers in the
<          * region between that lower frequency and the requested
<          * frequency f_min; here compute a new lower frequency */
<         fstart = XLALSimInspiralChirpStartFrequencyBound((1.0 + extra_time_fraction) * tchirp + tmerge + textra, m1, m2);
<     
<         /* generate the waveform in the time domain starting at fstart */
<         retval = XLALSimInspiralChooseTDWaveform(hplus, hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, fstart, f_ref, r, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
<         if (retval < 0)
<             XLAL_ERROR(XLAL_EFUNC);
---
>     /* final tapering at the beginning and at the end to remove filter transients */
1374,1376c1590,1594
<         /* condition the time domain waveform by tapering in the extra time
<          * at the beginning and high-pass filtering above original f_min */
<         XLALSimInspiralTDConditionStage1(*hplus, *hcross, extra_time_fraction * tchirp + textra, original_f_min);
---
>     /* waveform should terminate at a frequency >= Schwarzschild ISCO
>      * so taper one cycle at this frequency at the end; should not make
>      * any difference to IMR waveforms */
>     fisco = 1.0 / (pow(6.0, 1.5) * LAL_PI * (m1 + m2) * LAL_MTSUN_SI / LAL_MSUN_SI);
>     XLALSimInspiralTDConditionStage2(*hplus, *hcross, f_min, fisco);
1378c1596,1597
<         /* remaining conditioning is the same as with the frequency domain case */
---
>     return 0;
> }
1380c1599,1638
<     } else if (XLALSimInspiralImplementedFDApproximants(approximant)) {
---
> /** Helper routines for XLALSimInspiralTD(): performs conditioning of a FD waveform and transforms it to TD */
> static int XLALSimInspiralTDFromFD(
>     REAL8TimeSeries **hplus,                    /**< +-polarization waveform */
>     REAL8TimeSeries **hcross,                   /**< x-polarization waveform */
>     REAL8 phiRef,                               /**< reference orbital phase (rad) */
>     REAL8 deltaT,                               /**< sampling interval (s) */
>     REAL8 m1,                                   /**< mass of companion 1 (kg) */
>     REAL8 m2,                                   /**< mass of companion 2 (kg) */
>     REAL8 S1x,                                  /**< x-component of the dimensionless spin of object 1 */
>     REAL8 S1y,                                  /**< y-component of the dimensionless spin of object 1 */
>     REAL8 S1z,                                  /**< z-component of the dimensionless spin of object 1 */
>     REAL8 S2x,                                  /**< x-component of the dimensionless spin of object 2 */
>     REAL8 S2y,                                  /**< y-component of the dimensionless spin of object 2 */
>     REAL8 S2z,                                  /**< z-component of the dimensionless spin of object 2 */
>     REAL8 f_min,                                /**< starting GW frequency (Hz) */
>     REAL8 f_ref,                                /**< reference GW frequency (Hz) */
>     REAL8 r,                                    /**< distance of source (m) */
>     REAL8 z,                                    /**< redshift of source frame relative to observer frame */
>     REAL8 i,                                    /**< inclination of source (rad) */
>     REAL8 lambda1,                              /**< (tidal deformability of mass 1) / m1^5 (dimensionless) */
>     REAL8 lambda2,                              /**< (tidal deformability of mass 2) / m2^5 (dimensionless) */
>     LALSimInspiralWaveformFlags *waveFlags,     /**< Set of flags to control special behavior of some waveform families. Pass in NULL (or None in python) for default flags */
>     LALSimInspiralTestGRParam *nonGRparams, 	/**< Linked list of non-GR parameters. Pass in NULL (or None in python) for standard GR waveforms */
>     int amplitudeO,                             /**< twice post-Newtonian amplitude order */
>     int phaseO,                                 /**< twice post-Newtonian order */
>     Approximant approximant                     /**< post-Newtonian approximant to use for waveform production */
> )
> {
>     COMPLEX16FrequencySeries *hptilde = NULL;
>     COMPLEX16FrequencySeries *hctilde = NULL;
>     REAL8FFTPlan *plan;
>     size_t chirplen, end, k;
>     double tshift;
>     const double extra_time_fraction = 0.1; /* fraction of waveform duration to add as extra time for tapering */
>     const double extra_cycles = 3.0; /* more extra time measured in cycles at the starting frequency */
>     double original_f_min = f_min; /* f_min might be overwritten below, so keep original value */
>     double tchirp, tmerge, textra;
>     double fisco, fstart;
>     double s;
>     int retval;
1382,1383c1640,1641
<         /* create a conditioned frequency-domain waveform and transform
<          * it into the time-domain */
---
>     if (!XLALSimInspiralImplementedFDApproximants(approximant))
>         XLAL_ERROR(XLAL_EINVAL, "Invalid approximant: not a FD approximant");
1385,1389c1643,1646
<         COMPLEX16FrequencySeries *hptilde = NULL;
<         COMPLEX16FrequencySeries *hctilde = NULL;
<         REAL8FFTPlan *plan;
<         size_t chirplen, end, k;
<         double tshift;
---
>     /* adjust the reference frequency for certain precessing approximants:
>      * if that approximate interprets f_ref==0 to be f_min, set f_ref=f_min;
>      * otherwise do nothing */
>     f_ref = fixReferenceFrequency(f_ref, f_min, approximant);
1391,1396c1648,1655
<         /* generate the conditioned waveform in the frequency domain */
<         /* note: redshift factor has already been applied above */
<         /* set deltaF = 0 to get a small enough resolution */
<         retval = XLALSimInspiralFD(&hptilde, &hctilde, phiRef, 0.0, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, 0.5/deltaT, f_ref, r, 0.0, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
<         if (retval < 0)
<             XLAL_ERROR(XLAL_EFUNC);
---
>     /* apply redshift correction to dimensionful source-frame quantities */
>     if (z != 0.0) {
>         m1 *= (1.0 + z);
>         m2 *= (1.0 + z);
>         r *= (1.0 + z);  /* change from comoving (transverse) distance to luminosity distance */
>     }
>     /* set redshift to zero so we don't accidentally apply it again later */
>     z = 0.0;
1398,1411c1657,1661
<         /* we want to make sure that this waveform will give something
<          * sensible if it is later transformed into the time domain:
<          * to avoid the end of the waveform wrapping around to the beginning,
<          * we shift waveform backwards in time and compensate for this
<          * shift by adjusting the epoch -- note that XLALSimInspiralFD
<          * guarantees that there is extra padding to do this */
<         tshift = round(textra / deltaT) * deltaT; /* integer number of samples */
<         for (k = 0; k < hptilde->data->length; ++k) {
<             double complex phasefac = cexp(2.0 * M_PI * I * k * hptilde->deltaF * tshift);
<             hptilde->data->data[k] *= phasefac;
<             hctilde->data->data[k] *= phasefac;
<         }
<         XLALGPSAdd(&hptilde->epoch, tshift);
<         XLALGPSAdd(&hctilde->epoch, tshift);
---
>     /* if the requested low frequency is below the lowest Kerr ISCO
>      * frequency then change it to that frequency */
>     fisco = 1.0 / (pow(9.0, 1.5) * LAL_PI * (m1 + m2) * LAL_MTSUN_SI / LAL_MSUN_SI);
>     if (f_min > fisco)
>         f_min = fisco;
1413,1427c1663,1664
<         /* transform the waveform into the time domain */
<         chirplen = 2 * (hptilde->data->length - 1);
<         *hplus = XLALCreateREAL8TimeSeries("H_PLUS", &hptilde->epoch, 0.0, deltaT, &lalStrainUnit, chirplen);
<         *hcross = XLALCreateREAL8TimeSeries("H_CROSS", &hctilde->epoch, 0.0, deltaT, &lalStrainUnit, chirplen);
<         plan = XLALCreateReverseREAL8FFTPlan(chirplen, 0);
<         if (!(*hplus) || !(*hcross) || !plan) {
<             XLALDestroyCOMPLEX16FrequencySeries(hptilde);
<             XLALDestroyCOMPLEX16FrequencySeries(hctilde);
<             XLALDestroyREAL8TimeSeries(*hcross);
<             XLALDestroyREAL8TimeSeries(*hplus);
<             XLALDestroyREAL8FFTPlan(plan);
<             XLAL_ERROR(XLAL_EFUNC);
<         }
<         XLALREAL8FreqTimeFFT(*hplus, hptilde, plan);
<         XLALREAL8FreqTimeFFT(*hcross, hctilde, plan);
---
>     /* upper bound on the chirp time starting at f_min */
>     tchirp = XLALSimInspiralChirpTimeBound(f_min, m1, m2, S1z, S2z);
1429,1431c1666,1667
<         /* apply time domain filter at original f_min */
<         XLALHighPassREAL8TimeSeries(*hplus, original_f_min, 0.99, 8);
<         XLALHighPassREAL8TimeSeries(*hcross, original_f_min, 0.99, 8);
---
>     /* upper bound on the final black hole spin */
>     s = XLALSimInspiralFinalBlackHoleSpinBound(S1z, S2z);
1433,1446c1669,1670
<         /* compute how long a chirp we should have */
<         /* revised estimate of chirp length from new start frequency */
<         fstart = XLALSimInspiralChirpStartFrequencyBound((1.0 + extra_time_fraction) * tchirp, m1, m2);
<         tchirp = XLALSimInspiralChirpTimeBound(fstart, m1, m2, S1z, S2z);
<         
<         /* total expected chirp length includes merger */
<         chirplen = round((tchirp + tmerge) / deltaT);
< 
<         /* amount to snip off at the end is tshift */
<         end = (*hplus)->data->length - round(tshift / deltaT);
< 
<         /* snip off extra time at beginning and at the end */
<         XLALResizeREAL8TimeSeries(*hplus, end - chirplen, chirplen);
<         XLALResizeREAL8TimeSeries(*hcross, end - chirplen, chirplen);
---
>     /* upper bound on the final plunge, merger, and ringdown time */
>     tmerge = XLALSimInspiralMergeTimeBound(m1, m2) + XLALSimInspiralRingdownTimeBound(m1 + m2, s);
1448,1449c1672,1704
<         /* clean up */
<         XLALDestroyREAL8FFTPlan(plan);
---
>     /* extra time to include for all waveforms to take care of situations
>      * where the frequency is close to merger (and is sweeping rapidly):
>      * this is a few cycles at the low frequency */
>     textra = extra_cycles / f_min;
> 
>     /* generate the conditioned waveform in the frequency domain */
>     /* note: redshift factor has already been applied above */
>     /* set deltaF = 0 to get a small enough resolution */
>     retval = XLALSimInspiralFD(&hptilde, &hctilde, phiRef, 0.0, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, 0.5/deltaT, f_ref, r, 0.0, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
>     if (retval < 0)
>         XLAL_ERROR(XLAL_EFUNC);
> 
>     /* we want to make sure that this waveform will give something
>      * sensible if it is later transformed into the time domain:
>      * to avoid the end of the waveform wrapping around to the beginning,
>      * we shift waveform backwards in time and compensate for this
>      * shift by adjusting the epoch -- note that XLALSimInspiralFD
>      * guarantees that there is extra padding to do this */
>     tshift = round(textra / deltaT) * deltaT; /* integer number of samples */
>     for (k = 0; k < hptilde->data->length; ++k) {
>         double complex phasefac = cexp(2.0 * M_PI * I * k * hptilde->deltaF * tshift);
>         hptilde->data->data[k] *= phasefac;
>         hctilde->data->data[k] *= phasefac;
>     }
>     XLALGPSAdd(&hptilde->epoch, tshift);
>     XLALGPSAdd(&hctilde->epoch, tshift);
> 
>     /* transform the waveform into the time domain */
>     chirplen = 2 * (hptilde->data->length - 1);
>     *hplus = XLALCreateREAL8TimeSeries("H_PLUS", &hptilde->epoch, 0.0, deltaT, &lalStrainUnit, chirplen);
>     *hcross = XLALCreateREAL8TimeSeries("H_CROSS", &hctilde->epoch, 0.0, deltaT, &lalStrainUnit, chirplen);
>     plan = XLALCreateReverseREAL8FFTPlan(chirplen, 0);
>     if (!(*hplus) || !(*hcross) || !plan) {
1451a1707,1713
>         XLALDestroyREAL8TimeSeries(*hcross);
>         XLALDestroyREAL8TimeSeries(*hplus);
>         XLALDestroyREAL8FFTPlan(plan);
>         XLAL_ERROR(XLAL_EFUNC);
>     }
>     XLALREAL8FreqTimeFFT(*hplus, hptilde, plan);
>     XLALREAL8FreqTimeFFT(*hcross, hctilde, plan);
1453,1456c1715,1737
<         /* remaining conditioning is the same as with the time domain case */
< 
<     } else
<         XLAL_ERROR(XLAL_EINVAL, "Invalid approximant");
---
>     /* apply time domain filter at original f_min */
>     XLALHighPassREAL8TimeSeries(*hplus, original_f_min, 0.99, 8);
>     XLALHighPassREAL8TimeSeries(*hcross, original_f_min, 0.99, 8);
> 
>     /* compute how long a chirp we should have */
>     /* revised estimate of chirp length from new start frequency */
>     fstart = XLALSimInspiralChirpStartFrequencyBound((1.0 + extra_time_fraction) * tchirp, m1, m2);
>     tchirp = XLALSimInspiralChirpTimeBound(fstart, m1, m2, S1z, S2z);
> 
>     /* total expected chirp length includes merger */
>     chirplen = round((tchirp + tmerge) / deltaT);
> 
>     /* amount to snip off at the end is tshift */
>     end = (*hplus)->data->length - round(tshift / deltaT);
> 
>     /* snip off extra time at beginning and at the end */
>     XLALResizeREAL8TimeSeries(*hplus, end - chirplen, chirplen);
>     XLALResizeREAL8TimeSeries(*hcross, end - chirplen, chirplen);
> 
>     /* clean up */
>     XLALDestroyREAL8FFTPlan(plan);
>     XLALDestroyCOMPLEX16FrequencySeries(hptilde);
>     XLALDestroyCOMPLEX16FrequencySeries(hctilde);
1469a1751,1812
>  * @brief Generates an time domain inspiral waveform using the specified approximant; the
>  * resulting waveform is appropriately conditioned and suitable for injection into data.
>  *
>  * For spinning waveforms, all known spin effects up to given PN order are included
>  *
>  * This routine can generate FD approximants and transform them into the time domain.
>  * Waveforms are generated beginning at a slightly lower starting frequency and tapers
>  * are put in this early region so that the waveform smoothly turns on.  Artifacts at
>  * the very end of the waveform are also tapered.  The resulting waveform is high-pass
>  * filtered at frequency f_min so that it should have little content at lower frequencies.
>  *
>  * This routine has one additional parameter relative to XLALSimInspiralChooseTDWaveform.
>  * The additional parameter is the redshift, z, of the waveform.  This should be set to
>  * zero for sources in the nearby universe (that are nearly at rest relative to the
>  * earth).  For sources at cosmological distances, the mass parameters m1 and m2 should
>  * be interpreted as the physical (source frame) masses of the bodies and the distance
>  * parameter r is the comoving (transverse) distance.  If the calling routine has already
>  * applied cosmological "corrections" to m1 and m2 and regards r as a luminosity distance
>  * then the redshift factor should again be set to zero.
>  *
>  * @note The parameters passed must be in SI units.
>  */
> int XLALSimInspiralTD(
>     REAL8TimeSeries **hplus,                    /**< +-polarization waveform */
>     REAL8TimeSeries **hcross,                   /**< x-polarization waveform */
>     REAL8 phiRef,                               /**< reference orbital phase (rad) */
>     REAL8 deltaT,                               /**< sampling interval (s) */
>     REAL8 m1,                                   /**< mass of companion 1 (kg) */
>     REAL8 m2,                                   /**< mass of companion 2 (kg) */
>     REAL8 S1x,                                  /**< x-component of the dimensionless spin of object 1 */
>     REAL8 S1y,                                  /**< y-component of the dimensionless spin of object 1 */
>     REAL8 S1z,                                  /**< z-component of the dimensionless spin of object 1 */
>     REAL8 S2x,                                  /**< x-component of the dimensionless spin of object 2 */
>     REAL8 S2y,                                  /**< y-component of the dimensionless spin of object 2 */
>     REAL8 S2z,                                  /**< z-component of the dimensionless spin of object 2 */
>     REAL8 f_min,                                /**< starting GW frequency (Hz) */
>     REAL8 f_ref,                                /**< reference GW frequency (Hz) */
>     REAL8 r,                                    /**< distance of source (m) */
>     REAL8 z,                                    /**< redshift of source frame relative to observer frame */
>     REAL8 i,                                    /**< inclination of source (rad) */
>     REAL8 lambda1,                              /**< (tidal deformability of mass 1) / m1^5 (dimensionless) */
>     REAL8 lambda2,                              /**< (tidal deformability of mass 2) / m2^5 (dimensionless) */
>     LALSimInspiralWaveformFlags *waveFlags,     /**< Set of flags to control special behavior of some waveform families. Pass in NULL (or None in python) for default flags */
>     LALSimInspiralTestGRParam *nonGRparams, 	/**< Linked list of non-GR parameters. Pass in NULL (or None in python) for standard GR waveforms */
>     int amplitudeO,                             /**< twice post-Newtonian amplitude order */
>     int phaseO,                                 /**< twice post-Newtonian order */
>     Approximant approximant                     /**< post-Newtonian approximant to use for waveform production */
>     )
> {
>     /* call the appropriate helper routine */
>     if (XLALSimInspiralImplementedTDApproximants(approximant)) {
>         if (XLALSimInspiralTDFromTD(hplus, hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, f_ref, r, z, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant) < 0)
>             XLAL_ERROR(XLAL_EFUNC);
>     } else if (XLALSimInspiralImplementedFDApproximants(approximant)) {
>         if (XLALSimInspiralTDFromFD(hplus, hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, f_ref, r, z, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant) < 0)
>             XLAL_ERROR(XLAL_EFUNC);
>     } else
>         XLAL_ERROR(XLAL_EINVAL, "Invalid approximant");
>     return 0;
> }
> 
> /**
1502c1845
<  * 
---
>  *
1574c1917
<     
---
> 
1621c1964
<         
---
> 
1764c2107
<  * @name General Waveform Switching Mode Generation Routines 
---
>  * @name General Waveform Switching Mode Generation Routines
1882a2226
> 		case TNSEOB:
1912d2255
<         case TNSEOB:
2026c2369
<     
---
> 
2096c2439
<     SphHarmTimeSeries UNUSED *ts;
---
>     SphHarmTimeSeries *ts;
2181a2525
> 		case TNSEOB:
2183,2186c2527,2529
<         case TNSEOB:
<           //  ts = XLALSimIMREOBNRv2Modes(phiRef, deltaT, m1, m2, f_min, r);
<           //  hlm = XLALSphHarmTimeSeriesGetMode(ts, l, m);
<           //  break;
---
>             ts = XLALSimIMREOBNRv2Modes(phiRef, deltaT, m1, m2, f_min, r);
>             hlm = XLALSphHarmTimeSeriesGetMode(ts, l, m);
>             break;
2245c2588
<     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch, 0.0, 
---
>     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch, 0.0,
2247c2590
<     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch, 0.0, 
---
>     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch, 0.0,
2251c2594
<     memset((*hplus)->data->data, 0, (*hplus)->data->length 
---
>     memset((*hplus)->data->data, 0, (*hplus)->data->length
2253c2596
<     memset((*hcross)->data->data, 0, (*hcross)->data->length 
---
>     memset((*hcross)->data->data, 0, (*hcross)->data->length
2263,2265c2606,2608
<     
<     /* 
<      * cosines and sines of inclination between 
---
> 
>     /*
>      * cosines and sines of inclination between
2277c2620
<         phi = Phi->data->data[idx]; 	v = V->data->data[idx];   
---
>         phi = Phi->data->data[idx]; 	v = V->data->data[idx];
2280,2282c2623,2625
<         /* 
<          * As explained in Blanchet et al, a phase shift can be applied 
<          * to make log terms vanish which would appear in the amplitude 
---
>         /*
>          * As explained in Blanchet et al, a phase shift can be applied
>          * to make log terms vanish which would appear in the amplitude
2318c2661
<                         * (-465497./11025. + (LAL_GAMMA*856./105. 
---
>                         * (-465497./11025. + (LAL_GAMMA*856./105.
2330c2673
<                         * (-2189./210. + ci2*1123./210. + ci4*56./9. 
---
>                         * (-2189./210. + ci2*1123./210. + ci4*56./9.
2337c2680
<                         * (1377./80. + ci2*891./80. - ci4*729./280. 
---
>                         * (1377./80. + ci2*891./80. - ci4*729./280.
2340,2341c2683,2684
<                         + eta3*(-729./16. - ci2*243./80. + ci4*729./40.)) 
<                         + cos(8.*phi)*(-1024./315.*si6*(1. + ci2)*(1. - 7.*eta 
---
>                         + eta3*(-729./16. - ci2*243./80. + ci4*729./40.))
>                         + cos(8.*phi)*(-1024./315.*si6*(1. + ci2)*(1. - 7.*eta
2348c2691
<                         * (205119./8960. - log(3./2.)*1971./64. 
---
>                         * (205119./8960. - log(3./2.)*1971./64.
2351,2355c2694,2698
<                         * (-54869./960. + log(3./2.)*567./32. 
<                         + (-923./80. - log(3./2.)*81./8.)*ci2 
<                         + (41851./2880. - log(3./2.)*243./32.)*ci4)) 
<                         + dm*si3*(1. + ci2)*sin(5.*phi)*(-113125./5376. 
<                         + log(5./2.)*3125./192. 
---
>                         * (-54869./960. + log(3./2.)*567./32.
>                         + (-923./80. - log(3./2.)*81./8.)*ci2
>                         + (41851./2880. - log(3./2.)*243./32.)*ci4))
>                         + dm*si3*(1. + ci2)*sin(5.*phi)*(-113125./5376.
>                         + log(5./2.)*3125./192.
2358c2701
<                         + (-251./2240. - log(2.)*5./48.)*ci2 
---
>                         + (-251./2240. - log(2.)*5./48.)*ci2
2363,2367c2706,2710
<                         + (65097./4480. - log(3./2.)*405./32.)*ci2 
<                         + eta*(28445./288. - log(3./2.)*405./16. 
<                         + (-7137./160. + log(3./2.)*405./16.)*ci2)) 
<                         + dm*si3*ci*cos(5.*phi)*(113125./2688. 
<                         - log(5./2.)*3125./96. + eta*(-17639./160. 
---
>                         + (65097./4480. - log(3./2.)*405./32.)*ci2
>                         + eta*(28445./288. - log(3./2.)*405./16.
>                         + (-7137./160. + log(3./2.)*405./16.)*ci2))
>                         + dm*si3*ci*cos(5.*phi)*(113125./2688.
>                         - log(5./2.)*3125./96. + eta*(-17639./160.
2370c2713
<                         + ci*sin(2.*phi)*(-3620761./44100. 
---
>                         + ci*sin(2.*phi)*(-3620761./44100.
2372,2374c2715,2717
<                         + log(16.*v2)*856./105. - ci2*3413./1260. 
<                         + ci4*2909./2520. - ci6/45. + eta*(743./90. 
<                         - 41.*LAL_PI*LAL_PI/48. + ci2*3391./180. 
---
>                         + log(16.*v2)*856./105. - ci2*3413./1260.
>                         + ci4*2909./2520. - ci6/45. + eta*(743./90.
>                         - 41.*LAL_PI*LAL_PI/48. + ci2*3391./180.
2376c2719
<                         - ci2*5426./135. + ci4*382./45. - ci6*14./45.) 
---
>                         - ci2*5426./135. + ci4*382./45. - ci6*14./45.)
2379c2722
<                         * (-1809./64. + ci2*405./64. + eta*(405./32. 
---
>                         * (-1809./64. + ci2*405./64. + eta*(405./32.
2381c2724
<                         + ci2*1208./63. - ci4*64./45. + eta*(5207./45. 
---
>                         + ci2*1208./63. - ci4*64./45. + eta*(5207./45.
2385,2387c2728,2730
<                         * (3125.*LAL_PI/192.*si3*ci*(1. - 2.*eta)) 
<                         + si4*ci*sin(6.*phi)*(9153./280. - ci2*243./35. 
<                         + eta*(-7371./40. + ci2*243./5.) + eta2*(1296./5. 
---
>                         * (3125.*LAL_PI/192.*si3*ci*(1. - 2.*eta))
>                         + si4*ci*sin(6.*phi)*(9153./280. - ci2*243./35.
>                         + eta*(-7371./40. + ci2*243./5.) + eta2*(1296./5.
2389c2732
<                         + sin(8.*phi)*(-2048./315.*si6*ci*(1. - 7.*eta 
---
>                         + sin(8.*phi)*(-2048./315.*si6*ci*(1. - 7.*eta
2393,2394c2736,2737
<                 hp25 = cos(phi)*si*dm*(1771./5120. - ci2*1667./5120. 
<                         + ci4*217./9216. - ci6/9126. + eta*(681./256. 
---
>                 hp25 = cos(phi)*si*dm*(1771./5120. - ci2*1667./5120.
>                         + ci4*217./9216. - ci6/9126. + eta*(681./256.
2397c2740
<                         - ci6/3072.)) + cos(2.*phi)*LAL_PI*(19./3. + 3.*ci2 
---
>                         - ci6/3072.)) + cos(2.*phi)*LAL_PI*(19./3. + 3.*ci2
2399,2403c2742,2746
<                         + cos(3.*phi)*si*dm*(3537./1024. - ci2*22977./5120. 
<                         - ci4*15309./5120. + ci6*729./5120. 
<                         + eta*(-23829./1280. + ci2*5529./1280. 
<                         + ci4*7749./1280. - ci6*729./1280.) 
<                         + eta2*(29127./5120. - ci2*27267./5120. 
---
>                         + cos(3.*phi)*si*dm*(3537./1024. - ci2*22977./5120.
>                         - ci4*15309./5120. + ci6*729./5120.
>                         + eta*(-23829./1280. + ci2*5529./1280.
>                         + ci4*7749./1280. - ci6*729./1280.)
>                         + eta2*(29127./5120. - ci2*27267./5120.
2406,2407c2749,2750
<                         + cos(5.*phi)*si*dm*(-108125./9216. + ci2*40625./9216. 
<                         + ci4*83125./9216. - ci6*15625./9216. 
---
>                         + cos(5.*phi)*si*dm*(-108125./9216. + ci2*40625./9216.
>                         + ci4*83125./9216. - ci6*15625./9216.
2409,2410c2752,2753
<                         + ci6*15625./2304.) + eta2*(-119375./9216. 
<                         + ci2*40625./3072. + ci4*44375./9216. 
---
>                         + ci6*15625./2304.) + eta2*(-119375./9216.
>                         + ci2*40625./3072. + ci4*44375./9216.
2412,2415c2755,2758
<                         * (117649./46080.*si5*(1. + ci2)*(1. - 4.*eta 
<                         + 3.*eta2)) + sin(2.*phi)*(-9./5. + ci2*14./5. 
<                         + ci4*7./5. + eta*(32. + ci2*56./5. - ci4*28./5.)) 
<                         + sin(4.*phi)*si2*(1. + ci2)*(56./5. - 32.*log(2.)/3. 
---
>                         * (117649./46080.*si5*(1. + ci2)*(1. - 4.*eta
>                         + 3.*eta2)) + sin(2.*phi)*(-9./5. + ci2*14./5.
>                         + ci4*7./5. + eta*(32. + ci2*56./5. - ci4*28./5.))
>                         + sin(4.*phi)*si2*(1. + ci2)*(56./5. - 32.*log(2.)/3.
2418,2419c2761,2762
<                 hc25 = cos(2.*phi)*ci*(2. - ci2*22./5. + eta*(-282./5. 
<                         + ci2*94./5.)) + cos(4.*phi)*ci*si2*(-112./5. 
---
>                 hc25 = cos(2.*phi)*ci*(2. - ci2*22./5. + eta*(-282./5.
>                         + ci2*94./5.)) + cos(4.*phi)*ci*si2*(-112./5.
2421,2422c2764,2765
<                         + sin(phi)*si*ci*dm*(-913./7680. + ci2*1891./11520. 
<                         - ci4*7./4608. + eta*(1165./384. - ci2*235./576. 
---
>                         + sin(phi)*si*ci*dm*(-913./7680. + ci2*1891./11520.
>                         - ci4*7./4608. + eta*(1165./384. - ci2*235./576.
2424,2425c2767,2768
<                         - ci4*7./1536.)) + sin(2.*phi)*LAL_PI*ci*(34./3. 
<                         - ci2*8./3. + eta*(-20./3. + 8.*ci2)) 
---
>                         - ci4*7./1536.)) + sin(2.*phi)*LAL_PI*ci*(34./3.
>                         - ci2*8./3. + eta*(-20./3. + 8.*ci2))
2428,2429c2771,2772
<                         - ci4*1701./640.) + eta2*(18903./2560. 
<                         - ci2*11403./1280. + ci4*5103./2560.)) 
---
>                         - ci4*1701./640.) + eta2*(18903./2560.
>                         - ci2*11403./1280. + ci4*5103./2560.))
2432,2434c2775,2777
<                         - ci4*21875./4608. + eta*(66875./1152. 
<                         - ci2*44375./576. + ci4*21875./1152.) 
<                         + eta2*(-100625./4608. + ci2*83125./2304. 
---
>                         - ci4*21875./4608. + eta*(66875./1152.
>                         - ci2*44375./576. + ci4*21875./1152.)
>                         + eta2*(-100625./4608. + ci2*83125./2304.
2439,2442c2782,2785
<                 hp2 = cos(phi)*LAL_PI*si*dm*(-5./8. - ci2/8.) 
<                         + cos(2.*phi)*(11./60. + ci2*33./10. + ci4*29./24. 
<                         - ci6/24. + eta*(353./36. - 3.*ci2 - ci4*251./72. 
<                         + ci6*5./24.) + eta2*(-49./12. + ci2*9./2. 
---
>                 hp2 = cos(phi)*LAL_PI*si*dm*(-5./8. - ci2/8.)
>                         + cos(2.*phi)*(11./60. + ci2*33./10. + ci4*29./24.
>                         - ci6/24. + eta*(353./36. - 3.*ci2 - ci4*251./72.
>                         + ci6*5./24.) + eta2*(-49./12. + ci2*9./2.
2444,2445c2787,2788
<                         * (27./8.*(1 + ci2)) + cos(4.*phi)*si2*2./15.*(59. 
<                         + ci2*35. - ci4*8. 
---
>                         * (27./8.*(1 + ci2)) + cos(4.*phi)*si2*2./15.*(59.
>                         + ci2*35. - ci4*8.
2453c2796
<                 hc2 = cos(phi)*si*ci*dm*(-9./20. - 3./2.*log(2.)) 
---
>                 hc2 = cos(phi)*si*ci*dm*(-9./20. - 3./2.*log(2.))
2455c2798
<                         - sin(phi)*si*ci*dm*3.*LAL_PI/4. 
---
>                         - sin(phi)*si*ci*dm*3.*LAL_PI/4.
2460c2803
<                         + sin(4.*phi)*ci*si2*4./15.*(55. - 12.*ci2 
---
>                         + sin(4.*phi)*ci*si2*4./15.*(55. - 12.*ci2
2467c2810
<                 hp15 = cos(phi)*si*dm*(19./64. + ci2*5./16. - ci4/192. 
---
>                 hp15 = cos(phi)*si*dm*(19./64. + ci2*5./16. - ci4/192.
2470,2471c2813,2814
<                         + cos(3.*phi)*si*dm*(-657./128. - ci2*45./16. 
<                         + ci4*81./128. + eta*(225./64. - ci2*9./8. 
---
>                         + cos(3.*phi)*si*dm*(-657./128. - ci2*45./16.
>                         + ci4*81./128. + eta*(225./64. - ci2*9./8.
2474,2475c2817,2818
<                 hc15 = sin(phi)*si*ci*dm*(21./32. - ci2*5./96. 
<                         + eta*(-23./48. + ci2*5./48.)) 
---
>                 hc15 = sin(phi)*si*ci*dm*(21./32. - ci2*5./96.
>                         + eta*(-23./48. + ci2*5./48.))
2477,2478c2820,2821
<                         * (-603./64. + ci2*135./64. 
<                         + eta*(171./32. - ci2*135./32.)) 
---
>                         * (-603./64. + ci2*135./64.
>                         + eta*(171./32. - ci2*135./32.))
2482,2483c2825,2826
<                 hp1 = cos(2.*phi)*(19./6. + 3./2.*ci2 - ci4/3. 
<                         + eta*(-19./6. + ci2*11./6. + ci4)) 
---
>                 hp1 = cos(2.*phi)*(19./6. + 3./2.*ci2 - ci4/3.
>                         + eta*(-19./6. + ci2*11./6. + ci4))
2485,2486c2828,2829
<                 hc1 = sin(2.*phi)*ci*(17./3. - ci2*4./3. 
<                         + eta*(-13./3. + 4.*ci2)) 
---
>                 hc1 = sin(2.*phi)*ci*(17./3. - ci2*4./3.
>                         + eta*(-13./3. + 4.*ci2))
2490c2833
<                 hp05 = - si*dm*(cos(phi)*(5./8. + ci2/8.) 
---
>                 hp05 = - si*dm*(cos(phi)*(5./8. + ci2/8.)
2507,2508c2850,2851
<         (*hplus)->data->data[idx] = ampfac * v2 * ( hp0 + v * ( hp05 
<                 + v * ( hp1 + v * ( hp15 + v * ( hp2 + v * ( hp25 + v * hp3 
---
>         (*hplus)->data->data[idx] = ampfac * v2 * ( hp0 + v * ( hp05
>                 + v * ( hp1 + v * ( hp15 + v * ( hp2 + v * ( hp25 + v * hp3
2510,2511c2853,2854
<         (*hcross)->data->data[idx] = ampfac * v2 * ( hc0 + v * ( hc05 
<                 + v * ( hc1 + v * ( hc15 + v * ( hc2 + v * ( hc25 + v * hc3 
---
>         (*hcross)->data->data[idx] = ampfac * v2 * ( hc0 + v * ( hc05
>                 + v * ( hc1 + v * ( hc15 + v * ( hc2 + v * ( hc25 + v * hc3
2617c2960
<  * \"Frequency and time domain inspiral waveforms from comparable 
---
>  * \"Frequency and time domain inspiral waveforms from comparable
2621c2964
<  * 
---
>  *
2623c2966
<  * 
---
>  *
2626c2969
<  * \"Phasing of gravitational waves from inspiralling eccentric 
---
>  * \"Phasing of gravitational waves from inspiralling eccentric
2662c3005
<     
---
> 
2664c3007
<     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch, 0.0, 
---
>     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch, 0.0,
2666c3009
<     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch, 0.0, 
---
>     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch, 0.0,
2670c3013
<     memset((*hplus)->data->data, 0, (*hplus)->data->length 
---
>     memset((*hplus)->data->data, 0, (*hplus)->data->length
2672c3015
<     memset((*hcross)->data->data, 0, (*hcross)->data->length 
---
>     memset((*hcross)->data->data, 0, (*hcross)->data->length
2680,2682c3023,3025
<     
<     /* 
<      * cosines and sines of inclination between 
---
> 
>     /*
>      * cosines and sines of inclination between
2689c3032
<     /* loop over time steps and compute first radial and angular orbital variables, 
---
>     /* loop over time steps and compute first radial and angular orbital variables,
2695c3038
<         phi = Phi->data->data[idx]; 	et = Ecc->data->data[idx];	u = U->data->data[idx];	v = V->data->data[idx];   
---
>         phi = Phi->data->data[idx]; 	et = Ecc->data->data[idx];	u = U->data->data[idx];	v = V->data->data[idx];
2700c3043
< 	
---
> 
2702,2704c3045,3047
<          * First set the functions for the dimensionless orbital variables 
< 	 * (1/c)*dr/dt, (r/c)*dphi/dt, Z = G*m/(r*c^2) to 0. 
< 	 * Then use a switch to set proper non-zero values 
---
>          * First set the functions for the dimensionless orbital variables
> 	 * (1/c)*dr/dt, (r/c)*dphi/dt, Z = G*m/(r*c^2) to 0.
> 	 * Then use a switch to set proper non-zero values
2708c3051
< 	
---
> 
2710c3053
< 	
---
> 
2715c3058
< 	
---
> 
2747c3090
< 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta 
---
> 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta
2750,2757c3093,3100
< 			  + ((-288. + 765. * eta - 27. * pow(eta,  2.0) 
< 			  + pow(et, 4.0) * (261. * eta - 27 * pow(eta, 2.0)) 
< 			  + pow(et, 2.0) * (288. - 1026. * eta + 54. * pow(eta, 2.0)) 
< 			  + (-540. + pow(et, 2.0) * (540. - 216. * eta) 
< 			  + 216. * eta) * OTS + dt * (648. - 567. * eta + 35. * pow(eta, 2.0) 
< 			  + pow(et, 2.0) * (468. + 150. * eta - 70. * pow(eta, 2.0)) 
< 			  + pow(et, 4.0) * (72. - 231. * eta + 35. * pow(eta, 2.0)) 
< 			  + (180. - 72. * eta + pow(et, 2.0) * (-180. + 72. * eta)) * OTS)) * pow(v, 4.0)) 
---
> 			  + ((-288. + 765. * eta - 27. * pow(eta,  2.0)
> 			  + pow(et, 4.0) * (261. * eta - 27 * pow(eta, 2.0))
> 			  + pow(et, 2.0) * (288. - 1026. * eta + 54. * pow(eta, 2.0))
> 			  + (-540. + pow(et, 2.0) * (540. - 216. * eta)
> 			  + 216. * eta) * OTS + dt * (648. - 567. * eta + 35. * pow(eta, 2.0)
> 			  + pow(et, 2.0) * (468. + 150. * eta - 70. * pow(eta, 2.0))
> 			  + pow(et, 4.0) * (72. - 231. * eta + 35. * pow(eta, 2.0))
> 			  + (180. - 72. * eta + pow(et, 2.0) * (-180. + 72. * eta)) * OTS)) * pow(v, 4.0))
2764c3107
< 			  + (-6. * pow(1. - pow(et, 2.0), 3.0) * eta * (3. + 2. * eta) 
---
> 			  + (-6. * pow(1. - pow(et, 2.0), 3.0) * eta * (3. + 2. * eta)
2766,2773c3109,3116
< 			  + pow(et, 2.0) * (-147. + 8. * eta - 14. * pow(eta, 2.0))) 
< 			  + dt * (108. + 63. * eta + 33. * pow(eta, 2.0) 
< 			  + pow(et, 2.0) * (-216. - 126. * eta - 66. * pow(eta, 2.0)) 
< 			  + pow(et, 4.0) * (108. + 63. * eta + 33. * pow(eta, 2.0))) 
< 			  + pow(dt, 2.0) * (-240. - 31. * eta - 29. * pow(eta, 2.0) 
< 			  + pow(et, 4.0) * (-48. + 17. * eta - 17. * pow(eta, 2.0)) 
< 			  + pow(et, 2.0) * (288. + 14. * eta + 46. * pow(eta,2))) 
< 			  + 18. * pow(dt, 2.0) * (-2. + dt + 2. * pow(et, 2.0)) * (-5. + 2. * eta) * OTS) * pow(v, 4.0) 
---
> 			  + pow(et, 2.0) * (-147. + 8. * eta - 14. * pow(eta, 2.0)))
> 			  + dt * (108. + 63. * eta + 33. * pow(eta, 2.0)
> 			  + pow(et, 2.0) * (-216. - 126. * eta - 66. * pow(eta, 2.0))
> 			  + pow(et, 4.0) * (108. + 63. * eta + 33. * pow(eta, 2.0)))
> 			  + pow(dt, 2.0) * (-240. - 31. * eta - 29. * pow(eta, 2.0)
> 			  + pow(et, 4.0) * (-48. + 17. * eta - 17. * pow(eta, 2.0))
> 			  + pow(et, 2.0) * (288. + 14. * eta + 46. * pow(eta,2)))
> 			  + 18. * pow(dt, 2.0) * (-2. + dt + 2. * pow(et, 2.0)) * (-5. + 2. * eta) * OTS) * pow(v, 4.0)
2780,2783c3123,3126
< 			  + (-135. * eta + 9. * pow(eta, 2.0) + pow(et, 2.0) * (405. * eta - 27. * pow(eta, 2.0)) 
< 			  + pow(et, 6.0) * (135. * eta - 9. * pow(eta, 2.0)) 
< 			  + pow(et, 4.0) * (-405. * eta + 27 * pow(eta, 2.0)) 
< 			  + dt * (-540. + 351. * eta - 9. * pow(eta, 2.0) 
---
> 			  + (-135. * eta + 9. * pow(eta, 2.0) + pow(et, 2.0) * (405. * eta - 27. * pow(eta, 2.0))
> 			  + pow(et, 6.0) * (135. * eta - 9. * pow(eta, 2.0))
> 			  + pow(et, 4.0) * (-405. * eta + 27 * pow(eta, 2.0))
> 			  + dt * (-540. + 351. * eta - 9. * pow(eta, 2.0)
2785,2789c3128,3132
< 			  + pow(et, 2.0) * (1080. - 702. * eta + 18. * pow(eta, 2.0))) 
< 			  + pow(dt, 3.0) * (-324. + 189. * eta + 35. * pow(eta, 2.0) 
< 			  + pow(et, 2.0) * (-234. + 366. * eta - 70. * pow(eta, 2.0)) 
< 			  + pow(et, 4.0) * (72. - 231. * eta + 35. * pow(eta, 2.0))) 
< 			  - 36 * pow(dt, 2.0) * (3. + dt) * (1 - pow(et, 2.0)) * (-5. + 2. * eta) * OTS) * pow(v, 4.0) 
---
> 			  + pow(et, 2.0) * (1080. - 702. * eta + 18. * pow(eta, 2.0)))
> 			  + pow(dt, 3.0) * (-324. + 189. * eta + 35. * pow(eta, 2.0)
> 			  + pow(et, 2.0) * (-234. + 366. * eta - 70. * pow(eta, 2.0))
> 			  + pow(et, 4.0) * (72. - 231. * eta + 35. * pow(eta, 2.0)))
> 			  - 36 * pow(dt, 2.0) * (3. + dt) * (1 - pow(et, 2.0)) * (-5. + 2. * eta) * OTS) * pow(v, 4.0)
2791c3134
< 			  //==========================================================================================		
---
> 			  //==========================================================================================
2797c3140
< 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta 
---
> 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta
2813c3156
< 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta 
---
> 			  + ((-24. + dt * (18. - 7. * eta) + 9. * eta + pow(et, 2.0) * (24. - 9. * eta
2843c3186
<         
---
> 
2848c3191
< 	
---
> 
2975c3318
<     REAL8 hplusSpin15, hcrossSpin15, hplusTail15, hcrossTail15; 
---
>     REAL8 hplusSpin15, hcrossSpin15, hplusTail15, hcrossTail15;
3009c3352
<     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch, 
---
>     *hplus = XLALCreateREAL8TimeSeries( "H_PLUS", &V->epoch,
3011c3354
<     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch, 
---
>     *hcross = XLALCreateREAL8TimeSeries( "H_CROSS", &V->epoch,
3015c3358
<     memset((*hplus)->data->data, 0, 
---
>     memset((*hplus)->data->data, 0,
3017c3360
<     memset((*hcross)->data->data, 0, 
---
>     memset((*hcross)->data->data, 0,
3026c3369
<     
---
> 
3059c3402
<         /* 
---
>         /*
3089c3432
<                 hplus15 = (dm*(2*lx*nx*nz*(-95 + 90*lz2 - 65*nz2 
---
>                 hplus15 = (dm*(2*lx*nx*nz*(-95 + 90*lz2 - 65*nz2
3092c3435
<                         + 6*lx2*lz*(13 - 4*lz2 + 29*nz2 + eta*(-2 + 8*lz2 
---
>                         + 6*lx2*lz*(13 - 4*lz2 + 29*nz2 + eta*(-2 + 8*lz2
3094c3437
<                         * (-2 + 8*lz2 - 58*nz2)) - lz*(nx2 - ny2)*(83 - 6*lz2 
---
>                         * (-2 + 8*lz2 - 58*nz2)) - lz*(nx2 - ny2)*(83 - 6*lz2
3097,3100c3440,3443
<                         * nx*ny) + (-149 + 36*eta) * (ly*nx + lx*ny)*nz 
<                         + 6*(-3 + eta) * (2*lx*ly*lz - lz*nx*ny - 3*ly*nx*nz 
<                         - 3*lx*ny*nz) + (1 - 2*eta) * (6*lz3*(-4*lx*ly + nx*ny) 
<                         + 90*lz2*(ly*nx + lx*ny)*nz + 3*lz*(58*lx*ly 
---
>                         * nx*ny) + (-149 + 36*eta) * (ly*nx + lx*ny)*nz
>                         + 6*(-3 + eta) * (2*lx*ly*lz - lz*nx*ny - 3*ly*nx*nz
>                         - 3*lx*ny*nz) + (1 - 2*eta) * (6*lz3*(-4*lx*ly + nx*ny)
>                         + 90*lz2*(ly*nx + lx*ny)*nz + 3*lz*(58*lx*ly
3103,3106c3446,3449
<                 hplusSpin15 = (6*lz*ny*s1x + 6*dm*lz*ny*s1x - 3*eta*lz*ny*s1x 
<                         + 2*ly2*lnhy*s1y + 2*dm*ly2*lnhy*s1y 
<                         + 2*eta*ly2*lnhy*s1y + 6*lz*nx*s1y + 6*dm*lz*nx*s1y 
<                         - 3*eta*lz*nx*s1y + 8*lnhy*nx2*s1y + 8*dm*lnhy*nx2*s1y 
---
>                 hplusSpin15 = (6*lz*ny*s1x + 6*dm*lz*ny*s1x - 3*eta*lz*ny*s1x
>                         + 2*ly2*lnhy*s1y + 2*dm*ly2*lnhy*s1y
>                         + 2*eta*ly2*lnhy*s1y + 6*lz*nx*s1y + 6*dm*lz*nx*s1y
>                         - 3*eta*lz*nx*s1y + 8*lnhy*nx2*s1y + 8*dm*lnhy*nx2*s1y
3109,3110c3452,3453
<                         + 2*eta*ly2*lnhz*s1z - 6*ly*nx*s1z - 6*dm*ly*nx*s1z 
<                         - 9*eta*ly*nx*s1z + 8*lnhz*nx2*s1z + 8*dm*lnhz*nx2*s1z 
---
>                         + 2*eta*ly2*lnhz*s1z - 6*ly*nx*s1z - 6*dm*ly*nx*s1z
>                         - 9*eta*ly*nx*s1z + 8*lnhz*nx2*s1z + 8*dm*lnhz*nx2*s1z
3112,3113c3455,3456
<                         + eta*lnhz*ny2*s1z + 6*lz*ny*s2x - 6*dm*lz*ny*s2x 
<                         - 3*eta*lz*ny*s2x + lnhx*(2*ly2*((1 + dm + eta)*s1x 
---
>                         + eta*lnhz*ny2*s1z + 6*lz*ny*s2x - 6*dm*lz*ny*s2x
>                         - 3*eta*lz*ny*s2x + lnhx*(2*ly2*((1 + dm + eta)*s1x
3115,3123c3458,3466
<                         * s1x - (-8 + 8*dm + eta)*s2x)) + 2*ly2*lnhy*s2y 
<                         - 2*dm*ly2*lnhy*s2y + 2*eta*ly2*lnhy*s2y + 6*lz*nx*s2y 
<                         - 6*dm*lz*nx*s2y - 3*eta*lz*nx*s2y + 8*lnhy*nx2*s2y 
<                         - 8*dm*lnhy*nx2*s2y - eta*lnhy*nx2*s2y - 8*lnhy*ny2*s2y 
<                         + 8*dm*lnhy*ny2*s2y + eta*lnhy*ny2*s2y + 2*ly2*lnhz*s2z 
<                         - 2*dm*ly2*lnhz*s2z + 2*eta*ly2*lnhz*s2z - 6*ly*nx*s2z 
<                         + 6*dm*ly*nx*s2z - 9*eta*ly*nx*s2z + 8*lnhz*nx2*s2z 
<                         - 8*dm*lnhz*nx2*s2z - eta*lnhz*nx2*s2z - 8*lnhz*ny2*s2z 
<                         + 8*dm*lnhz*ny2*s2z + eta*lnhz*ny2*s2z - 3*lx*ny 
---
>                         * s1x - (-8 + 8*dm + eta)*s2x)) + 2*ly2*lnhy*s2y
>                         - 2*dm*ly2*lnhy*s2y + 2*eta*ly2*lnhy*s2y + 6*lz*nx*s2y
>                         - 6*dm*lz*nx*s2y - 3*eta*lz*nx*s2y + 8*lnhy*nx2*s2y
>                         - 8*dm*lnhy*nx2*s2y - eta*lnhy*nx2*s2y - 8*lnhy*ny2*s2y
>                         + 8*dm*lnhy*ny2*s2y + eta*lnhy*ny2*s2y + 2*ly2*lnhz*s2z
>                         - 2*dm*ly2*lnhz*s2z + 2*eta*ly2*lnhz*s2z - 6*ly*nx*s2z
>                         + 6*dm*ly*nx*s2z - 9*eta*ly*nx*s2z + 8*lnhz*nx2*s2z
>                         - 8*dm*lnhz*nx2*s2z - eta*lnhz*nx2*s2z - 8*lnhz*ny2*s2z
>                         + 8*dm*lnhz*ny2*s2z + eta*lnhz*ny2*s2z - 3*lx*ny
3125,3126c3468,3469
<                         - 2*lx2*(lnhx*((1 + dm + eta)*s1x + (1 - dm + eta)*s2x) 
<                         + lnhy*((1 + dm + eta)*s1y + (1 - dm + eta)*s2y) 
---
>                         - 2*lx2*(lnhx*((1 + dm + eta)*s1x + (1 - dm + eta)*s2x)
>                         + lnhy*((1 + dm + eta)*s1y + (1 - dm + eta)*s2y)
3128,3132c3471,3475
<                 hcrossSpin15 = (-3*lz*(nx*((2 + 2*dm - eta)*s1x 
<                         - (-2 + 2*dm + eta)*s2x) + ny*((-2 - 2*dm + eta)*s1y 
<                         + (-2 + 2*dm + eta)*s2y)) + ny*(-6*ly*s1z - 6*dm*ly*s1z 
<                         - 9*eta*ly*s1z + 16*lnhz*nx*s1z + 16*dm*lnhz*nx*s1z 
<                         - 2*eta*lnhz*nx*s1z + 2*lnhx*nx*((8 + 8*dm - eta)*s1x 
---
>                 hcrossSpin15 = (-3*lz*(nx*((2 + 2*dm - eta)*s1x
>                         - (-2 + 2*dm + eta)*s2x) + ny*((-2 - 2*dm + eta)*s1y
>                         + (-2 + 2*dm + eta)*s2y)) + ny*(-6*ly*s1z - 6*dm*ly*s1z
>                         - 9*eta*ly*s1z + 16*lnhz*nx*s1z + 16*dm*lnhz*nx*s1z
>                         - 2*eta*lnhz*nx*s1z + 2*lnhx*nx*((8 + 8*dm - eta)*s1x
3134,3135c3477,3478
<                         * s1y - (-8 + 8*dm + eta)*s2y) - 6*ly*s2z + 6*dm*ly*s2z 
<                         - 9*eta*ly*s2z + 16*lnhz*nx*s2z - 16*dm*lnhz*nx*s2z 
---
>                         * s1y - (-8 + 8*dm + eta)*s2y) - 6*ly*s2z + 6*dm*ly*s2z
>                         - 9*eta*ly*s2z + 16*lnhz*nx*s2z - 16*dm*lnhz*nx*s2z
3137c3480
<                         + (1 - dm + eta)*s2x) - 3*nx*((2 + 2*dm + 3*eta)*s1z 
---
>                         + (1 - dm + eta)*s2x) - 3*nx*((2 + 2*dm + 3*eta)*s1z
3139c3482
<                         * s1y + (1 - dm + eta)*s2y) + lnhz*((1 + dm + eta)*s1z 
---
>                         * s1y + (1 - dm + eta)*s2y) + lnhz*((1 + dm + eta)*s1z
3143c3486
<                 hplusTail15 = 2*((lx2 - ly2 - nx2 + ny2)*LAL_PI 
---
>                 hplusTail15 = 2*((lx2 - ly2 - nx2 + ny2)*LAL_PI
3145c3488
<                 hcrossTail15 = 4*((lx*ly - nx*ny)*LAL_PI 
---
>                 hcrossTail15 = 4*((lx*ly - nx*ny)*LAL_PI
3151,3156c3494,3499
<                 hplus1 = (-13*lx2 + 13*ly2 + 6*lx2*lz2 - 6*ly2*lz2 
<                         + 13*(nx2 - ny2) - 2*lz2*(nx2 - ny2) - 32*lx*lz*nx*nz 
<                         + 32*ly*lz*ny*nz - 14*lx2*nz2 + 14*ly2*nz2 
<                         + 10*(nx2 - ny2)*nz2)/6. + (eta*(lx2 - 18*lx2*lz2 
<                         + 96*lx*lz*nx*nz - 96*ly*lz*ny*nz + 42*lx2*nz2 
<                         + ly2*(-1 + 18*lz2 - 42*nz2) + (nx2 - ny2) 
---
>                 hplus1 = (-13*lx2 + 13*ly2 + 6*lx2*lz2 - 6*ly2*lz2
>                         + 13*(nx2 - ny2) - 2*lz2*(nx2 - ny2) - 32*lx*lz*nx*nz
>                         + 32*ly*lz*ny*nz - 14*lx2*nz2 + 14*ly2*nz2
>                         + 10*(nx2 - ny2)*nz2)/6. + (eta*(lx2 - 18*lx2*lz2
>                         + 96*lx*lz*nx*nz - 96*ly*lz*ny*nz + 42*lx2*nz2
>                         + ly2*(-1 + 18*lz2 - 42*nz2) + (nx2 - ny2)
3158,3161c3501,3504
<                 hcross1 = (eta*(lx*ly - nx*ny - 6*(lz2*(3*lx*ly - nx*ny) 
<                         - 8*lz*(ly*nx + lx*ny)*nz + (-7*lx*ly 
<                         + 5*nx*ny)*nz2)))/3. + (-13*(lx*ly - nx*ny) 
<                         + 2*(lz2*(3*lx*ly - nx*ny) - 8*lz*(ly*nx + lx*ny)*nz 
---
>                 hcross1 = (eta*(lx*ly - nx*ny - 6*(lz2*(3*lx*ly - nx*ny)
>                         - 8*lz*(ly*nx + lx*ny)*nz + (-7*lx*ly
>                         + 5*nx*ny)*nz2)))/3. + (-13*(lx*ly - nx*ny)
>                         + 2*(lz2*(3*lx*ly - nx*ny) - 8*lz*(ly*nx + lx*ny)*nz
3164c3507
<                 hplusSpin1 = (-(ny*((1 + dm)*s1x + (-1 + dm)*s2x)) 
---
>                 hplusSpin1 = (-(ny*((1 + dm)*s1x + (-1 + dm)*s2x))
3166c3509
<                 hcrossSpin1 = (nx*((1 + dm)*s1x + (-1 + dm)*s2x) 
---
>                 hcrossSpin1 = (nx*((1 + dm)*s1x + (-1 + dm)*s2x)
3172c3515
<                 hplus05 = (dm*(-2*lx2*lz + 2*ly2*lz + lz*(nx2 - ny2) 
---
>                 hplus05 = (dm*(-2*lx2*lz + 2*ly2*lz + lz*(nx2 - ny2)
3174c3517
<                 hcross05 = dm*(-2*lx*ly*lz + lz*nx*ny 
---
>                 hcross05 = dm*(-2*lx*ly*lz + lz*nx*ny
3183c3526
<             default: 
---
>             default:
3191,3192c3534,3535
<         (*hplus)->data->data[idx] = ampfac * v2 * ( hplus0 
<                 + v * ( hplus05 + v * ( hplus1 + hplusSpin1 
---
>         (*hplus)->data->data[idx] = ampfac * v2 * ( hplus0
>                 + v * ( hplus05 + v * ( hplus1 + hplusSpin1
3194,3195c3537,3538
<         (*hcross)->data->data[idx] = ampfac * v2 * ( hcross0 
<                 + v * ( hcross05 + v * ( hcross1 + hcrossSpin1 
---
>         (*hcross)->data->data[idx] = ampfac * v2 * ( hcross0
>                 + v * ( hcross05 + v * ( hcross1 + hcrossSpin1
3546c3889
<  * @name Routines for Handling Approximants, Order, Axis, Mode Information 
---
>  * @name Routines for Handling Approximants, Order, Axis, Mode Information
3565a3909
> 	case EccentricTD:
3567c3911,3912
<         case TNSEOB:
---
> 		case TNSEOB:
>         case HGimri:
3573c3918
< 	case IMRPhenomB:
---
>         case IMRPhenomB:
3575a3921
> 	case IMRPhenomD:
3579a3926
>         case SEOBNRv2_opt:
3580a3928
>         case NR_hdf5:
3603a3952,3954
>         case IMRPhenomPv2:
>         case EOBNRv2_ROM:
>         case EOBNRv2HM_ROM:
3607a3959
>         case SEOBNRv2_ROM_DoubleSpin_HI:
3659,3662d4010
<  *
<  * @bug
<  * The default frame axis should be LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L
<  * rather than LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW.
3698c4046
<             *axis = LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW;
---
>             *axis = LAL_SIM_INSPIRAL_FRAME_AXIS_DEFAULT;
3791,3793d4138
<  * @bug
<  * The default should be LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L
<  * rather than LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW.
3807,3809d4151
<  * @bug
<  * The default should be LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L
<  * rather than LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW.
3821c4163
<         axis = LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW;
---
>         axis = LAL_SIM_INSPIRAL_FRAME_AXIS_DEFAULT;
4006a4349
>     case IMRPhenomPv2:
4009a4353,4354
>     case SEOBNRv3:
>     case NR_hdf5:
4024c4369
<     case SEOBNRv3:
---
>     case SEOBNRv2_opt:
4028a4374
>     case SEOBNRv2_ROM_DoubleSpin_HI:
4042a4389
>     case EOBNRv2HM_ROM:
4044c4391
<     case TNSEOB:
---
>     case EOBNRv2_ROM:
4094d4440
<     case TNSEOB:
4096a4443,4444
> 	case TNSEOB:
>     case EOBNRv2_ROM:
4097a4446
>     case EOBNRv2HM_ROM:
4099a4449
>     case SEOBNRv2_opt:
4104a4455
>     case SEOBNRv2_ROM_DoubleSpin_HI:
4111a4463
>     case IMRPhenomPv2:
4119a4472
>     case NR_hdf5:
4339c4692
<         case fSchwarzISCO: 
---
>         case fSchwarzISCO:
4353a4707,4709
> 		case fIMRPhenomDPeak:
> 			freq = XLALIMRPhenomDGetPeakFreq(m1Msun, m2Msun, S1z, S2z);
> 			break;
4451c4807
< 	    {	
---
> 	    {
4495,4501d4850
< 
<         case TNSEOB:
<             /* Check that spins are zero */
<             XLALPrintError("I don't know how to calculate final freq. for this approximant, sorry!\n");
<             XLAL_ERROR(XLAL_EINVAL);
<             break;
< 
4512a4862
>         case SEOBNRv2_opt:
4550d4899
< 
4560a4910,4911
>         /* NR waveforms */
>         case NR_hdf5:
4590c4941
<  * 
---
>  *
4652c5003
<  * 
---
>  *
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralEccentricityFD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralEccentricityFD.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralEccentricTD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralEccentricTD.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiral.h ./LALSimInspiral.h
27a28
> 
34a36,187
>  * @addtogroup lalsimulation_inspiral
>  * @details
>  *
>  * Various types of inspiral approximants are supported for producing
>  * waveforms in the time- or frequency-domains.  The high-level routines
>  * for generating simulated inspiral waveforms are
>  * XLALSimInspiralChooseTDWaveform() (for time-domain waveforms) and
>  * XLALSimInspiralChooseFDWaveform() (for frequency-domain waveforms).
>  * The following examples show their basic usage.
>  *
>  * Generate a time-domain waveform:
>  * @code
>  * #include <lal/LALSimInspiral.h>
>  * #include <lal/LALConstants.h>
>  * ...
>  * double phiRef = 0;             // gravitational wave phase at end
>  * double deltaT = 1.0/16384.0;   // series sampling interval
>  * double m1 = 1.4 * LAL_MSUN_SI; // mass of body 1
>  * double m2 = 1.4 * LAL_MSUN_SI; // mass of body 2
>  * double S1x = 0.0;              // x-component of dimensionless spin of body 1
>  * double S1y = 0.0;              // y-component of dimensionless spin of body 1
>  * double S1z = 0.0;              // z-component of dimensionless spin of body 1
>  * double S2x = 0.0;              // x-component of dimensionless spin of body 2
>  * double S2y = 0.0;              // y-component of dimensionless spin of body 2
>  * double S2z = 0.0;              // z-component of dimensionless spin of body 2
>  * double f_min = 40.0;           // start frequency of inspiral
>  * double f_ref = 0.0;            // reference frequency: 0 means waveform end
>  * double r = 1e6 * LAL_PC_SI;    // distance
>  * double i = 0.0;                // inclination
>  * double lambda1 = 0.0;          // dimensionless tidal parameter of body 1
>  * double lambda2 = 0.0;          // dimensionless tidal parameter of body 2
>  * LALSimInspiralWaveformFlags *waveFlags = NULL;  // no extra flags
>  * LALSimInspiralTestGRParam *nonGRparams = NULL;  // no non-GR parameters
>  * int amplitudeO = -1;           // amplitude pN order: -1 means include all
>  * int phaseO = -1;               // phase pN order: -1 means include all
>  * Approximant approximant = TaylorT2;  // post-Newtonian approximant
>  * REAL8TimeSeries *hplus = NULL;  // plus polarization to be returned
>  * REAL8TimeSeries *hcross = NULL; // cross polarization to be returned
>  * ...
>  * XLALSimInspiralChooseTDWaveform(&hplus, &hcross, phiRef, deltaT, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, f_ref, r, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
>  * @endcode
>  *
>  * Generate a frequency-domain waveform:
>  * @code
>  * #include <lal/LALSimInspiral.h>
>  * #include <lal/LALConstants.h>
>  * ...
>  * double phiRef = 0;             // gravitational wave phase at end
>  * double deltaF = 1.0/64.0;      // series sampling interval
>  * double m1 = 1.4 * LAL_MSUN_SI; // mass of body 1
>  * double m2 = 1.4 * LAL_MSUN_SI; // mass of body 2
>  * double S1x = 0.0;              // x-component of dimensionless spin of body 1
>  * double S1y = 0.0;              // y-component of dimensionless spin of body 1
>  * double S1z = 0.0;              // z-component of dimensionless spin of body 1
>  * double S2x = 0.0;              // x-component of dimensionless spin of body 2
>  * double S2y = 0.0;              // y-component of dimensionless spin of body 2
>  * double S2z = 0.0;              // z-component of dimensionless spin of body 2
>  * double f_min = 40.0;           // start frequency of inspiral
>  * double f_max = 0.0;            // end frequency of inspiral: 0 means use default
>  * double f_ref = 0.0;            // reference frequency: 0 means waveform end
>  * double r = 1e6 * LAL_PC_SI;    // distance
>  * double i = 0.0;                // inclination
>  * double lambda1 = 0.0;          // dimensionless tidal parameter of body 1
>  * double lambda2 = 0.0;          // dimensionless tidal parameter of body 2
>  * LALSimInspiralWaveformFlags *waveFlags = NULL;  // no extra flags
>  * LALSimInspiralTestGRParam *nonGRparams = NULL;  // no non-GR parameters
>  * int amplitudeO = -1;           // amplitude pN order: -1 means include all
>  * int phaseO = -1;               // phase pN order: -1 means include all
>  * Approximant approximant = TaylorF2;  // post-Newtonian approximant
>  * COMPLEX16FrequencySeries *hptilde = NULL;  // plus polarization to be returned
>  * COMPLEX16FrequencySeries *hctilde = NULL; // cross polarization to be returned
>  * ...
>  * XLALSimInspiralChooseFDWaveform(&hptilde, &hctilde, phiRef, deltaF, m1, m2, S1x, S1y, S1z, S2x, S2y, S2z, f_min, f_max, f_ref, r, i, lambda1, lambda2, waveFlags, nonGRparams, amplitudeO, phaseO, approximant);
>  * @endcode
>  *
>  * ### Coordinate Systems
>  *
>  * The diagram below illustrates how the source frame (x,y,z) of the binary is
>  * related to the wave frame (X,Y,Z) in which the gravitational waveform is
>  * defined.
>  *
>  * @anchor lalsiminspiral_orbitelements
>  * @image html lalsiminspiral_orbitelements.svg "Orbital Elements"
>  *
>  * The origin of the coordinate systems is the instantaneous center-of-mass
>  * of the binary system.  The orbiting body shown in the diagram is body 1.
>  *
>  * The binary's instantaneous orbital angular momentum @b L at the
>  * reference gravitational wave frequency @p f_ref defines the z-axis of the
>  * binary system, while the direction to the periapsis defines the x-axis of
>  * the binary system.  The x-y-plane is therefore the orbital plane, at least
>  * at the moment the binary system is at the reference gravitational wave
>  * frequency.
>  *
>  * The spin components for body 1, (@p S1x,@p S1y, @p S1z), and for body 2,
>  * (@p S2x,@p S2y, @p S2z), are defined in the source-frame.  Therefore,
>  * when the spins are aligned with the orbital angular momentum,
>  * @p S1x = @p S1y = @p S2x = @p S2y = 0.
>  *
>  * The wave frame is defined by the Z-axis, which points toward the Earth,
>  * and some reference direction, defining the X-axis.  The X-Y-plane is
>  * therefore the plane of the sky.
>  *
>  * The plus- and cross-polarizations of the gravitational waveform are defined
>  * in this wave frame.  Specifically, if \f$ h^{ij} \f$ is computed in the
>  * source frame, then
>  * \f[ h_+ = \frac12 ( \hat{p}_i \hat{p}_j - \hat{q}_i \hat{q}_j ) h^{ij} \f]
>  * and
>  * \f[ h_\times = \frac12 ( \hat{p}_i \hat{q}_j + \hat{q}_i \hat{p}_j ) h^{ij} \f]
>  * where \f$ \hat{p}_i \f$ are the components of the unit vector pointing
>  * along the X-axis and \f$ \hat{q}_i \f$ are the components of the unit
>  * vector pointing along the Y-axis.
>  *
>  * The orbital elements are:
>  *
>  *  * Inclination (&iota;).  The angle between the Z-axis of the wave frame
>  *    and the z-axis of the source frame.
>  *  * Longitude of ascending node (&Omega;).  The angle on the plane of the
>  *    sky from the X-axis of the reference direction in the wave frame to the
>  *    ascending node @htmlonly &#x260A; @endhtmlonly.
>  *    @note This angle is entirely degenerate with the polarization angle &psi;.
>  *  * Argument of pariapsis (&omega;).  The angle on the orbital plane from
>  *    the ascending node @htmlonly &#x260A; @endhtmlonly to the x-axis in the
>  *    source frame.
>  *  * True anomaly (&phi;).  The angle along the orbital plane from the
>  *    periapsis to the present position of the orbiting body (body 1).
>  *    The reference phase @p phiRef is @e twice the true anomaly of body 1
>  *    at the moment when the system reaches the gravitational wave frequency
>  *    @p f_ref which is @e twice the orbital frequency.
>  *
>  * @attention
>  * At present, eccentric orbits are not fully supported, and the x-axis
>  * of the source frame is defined to be the ascending node
>  * @htmlonly &#x260A; @endhtmlonly.  Therefore, &omega;=0 by definition.
>  *
>  * @attention
>  * In the present implementation, the reference direction in the wave frame,
>  * i.e., the X-axis, is defined to be the ascending node
>  * @htmlonly &#x260A; @endhtmlonly.  Therefore, &Omega;=0 by definition.  At
>  * present, then, the X-axis and the x-axis coincide.
>  *
>  * @sa
>  * The coordinate systems used here follow those of
>  * > Clifford M. Will and Alan G. Wiseman
>  * > "Gravitational radiation from compact binary systems: Gravitational
>  * > waveforms and energy loss to second post-Newtonian order"
>  * > Phys. Rev. D @b 54, 4813 (1996)
>  * > http://dx.doi.org/10.1103/PhysRevD.54.4813
>  *
>  */
> 
> /**
43,48c196
<  * @defgroup LALSimInspiralTaylorT1_c              Module LALSimInspiralTaylorT1.c
<  * @defgroup LALSimInspiralTaylorT2_c              Module LALSimInspiralTaylorT2.c
<  * @defgroup LALSimInspiralTaylorT3_c              Module LALSimInspiralTaylorT3.c
<  * @defgroup LALSimInspiralTaylorT4_c              Module LALSimInspiralTaylorT4.c
<  * @defgroup LALSimInspiralTaylorEt_c              Module LALSimInspiralTaylorEt.c
<  * @defgroup LALSimInspiralTaylorF2_c              Module LALSimInspiralTaylorF2.c
---
>  * @defgroup LALSimInspiralTaylorXX_c              Module LALSimInspiralTaylorXX.c
53a202
>  * @defgroup LALSimInspiralHGimri_c                Module LALSimInspiralHGimri.c
73a223
>                          * @remarks Implemented in lalsimulation (time domain).
77a228
>                          * @remarks Implemented in lalsimulation (time domain).
80a232
>                          * @remarks Implemented in lalsimulation (time domain).
84,141c236,362
<                          * Outputs a frequency-domain wave. */
<    EccentricFD,         /** Frequency domain waveform in the SPA to describe low eccentricity systems */
<    TaylorF2,		/**< The standard stationary phase approximation; Outputs a frequency-domain wave. */
<    TaylorR2F4,		/**< A frequency domain model closely related to TaylorT4 */
<    TaylorF2RedSpin,		/**< TaylorF2 waveforms for non-precessing spins, defined in terms of a single (reduced-spin) parameter [Ajith_2011ec]*/
<    TaylorF2RedSpinTidal,	/**< TaylorF2 waveforms for non-precessing spins, defined in terms of a single (reduced-spin) parameter [Ajith_2011ec] plus tidal terms (http://arxiv.org/abs/1101.1673) */
<    PadeT1,		/**< Time-domain P-approximant; Outputs a time-domain wave. */
<    PadeF1,		/**< Frequency-domain P-approximant (not yet implemented). */
<    EOB,			/**< Effective one-body waveform; Outputs a time-domain wave. */
<    BCV,			/**< Detection template family of Buonanno, Chen and Vallisneri \cite BCV03; Outputs a frequency-domain wave. */
<    BCVSpin,		/**< Detection template family of Buonanno, Chen and Vallisneri including  spin effects \cite BCV03b; Outputs a frequency-domain wave. */
<    SpinTaylorT1,	/**< Spinning case T1 models */
<    SpinTaylorT2,	/**< Spinning case T2 models */
<    SpinTaylorT3,	/**< Spinning case T3 models */
<    SpinTaylorT4,	/**< Spinning case T4 models (lalsimulation's equivalent of SpinTaylorFrameless) */
<    SpinTaylorT5,       /**< Spinning case T5. Ref. Sec III of P. Ajith, Phys Rev D (2011)  */
<    SpinTaylorF2,	/**< Spinning case F2 models (single spin only) */
<    SpinTaylorFrameless,	/**< Spinning case PN models (replace SpinTaylor by removing the coordinate singularity) */
<    SpinTaylor,		/**< Spinning case PN models (should replace SpinTaylorT3 in the future) */
<    PhenSpinTaylor,      /**< Inspiral part of the PhenSpinTaylorRD. */
<    PhenSpinTaylorRD,	/**< Phenomenological waveforms, interpolating between a T4 spin-inspiral and the ringdown. */
<    SpinQuadTaylor,	/**< Spinning case PN models with quadrupole-monopole and self-spin interaction. */
<    FindChirpSP,		/**< The stationary phase templates implemented by FindChirpSPTemplate in the findchirp package (equivalent to TaylorF2 at twoPN order). */
<    FindChirpPTF,	/**< UNDOCUMENTED */
<    GeneratePPN,		/**< The time domain templates generated by LALGeneratePPNInspiral() in the inject package (equivalent to TaylorT3 at twoPN order). */
<    BCVC,		/**< UNDOCUMENTED */
<    FrameFile,		/**< The waveform contains arbitrary data read from a frame file. */
<    AmpCorPPN,		/**< UNDOCUMENTED */
<    NumRel,		/**< UNDOCUMENTED */
<    NumRelNinja2,	/**< The waveform contains REAL8 data generated by lalapps_fr_ninja from a file in the format described in arXiv:0709.0093v3 */
<    Eccentricity,	/**< UNDOCUMENTED */
<    EOBNR,		/**< UNDOCUMENTED */
<    EOBNRv2,
<    TNSEOB,		/**< UNDOCUMENTED */
<    EOBNRv2HM,		/**< UNDOCUMENTED */
<    SEOBNRv1,		/**< Spin-aligned EOBNR model */
<    SEOBNRv2,		/**< Spin-aligned EOBNR model v2 */
<    SEOBNRv3,		/**< Spin precessing EOBNR model v3 */
<    SEOBNRv1_ROM_EffectiveSpin, /**< Single-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv1 See [Purrer:2014fza] */
<    SEOBNRv1_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv1 See [Purrer:2014fza] */
<    SEOBNRv2_ROM_EffectiveSpin, /**< Single-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2 */
<    SEOBNRv2_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2 */
<    HGimri,		/**< Time domain inspiral-merger-ringdown waveform for quasi-circular intermediate mass-ratio inspirals [Huerta & Gair arXiv:1009.1985]*/
<    IMRPhenomA,		/**< Time domain (non-spinning) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFA  */
<    IMRPhenomB,		/**< Time domain (non-precessing spins) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFB */
<    IMRPhenomFA,		/**< Frequency domain (non-spinning) inspiral-merger-ringdown templates of Ajith et al [Ajith_2007kx] with phenomenological coefficients defined in the Table I of [Ajith_2007xh]*/
<    IMRPhenomFB,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Ajith et al [Ajith_2009bn] */
<    IMRPhenomC,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Santamaria et al [Santamaria:2010yb] with phenomenological coefficients defined in the Table II of [Santamaria:2010yb]*/
<    IMRPhenomD,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of ... [] with phenomenological coefficients defined in the Table X of [...]*/
<    IMRPhenomP,		/**< Frequency domain (generic spins) inspiral-merger-ringdown templates of Hannam et al., arXiv:1308.3271 [gr-qc] */
<    IMRPhenomFC,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Santamaria et al [Santamaria:2010yb] with phenomenological coefficients defined in the Table II of [Santamaria:2010yb]*/
<    TaylorEt,		/**< UNDOCUMENTED */
<    TaylorT4,		/**< UNDOCUMENTED */
<    EccentricTD,		/**< Time domain Taylor T4 approximant including orbital eccentricity effects */
<    TaylorN,		/**< UNDOCUMENTED */
<    SpinTaylorT4Fourier, /**< Frequency domain (generic spins) inspiral only waveforms based on TaylorT4, arXiv: 1408.5158 */
<    SpinTaylorT2Fourier, /**< Frequency domain (generic spins) inspiral only waveforms based on TaylorT2, arXiv: 1408.5158 */
<    SpinDominatedWf,     /**< Time domain, inspiral only, 1 spin, precessing waveform, Tapai et al, arXiv: 1209.1722 */
---
>                          * Outputs a frequency-domain wave.
>                          * @attention Not implemented in lalsimulation. */
>    EccentricFD,         /**< Frequency domain waveform in the SPA to describe low eccentricity systems.
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    TaylorF2,		/**< The standard stationary phase approximation; Outputs a frequency-domain wave.
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    TaylorR2F4,		/**< A frequency domain model closely related to TaylorT4
>                          * @attention Not implemented in lalsimulation. */
>    TaylorF2RedSpin,		/**< TaylorF2 waveforms for non-precessing spins, defined in terms of a single (reduced-spin) parameter [Ajith_2011ec].
>                                  * @remarks Implemented in lalsimulation (frequency domain). */
>    TaylorF2RedSpinTidal,	/**< TaylorF2 waveforms for non-precessing spins, defined in terms of a single (reduced-spin) parameter [Ajith_2011ec] plus tidal terms (http://arxiv.org/abs/1101.1673).
>                                  * @remarks Implemented in lalsimulation (frequency domain).  */
>    PadeT1,		/**< Time-domain P-approximant; Outputs a time-domain wave.
>                          * @attention Not implemented in lalsimulation. */
>    PadeF1,		/**< Frequency-domain P-approximant (not yet implemented).
>                          * @attention Not implemented in lalsimulation. */
>    EOB,			/**< Effective one-body waveform; Outputs a time-domain wave.
>                          * @attention Not implemented in lalsimulation. */
>    BCV,			/**< Detection template family of Buonanno, Chen and Vallisneri \cite BCV03; Outputs a frequency-domain wave.
>                          * @attention Not implemented in lalsimulation. */
>    BCVSpin,		/**< Detection template family of Buonanno, Chen and Vallisneri including  spin effects \cite BCV03b; Outputs a frequency-domain wave.
>                          * @attention Not implemented in lalsimulation. */
>    SpinTaylorT1,	/**< Spinning case T1 models.
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SpinTaylorT2,	/**< Spinning case T2 models.
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SpinTaylorT3,	/**< Spinning case T3 models
>                          * @attention Not implemented in lalsimulation. */
>    SpinTaylorT4,	/**< Spinning case T4 models (lalsimulation's equivalent of SpinTaylorFrameless).
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SpinTaylorT5,       /**< Spinning case T5. Ref. Sec III of P. Ajith, Phys Rev D (2011)
>                          * @attention Not implemented in lalsimulation.  */
>    SpinTaylorF2,	/**< Spinning case F2 models (single spin only).
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    SpinTaylorFrameless,	/**< Spinning case PN models (replace SpinTaylor by removing the coordinate singularity)
>                          * @attention Not implemented in lalsimulation. */
>    SpinTaylor,		/**< Spinning case PN models (should replace SpinTaylorT3 in the future)
>                          * @attention Not implemented in lalsimulation. */
>    PhenSpinTaylor,      /**< Inspiral part of the PhenSpinTaylorRD.
>                          * @remarks Implemented in lalsimulation (time domain). */
>    PhenSpinTaylorRD,	/**< Phenomenological waveforms, interpolating between a T4 spin-inspiral and the ringdown.
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SpinQuadTaylor,	/**< Spinning case PN models with quadrupole-monopole and self-spin interaction.
>                          * @attention Not implemented in lalsimulation. */
>    FindChirpSP,		/**< The stationary phase templates implemented by FindChirpSPTemplate in the findchirp package (equivalent to TaylorF2 at twoPN order).
>                          * @attention Not implemented in lalsimulation. */
>    FindChirpPTF,	/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    GeneratePPN,		/**< The time domain templates generated by LALGeneratePPNInspiral() in the inject package (equivalent to TaylorT3 at twoPN order).
>                          * @attention Not implemented in lalsimulation. */
>    BCVC,		/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    FrameFile,		/**< The waveform contains arbitrary data read from a frame file.
>                          * @attention Not implemented in lalsimulation. */
>    AmpCorPPN,		/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    NumRel,		/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    NumRelNinja2,	/**< The waveform contains REAL8 data generated by lalapps_fr_ninja from a file in the format described in arXiv:0709.0093v3
>                          * @attention Not implemented in lalsimulation. */
>    Eccentricity,	/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    EOBNR,		/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    EOBNRv2,		/**< UNDOCUMENTED
>                          * @remarks Implemented in lalsimulation (time domain). */
>    TNSEOB,     /**< UNDOCUMENTED
>                             * @remarks Implemented in lalsimulation (time domain). */
>    EOBNRv2HM,		/**< UNDOCUMENTED
>                          * @remarks Implemented in lalsimulation (time domain). */
>    EOBNRv2_ROM,       /**< Frequency domain reduced order model of model EOBNRv2HM, no spin neither higher modes.
>                          * @attention Not implemented in lalsimulation. */
>    EOBNRv2HM_ROM,       /**< Frequency domain reduced order model of model EOBNRv2HM, no spin but with higher modes.
>                          * @attention Not implemented in lalsimulation. */
>    SEOBNRv1,		/**< Spin-aligned EOBNR model
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SEOBNRv2,		/**< Spin-aligned EOBNR model v2
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SEOBNRv2_opt,	/**< Optimized Spin-aligned EOBNR model v2
>                          * @remarks Implemented in lalsimulation (time domain). */
>    SEOBNRv3,		/**< Spin precessing EOBNR model v3
>                          * @todo Fix implementation in lalsimulation (time domain). */
>    SEOBNRv1_ROM_EffectiveSpin, /**< Single-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv1 See [Purrer:2014fza]
>                                 * @remarks Implemented in lalsimulation (frequency domain). */
>    SEOBNRv1_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv1 See [Purrer:2014fza]
>                              * @remarks Implemented in lalsimulation (frequency domain). */
>    SEOBNRv2_ROM_EffectiveSpin, /**< Single-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2
>                                 * @remarks Implemented in lalsimulation (frequency domain). */
>    SEOBNRv2_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2
>                              * @remarks Implemented in lalsimulation (frequency domain). */
>    SEOBNRv2_ROM_DoubleSpin_HI, /**< High resolution low-mass double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2
>                                 * @remarks Implemented in lalsimulation (frequency domain). */
>    HGimri,		/**< Time domain inspiral-merger-ringdown waveform for quasi-circular intermediate mass-ratio inspirals [Huerta & Gair arXiv:1009.1985]
>                          * @remarks Implemented in lalsimulation (time domain). */
>    IMRPhenomA,		/**< Time domain (non-spinning) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFA.
>                          * @remarks Implemented in lalsimulation (time domain and frequency domain). */
>    IMRPhenomB,		/**< Time domain (non-precessing spins) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFB.
>                          * @remarks Implemented in lalsimulation (time domain and frequency domain). */
>    IMRPhenomFA,		/**< Frequency domain (non-spinning) inspiral-merger-ringdown templates of Ajith et al [Ajith_2007kx] with phenomenological coefficients defined in the Table I of [Ajith_2007xh]
>                          * @attention Not implemented in lalsimulation.*/
>    IMRPhenomFB,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Ajith et al [Ajith_2009bn]
>                          * @attention Not implemented in lalsimulation. */
>    IMRPhenomC,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Santamaria et al [Santamaria:2010yb] with phenomenological coefficients defined in the Table II of [Santamaria:2010yb].
>                          * @remarks Implemented in lalsimulation (time domain and frequency domain). */
>    IMRPhenomD,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Husa et al, arXiv:1508.07250 and Khan et al, arXiv:1508.07253 with phenomenological coefficients defined in the Table ...
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    IMRPhenomP,		/**< Frequency domain (generic spins) inspiral-merger-ringdown templates of Hannam et al., arXiv:1308.3271 [gr-qc]. Based on IMRPhenomC.
>                          * @remarks Implemented in lalsimulation (frequency domain).  */
>    IMRPhenomPv2,		/**< Frequency domain (generic spins) inspiral-merger-ringdown templates of Hannam et al., arXiv:1308.3271 [gr-qc]. Based on IMRPhenomD, arXiv:1508.07250 and arXiv:1508.07253.
>                          * @remarks Implemented in lalsimulation (frequency domain).  */
>    IMRPhenomFC,		/**< Frequency domain (non-precessing spins) inspiral-merger-ringdown templates of Santamaria et al [Santamaria:2010yb] with phenomenological coefficients defined in the Table II of [Santamaria:2010yb]
>                          * @attention Not implemented in lalsimulation.*/
>    TaylorEt,		/**< UNDOCUMENTED
>                          * @remarks Implemented in lalsimulation (time domain). */
>    TaylorT4,		/**< UNDOCUMENTED
>                          * @remarks Implemented in lalsimulation (time domain). */
>    EccentricTD,		/**< Time domain Taylor T4 approximant including orbital eccentricity effects
>                          * @remarks Implemented in lalsimulation (time domain). */
>    TaylorN,		/**< UNDOCUMENTED
>                          * @attention Not implemented in lalsimulation. */
>    SpinTaylorT4Fourier, /**< Frequency domain (generic spins) inspiral only waveforms based on TaylorT4, arXiv: 1408.5158
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    SpinTaylorT2Fourier, /**< Frequency domain (generic spins) inspiral only waveforms based on TaylorT2, arXiv: 1408.5158
>                          * @remarks Implemented in lalsimulation (frequency domain). */
>    SpinDominatedWf,     /**< Time domain, inspiral only, 1 spin, precessing waveform, Tapai et al, arXiv: 1209.1722
>                          * @remarks Implemented in lalsimulation (time domain). */
>    NR_hdf5,              /**< Time domain, NR waveform from HDF file. From INSERT LINKS HERE */
150a372
>     fIMRPhenomDPeak, /**< Frequency of the peak amplitude in IMRPhenomD */
223a446
> SphHarmTimeSeries* XLALSimInspiralTDModesFromPolarizations(REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 S1x, REAL8 S1y, REAL8 S1z, REAL8 S2x, REAL8 S2y, REAL8 S2z, REAL8 f_min, REAL8 f_ref, REAL8 r, REAL8 z, REAL8 lambda1, REAL8 lambda2, LALSimInspiralWaveformFlags *waveFlags, LALSimInspiralTestGRParam *nonGRparams, int amplitudeO, int phaseO, Approximant approximant);
279d501
< int XLALSimInspiralTransformPrecessingInitialConditions(REAL8 *incl, REAL8 *S1x, REAL8 *S1y, REAL8 *S1z, REAL8 *S2x, REAL8 *S2y, REAL8 *S2z, REAL8 thetaJN, REAL8 phiJL, REAL8 theta1, REAL8 theta2, REAL8 phi12, REAL8 chi1, REAL8 chi2, REAL8 m1, REAL8 m2, REAL8 fRef);
281c503
< 
---
> int XLALSimInspiralTransformPrecessingObsoleteInitialConditions(REAL8 *incl, REAL8 *S1x, REAL8 *S1y, REAL8 *S1z, REAL8 *S2x, REAL8 *S2y, REAL8 *S2z, REAL8 thetaJN, REAL8 phiJL, REAL8 theta1, REAL8 theta2, REAL8 phi12, REAL8 chi1, REAL8 chi2, REAL8 m1, REAL8 m2, REAL8 fRef);
358c580
< SphHarmTimeSeries *XLALSimInspiralTaylorT4PNModes(REAL8 phiRef, REAL8 v0, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 fRef, REAL8 r, REAL8 lambda1, REAL8 lambda2, LALSimInspiralTidalOrder tideO, int amplitudeO, int phaseO, int lmax); 
---
> SphHarmTimeSeries *XLALSimInspiralTaylorT4PNModes(REAL8 phiRef, REAL8 v0, REAL8 deltaT, REAL8 m1, REAL8 m2, REAL8 f_min, REAL8 fRef, REAL8 r, REAL8 lambda1, REAL8 lambda2, LALSimInspiralTidalOrder tideO, int amplitudeO, int phaseO, int lmax);
389a612,719
> /* Struct containing all of the non-dynamical coefficients needed
>  * to evolve a TaylorTx spinning, precessing binary and produce a waveform.
>  * This struct is passed to the static Derivatives and StoppingTest functions.*/
> typedef struct tagXLALSimInspiralSpinTaylorTxCoeffs
> {
>   REAL8 M; ///< total mass in solar mass units
>   REAL8 Mchirp; ///< chirp mass in solar mass units
>   REAL8 eta; ///< symmetric mass ratio
>   REAL8 m1M; ///< m1 / M
>   REAL8 m2M; ///< m2 / M
>   REAL8 wdotnewt; ///< leading order coefficient of wdot = \f$\dot{\omega}\f$
>   REAL8 wdotcoeff[LAL_MAX_PN_ORDER]; ///< coeffs. of PN corrections to wdot
>   REAL8 wdotlogcoeff; ///< coefficient of log term in wdot
>   REAL8 wdot3S1O, wdot3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 wdot4S1S2, wdot4S1OS2O; ///< non-dynamical 2PN SS corrections
>   REAL8 wdot4S1S1,wdot4S2S2; ///< non-dynamical self S^2 2PN correction
>   REAL8 wdot4S1OS1O, wdot4S2OS2O; ///< non-dynamical self SO^2 2PN correction
>   REAL8 wdot4QMS1S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correct
>   REAL8 wdot4QMS1OS1O; ///< non-dynamical (S1.L)^2 2PN quadrupole-monopole co
>   REAL8 wdot4QMS2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correct
>   REAL8 wdot4QMS2OS2O; ///< non-dynamical (S2.L)^2 2PN quadrupole-monopole c
>   REAL8 wdot5S1O, wdot5S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 wdot6S1O, wdot6S2O; ///< non-dynamical 3PN SO corrections
>   REAL8 wdot6S1S2, wdot6S1OS2O; ///< non-dynamical 3PN S1-S2 corrections
>   REAL8 wdot6S1S1, wdot6S1OS1O; ///< non-dynamical 3PN Spin^2 corrections
>   REAL8 wdot6S2S2, wdot6S2OS2O; ///< non-dynamical 3PN Spin^2 corrections
>   REAL8 wdot6QMS1S1, wdot6QMS1OS1O; ///< non-dynamical 3PN quadrupole-monopole S1^2 corrections
>   REAL8 wdot6QMS2S2, wdot6QMS2OS2O; ///< non-dynamical 3PN quadrupole-monopole S2^2 corrections
>   REAL8 wdot7S1O, wdot7S2O; ///< non-dynamical 3.5PN SO corrections
>   REAL8 wdottidal10;	///< leading order tidal correction
>   REAL8 wdottidal12;	///< next to leading order tidal correction
>   REAL8 Ecoeff[LAL_MAX_PN_ORDER]; ///< coeffs. of PN corrections to energy
>   REAL8 E3S1O, E3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 E4S1S2,E4S1OS2O; ///< non-dynamical 2PN SS correction
>   REAL8 E4QMS1S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS1OS1O;///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
>   REAL8 E4QMS2OS2O;///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
>   REAL8 E5S1O, E5S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 E6S1S2;  ///< non-dynamical 3PN S1-S2 correction
>   REAL8 E6S1OS2O; ///< non-dynamical 3PN S1.LN S2.LN correction
>   REAL8 E6S1S1, E6S1OS1O; ///< non-dynamical 3PN slef-spin^2 corrections
>   REAL8 E6S2S2, E6S2OS2O; ///< non-dynamical 3PN self-spin^2 corrections
>   REAL8 E6QMS1S1, E6QMS1OS1O; ///< non-dynamical 3PN quadrupole-monopole spin^2 corrections
>   REAL8 E6QMS2S2, E6QMS2OS2O; ///< non-dynamical 3PN quadrupole-monopole spin^2 corrections
>   REAL8 E7S1O, E7S2O; ///< non-dynamical 3.5PN SO corrections
>   REAL8 Etidal10; ///< leading order 5PN tidal correction to energy
>   REAL8 Etidal12; ///< next to leading order 6PN tidal correction to energy
>   REAL8 dEdvnewt;
>   REAL8 Fcoeff[LAL_MAX_PN_ORDER];///<FluxCoeff
>   REAL8 Fnewt; ///<newtonian term in Flux
>   REAL8 Flogcoeff; ///<log coeff in flux
>   REAL8 F3S1O;  ///< Coefficient of S1.LN term
>   REAL8 F3S2O;  ///< Coefficient of S2.LN term
>   REAL8 F4S1S2; ///< Coefficient of S1.S2 term
>   REAL8 F4S1OS2O;///< Coefficient of S1.LN S2.LN term
>   REAL8 F4S1S1;  ///< Coefficient of S1.S1 term
>   REAL8 F4S1OS1O;///< Coefficient of (S1.LN)^2 term
>   REAL8 F4S2S2;  ///< Coefficient of S1.S2 term
>   REAL8 F4S2OS2O; ///< Coefficient of (S2.LN)^2 term
>   REAL8 F4QMS1S1; ///< Coefficient of S1.S1 term
>   REAL8 F4QMS2S2; ///< Coefficient of S2.S2 term
>   REAL8 F4QMS1OS1O; ///< Coefficient of quad-monop. (S1.LN)^2 term
>   REAL8 F4QMS2OS2O; ///< Coefficient of quad-monop. (S2.LN)^2 term
>   REAL8 F5S1O;  ///< Coefficient of (S1.LN)
>   REAL8 F5S2O;  ///< Coefficient of (S1.LN) term
>   REAL8 F6S1O, F6S2O; ///< Coefficient of (Si.LN) term
>   REAL8 F6S1S2, F6S1OS2O; ///< Coefficients of S1.S2 and S1.LN S2.LN terms
>   REAL8 F6S1S1, F6S1OS1O; ///< Coefficients of S1.S1 and (S1.LN)^2 terms
>   REAL8 F6S2S2, F6S2OS2O; ///< Coefficients of S2.S2 and (S2.LN)^2 terms
>   REAL8 F6QMS1S1, F6QMS2S2; ///< Coefficients of quad-monop. S1.S1 and S2.S2 terms
>   REAL8 F6QMS1OS1O, F6QMS2OS2O; ///< Coefficients of quad-monop. (S1.LN)^2 and (S2.LN)^2 terms
>   REAL8 F7S1O; ///< Coefficients of S1.LN term
>   REAL8 F7S2O; ///< Coefficients of S2.LN term
>   REAL8 Ftidal10;     ///< leading order 5PN tidal correction
>   REAL8 Ftidal12;     ///< next-to-leading order 6PN tidal correction
>   REAL8 Ldot3S1O, Ldot3S2O; ///< non-dynamical 1.5PN SO corrections
>   REAL8 Ldot4S1S2; ///< non-dynamical 2PN coefficients of S1.LN S2xL and S2.LN S1xL
>   REAL8 Ldot4QMS1; ///< non-dynamical quad-monop. 2PN coeff of S1.LN S1xL
>   REAL8 Ldot4QMS2; ///< non-dynamical quad-monop. 2PN coeff of S2.LN S2xL
>   REAL8 Ldot5S1O, Ldot5S2O; ///< non-dynamical 2.5PN SO corrections
>   REAL8 Ldot6S1OS2, Ldot6S2OS1; ///< non-dynamical 3PN S1S2 corrections
>   REAL8 Ldot6S1OS1, Ldot6S2OS2; ///< non-dynamical 3PN S^2 corrections
>   REAL8 Ldot6QMS1O, Ldot6QMS2O; ///< non-dynamical 3PN quadrupole-monopole S^2 corrections
>   REAL8 Ldot7S1, Ldot7S2; ///< non-dynamical 3.5PN SxL terms in Ldot
>   REAL8 S1dot3; ///< coeff of LNxS1 term in S1dot
>   REAL8 S2dot3; ///< coeff of LNxS2 term in S2dot
>   REAL8 Sdot4S2;  ///< coeff of S2xS1 term in S1dot and of S1xS2 in S2dot
>   REAL8 Sdot4S2O; ///< coeff of LN.S2 LNxS1 term in S1dot and of LN.S1 LNxS2 in S2dot
>   REAL8 S1dot4QMS1O; ///< coeff of quad-monop. LN.S1 LNxS1 term in S1dot
>   REAL8 S2dot4QMS2O; ///< coeff of quad-monop. LN.S2 LNxS2 term in S1dot
>   REAL8 S1dot5S2; ///< coeff of LNxS1 term in S1dot
>   REAL8 S2dot5S1; ///< coeff of LNxS2 term in S2dot
>   REAL8 S1dot6S1O, S1dot6S2O;  ///< coeff of LN.Si LNxS1 term in S1dot
>   REAL8 S1dot6S2; ///< coeff of S2xS1 term in S1dot
>   REAL8 S1dot6QMS1O; ///< coeff of quad-monop. S1.LN LNxS1 term in S1dot
>   REAL8 S2dot6S1O, S2dot6S2O; ///< coeff of LN.Si LNxS2 term in S2dot
>   REAL8 S2dot6S1;    // Coefficient of S1 x S2 in S2dot
>   REAL8 S2dot6QMS2O; //Coeff. of quad-monop. S2.LN LN X S2 term in S2dot
>   REAL8 S1dot7S2;// Coefficient of S1 x S2 in S1dot
>   REAL8 S2dot7S1;// Coefficient of S1 x S2 in S2dot
>   REAL8 fStart; ///< starting GW frequency of integration
>   REAL8 fEnd; ///< ending GW frequency of integration
>   INT4 phaseO; ///< Twice PN order of GW-phase
>   LALSimInspiralSpinOrder spinO; ///< Twice PN order of included spin effects
>   LALSimInspiralTidalOrder tideO;///< Twice PN order of included tidal effects
>   REAL8 prev_domega; ///< Previous value of domega/dt used in stopping test
> } XLALSimInspiralSpinTaylorTxCoeffs;
401c731,735
< 
---
> INT4 XLALSimInspiralSpinDerivatives(REAL8 *dLNhx, REAL8 *dLNhy, REAL8 *dLNhz, REAL8 *dE1x, REAL8 *dE1y, REAL8 *dE1z, REAL8 *dS1x, REAL8 *dS1y, REAL8 *dS1z, REAL8 *dS2x, REAL8 *dS2y, REAL8 *dS2z, REAL8 *dphiExtra, const REAL8 v, const REAL8 LNhx, const REAL8 LNhy, const REAL8 LNhz, const REAL8 E1x, const REAL8 E1y, const REAL8 E1z, const REAL8 S1x, const REAL8 S1y, const REAL8 S1z, const REAL8 S2x, const REAL8 S2y, const REAL8 S2z, const REAL8 LNhdotS1, const REAL8 LNhdotS2, XLALSimInspiralSpinTaylorTxCoeffs *params);
> INT4 XLALSimInspiralSpinTaylorT4Derivatives(REAL8 t, const REAL8 values[], REAL8 dvalues[], void *mparams);
> INT4 XLALSimInspiralSpinTaylorT4Setup(XLALSimInspiralSpinTaylorTxCoeffs *params, REAL8 m1, REAL8 m2, REAL8 fStart, REAL8 fEnd, REAL8 lambda1, REAL8 lambda2, REAL8 quadparam1, REAL8 quadparam2, LALSimInspiralSpinOrder spinO, LALSimInspiralTidalOrder tideO, INT4 phaseO);
> INT4 XLALSimSpinTaylorEnergySpinDerivativeSetup(XLALSimInspiralSpinTaylorTxCoeffs *params, const REAL8 lambda1, const REAL8 lambda2, const REAL8 quadparam1, const REAL8 quadparam2);
> INT4 XLALSimInspiralSetEnergyPNTerms(REAL8 *Espin3, REAL8 *Espin4, REAL8 *Espin5, REAL8 *Espin6, REAL8 *Espin7, XLALSimInspiralSpinTaylorTxCoeffs *params, const REAL8 LNhdotS1, const REAL8 LNhdotS2, const REAL8 S1sq, const REAL8 S2sq, const REAL8 S1dotS2);
423a758
> 
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralHGimri.c ./LALSimInspiralHGimri.c
32a33
> #include <lal/Date.h>
1073,1078c1074,1079
< 		hp0 = exp(-(i-(i_lightring-1))*dt*(wi0*(m+M)/final_mass))*( aone-(2./9.)*final_q*w0*atwo )*( a0n*cos(w0*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) - a0p*sin(w0*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
< 		hp1 = exp(-(i-(i_lightring-1))*dt*(wi1*(m+M)/final_mass))*( aone-(2./9.)*final_q*w1*atwo )*( a1n*cos(w1*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) - a1p*sin(w1*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
< 		hp2 = exp(-(i-(i_lightring-1))*dt*(wi2*(m+M)/final_mass))*( aone-(2./9.)*final_q*w2*atwo )*( a2n*cos(w2*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) - a2p*sin(w2*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
< 		hc0 = exp(-(i-(i_lightring-1))*dt*(wi0*(m+M)/final_mass))*( aone-(2./9.)*final_q*w0*atwo )*( a0c*cos(w0*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) + a0cp*sin(w0*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
< 		hc1 = exp(-(i-(i_lightring-1))*dt*(wi1*(m+M)/final_mass))*( aone-(2./9.)*final_q*w1*atwo )*( a1c*cos(w1*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) + a1cp*sin(w1*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
< 		hc2 = exp(-(i-(i_lightring-1))*dt*(wi2*(m+M)/final_mass))*( aone-(2./9.)*final_q*w2*atwo )*( a2c*cos(w2*(i-(i_lightring-1))*(dt*(m+M)/final_mass)) + a2cp*sin(w2*(i-(i_lightring-1))*(dt*(m+M)/final_mass)));
---
> 		hp0 = exp(-(i-(i_lightring-1.))*dt*(wi0*(m+M)/final_mass))*( aone-(2./9.)*final_q*w0*atwo )*( a0n*cos(w0*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) - a0p*sin(w0*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
> 		hp1 = exp(-(i-(i_lightring-1.))*dt*(wi1*(m+M)/final_mass))*( aone-(2./9.)*final_q*w1*atwo )*( a1n*cos(w1*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) - a1p*sin(w1*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
> 		hp2 = exp(-(i-(i_lightring-1.))*dt*(wi2*(m+M)/final_mass))*( aone-(2./9.)*final_q*w2*atwo )*( a2n*cos(w2*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) - a2p*sin(w2*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
> 		hc0 = exp(-(i-(i_lightring-1.))*dt*(wi0*(m+M)/final_mass))*( aone-(2./9.)*final_q*w0*atwo )*( a0c*cos(w0*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) + a0cp*sin(w0*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
> 		hc1 = exp(-(i-(i_lightring-1.))*dt*(wi1*(m+M)/final_mass))*( aone-(2./9.)*final_q*w1*atwo )*( a1c*cos(w1*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) + a1cp*sin(w1*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
> 		hc2 = exp(-(i-(i_lightring-1.))*dt*(wi2*(m+M)/final_mass))*( aone-(2./9.)*final_q*w2*atwo )*( a2c*cos(w2*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)) + a2cp*sin(w2*(i-(i_lightring-1.))*(dt*(m+M)/final_mass)));
1099c1100
< 	return 0;
---
> 	return i_lightring;
1103a1105,1110
> /**
>  * @addtogroup LALSimInspiralHGimri_c
>  * @brief Routines for generating the Huerta-Gair Intermediate-Mass-Ratio Inspiral model.
>  * @{
>  */
> 
1215,1217c1222,1224
< 	static LIGOTimeGPS epoch;
< 	*hplus = XLALCreateREAL8TimeSeries("h_plus",&epoch,fDyne,dt,&lalStrainUnit,length);
< 	*hcross = XLALCreateREAL8TimeSeries("h_cross",&epoch,fDyne,dt,&lalStrainUnit,length);
---
> 	LIGOTimeGPS tc = LIGOTIMEGPSZERO;
> 	*hplus = XLALCreateREAL8TimeSeries("h_plus",&tc,fDyne,dt,&lalStrainUnit,length);
> 	*hcross = XLALCreateREAL8TimeSeries("h_cross",&tc,fDyne,dt,&lalStrainUnit,length);
1221c1228,1233
< 	HGimri_start(m*Msun_sec,M*Msun_sec,q,dist*GPC_sec,Sdotn,phi0,p0,(*hplus)->data,(*hcross)->data,dt/((m+M)*Msun_sec),length);
---
> 	INT4 i_ref = 0;
> 	i_ref = HGimri_start(m*Msun_sec,M*Msun_sec,q,dist*GPC_sec,Sdotn,phi0,p0,(*hplus)->data,(*hcross)->data,dt/((m+M)*Msun_sec),length);
> 
> 	//Redefine reference epoch to beginning of ringdown
> 	XLALGPSAdd(&(*hplus)->epoch,-1.*i_ref*dt);
> 	XLALGPSAdd(&(*hcross)->epoch,-1.*i_ref*dt);
1225a1238,1239
> 
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralHGimri.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralHGimri.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiral.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiral.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralOptimizedCoefficientsEccentricityFD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralOptimizedCoefficientsEccentricityFD.o
Only in .: lalsiminspiral_orbitelements.svg
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralPNCoefficients.c ./LALSimInspiralPNCoefficients.c
90a91,92
> /*  Eq. (4.6) of arXiv:1212.5520
>  */
97a100,101
> /*  Eq. (6) of arXiv:astro-ph/0504538v2
>  */
104a109,110
> /*  Eq. (6) of arXiv:astro-ph/0504538v2
>  */
111a118,119
> /*  Eq. (6) of arXiv:astro-ph/0504538v2
>  */
118a127,128
> /*  Eq. (6) of arXiv:astro-ph/0504538v2
>  */
125a136,137
> /*  Eq. 4.6 of arXiv:1212.5520
>  */
130c142,187
< 	return 5./3. + 3./mByM + 29.*mByM/9. + mByM*mByM/9.;
---
>         return 5./3. + 3./mByM + 29.*mByM/9. + mByM*mByM/9.;
> }
> 
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNS1S2Coeff(
> 	REAL8 eta)
> {
> 	return 2./eta-11./6.;
> }
> 
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNS1S2OCoeff(
> 	REAL8 eta)
> {
> 	return -11./3./eta + 2.3/1.8;
> }
> 
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNSelf2SCoeff(
> 	REAL8 mByM)
> {
> 	return -1./mByM/mByM - 1./6./mByM - 0.5;
> }
> 
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNSelf2SOCoeff(
> 	REAL8 mByM)
> {
> 	return 6./mByM/mByM - 1.5/mByM - 1.1/1.8;
> }
> 
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNQM2SCoeff(
> 	REAL8 mByM)
> {
> 	return 1.25/mByM/mByM + 1.25/mByM + 5./12.;
132a190,201
> /*  From (3.30) of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNEnergy_6PNQM2SOCoeff(
> 	REAL8 mByM)
> {
> 	return -15./4./mByM/mByM - 15./4./mByM - 1.25;
> }
> 
> /*  Eq. (4.6) of arXiv:1212.5520
>  *  Symbol definitions right above eq. (3.1)
>  */
252a322,323
> /* Eq. (4.9) of arXiv:1307.6793
>  */
274a346,349
> /* Eq. (4.9) of arXiv:1307.6793
>  * (symbol definitions around eq. 3.1)
>  */
> 
281a357,402
> /* From (4.12) of 1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNS1S2Coeff(
>     REAL8 eta)
> {
> 	return 212.3/8.4/eta + 82.1/7.2;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNS1S2OCoeff(
>     REAL8 eta)
> {
>     return -56.47/1.68/eta - 202.3/7.2;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNSelf2SCoeff(
>     REAL8 mByM)
> {
>     return 18.9/(1.6*mByM*mByM) - 3.5/(14.4*mByM) + 4.7/14.4;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNSelf2SOCoeff(
>     REAL8 mByM)
> {
>     return -239./16./mByM/mByM + 293./144./mByM + 299./144.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNQM2SCoeff(
>     REAL8 mByM)
> {
>     return  2.79/(1.12*mByM*mByM) + 4.5/(1.6*mByM) - 43./8.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralPNFlux_6PNQM2SOCoeff(
>     REAL8 mByM)
> {
>     return  -8.37/(1.12*mByM*mByM) - 13.5/(1.6*mByM) + 129./8.;
> }
> 
> /*
>  */
288a410,411
> /* Eq. (4.9) of arXiv:1307.6793
>  */
293c416
<         return (380.647/13.608) + 9535./(336.*mByM) - 40115.*mByM/756. + 3742.*mByM*mByM/63. - 35.*mByM*mByM*mByM/108. - 1117.*mByM*mByM*mByM*mByM/54.;
---
>         return (380.647/13.608) + 95.35/(3.36*mByM) - 401.15*mByM/7.56 + 3742.*mByM*mByM/63. - 35.*mByM*mByM*mByM/108. - 1117.*mByM*mByM*mByM*mByM/54.;
295a419,420
> /* Eq. (4.9) of arXiv:1307.6793
>  */
301d425
<        // see eq. (4.9) of arXiv:1307.6793
333c457
< 	const REAL8 chi1sq, /**< Magnitude of dimensionless spin 1 */
---
> 	const REAL8 chi1sq,/**< Magnitude of dimensionless spin 1 */
386a511,514
>     REAL8 pn_ss3 =  (326.75L/1.12L + 557.5L/1.8L*eta)*eta*chi1L*chi2L;
>     pn_ss3 += ((4703.5L/8.4L+2935.L/6.L*m1M-120.L*m1M*m1M)*qm_def1 + (-4108.25L/6.72L-108.5L/1.2L*m1M+125.5L/3.6L*m1M*m1M)) *m1M*m1M * chi1sq;
>     pn_ss3 += ((4703.5L/8.4L+2935.L/6.L*m2M-120.L*m2M*m2M)*qm_def2 + (-4108.25L/6.72L-108.5L/1.2L*m2M+125.5L/3.6L*m2M*m2M)) *m2M*m2M * chi2sq;
> 
388c516
<     const REAL8 pn_gamma = (554345.L/1134.L + 110.L*eta/9.L)*SL + (13915.L/84.L - 10.L*eta/3.)*dSigmaL;
---
>     const REAL8 pn_gamma = (554345.L/1134.L + 110.L*eta/9.L)*SL + (13915.L/84.L - 10.L*eta/3.L)*dSigmaL;
395c523
<             pfa->v[6] += LAL_PI * (3760.L*SL + 1490.L*dSigmaL)/3.L;
---
>             pfa->v[6] += LAL_PI * (3760.L*SL + 1490.L*dSigmaL)/3.L + pn_ss3;
612,614c740
<  * The terms 4PNSS and 4PNSSL are spin1-spin1 terms, and also depend
<  * on qm_def, the dimensionless quadrupole-monopole deformation
<  * parameter (1 for BH, larger for NS
---
>  * The terms 4PNSS and 4PNSSL are spin1-spin1 terms.
624c750
< XLALSimInspiralTaylorT2dtdv_4PNS1S2LCoeff(
---
> XLALSimInspiralTaylorT2dtdv_4PNS1S2OCoeff(
631,632c757,758
< XLALSimInspiralTaylorT2dtdv_4PNSSCoeff(
<     REAL8 mByM, REAL8 qm_def)
---
> XLALSimInspiralTaylorT2dtdv_4PNSelf2SCoeff(
>     REAL8 mByM)
634c760
<     return (5.*qm_def/2. - 7./96.)/mByM/mByM;
---
>     return - 7./96./mByM/mByM;
638,639c764,765
< XLALSimInspiralTaylorT2dtdv_4PNSSLCoeff(
<     REAL8 mByM, REAL8 qm_def)
---
> XLALSimInspiralTaylorT2dtdv_4PNSelf2SOCoeff(
>         REAL8 mByM)
641c767
<     return (-15.*qm_def/2. + 1./96.)/mByM/mByM;
---
>     return 1./96./mByM/mByM;
643a770,838
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_4PNQM2SCoeff(
>         REAL8 mByM)
> {
>         return 2.5/mByM/mByM;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_4PNQM2SOCoeff(
> 	REAL8 mByM)
> {
> 	return -7.5/mByM/mByM;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNSelf2SCoeff(
>     REAL8 mByM)
> {
>     return -37.427/(2.304*mByM*mByM) - 2.41/2.88/mByM - 5.51/2.88;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNSelf2SOCoeff(
>     REAL8 mByM)
> {
>     return 754.979/(16.128*mByM*mByM) + 15.43/2.88/mByM + 4.9/28.8;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNS1S2Coeff(
>     REAL8 eta)
> {
>     return  52.973/8.064/eta + 3.13/1.44;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNS1S2OCoeff(
>     REAL8 eta)
> {
>     return  -170.603/8.064/eta - 25.43/1.44;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNQM2SOCoeff(
>     REAL8 mByM)
> {
>     return  -94.07/(2.24*mByM*mByM) -58.7/1.6/mByM + 9.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_6PNQM2SCoeff(
>     REAL8 mByM)
> {
>     return  94.07/(6.72*mByM*mByM) + 58.7/4.8/mByM - 3.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_10PNTidalCoeff(
>         REAL8 mByM)
> {
>         return 6.*mByM*mByM*mByM*mByM * (-12.+11.*mByM);
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT2dtdv_12PNTidalCoeff(
>         REAL8 mByM)
> {
>         return mByM*mByM*mByM*mByM * (-3179/8. + 919/8.*mByM + 1143/4.*mByM*mByM - 65./2.*mByM*mByM*mByM);
> }
1007,1009c1202,1203
< static REAL8 UNUSED
< XLALSimInspiralTaylorT4wdot_4PNSelfSSCoeff(
< 	REAL8 mByM)
---
> static REAL8 UNUSED XLALSimInspiralTaylorT4wdot_4PNSelf2SCoeff(
>         REAL8 mByM)
1011c1205
< 	return 7./96./mByM/mByM;
---
>         return 7./96./mByM/mByM;
1014,1016c1208,1209
< static REAL8 UNUSED
< XLALSimInspiralTaylorT4wdot_4PNSelfSSOCoeff(
< 	REAL8 mByM)
---
> static REAL8 UNUSED XLALSimInspiralTaylorT4wdot_4PNSelf2SOCoeff(
>         REAL8 mByM)
1018c1211
< 	return -1./96./mByM/mByM;
---
>         return -1./96./mByM/mByM;
1020,1023c1213,1214
< 
< static REAL8 UNUSED
< XLALSimInspiralTaylorT4wdot_4PNQMCoeff(
< 	REAL8 mByM)
---
> static REAL8 UNUSED XLALSimInspiralTaylorT4wdot_4PNQM2SCoeff(
>         REAL8 mByM)
1025c1216
< 	return -5./2./mByM/mByM;
---
>         return -2.5/mByM/mByM;
1028,1030c1219,1220
< static REAL8 UNUSED
< XLALSimInspiralTaylorT4wdot_4PNQMSOCoeff(
< 	REAL8 mByM)
---
> static REAL8 UNUSED XLALSimInspiralTaylorT4wdot_4PNQM2SOCoeff(
>         REAL8 mByM)
1032c1222
< 	return 15./2./mByM/mByM;
---
>         return 7.5/mByM/mByM;
1083a1274,1315
> XLALSimInspiralTaylorT4wdot_6PNS1S2Coeff(
> 	REAL8 eta)
> {
> 	return 108.79/(6.72*eta) + 75.25/2.88;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT4wdot_6PNS1S2OCoeff(
> 	REAL8 eta)
> {
> 	return 162.25/(2.24*eta) -129.31/2.88;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT4wdot_6PNSelf2SCoeff(
> 	REAL8 mByM)
> {
> 	return 101.9/(6.4*mByM*mByM) + 2.51/(5.76*mByM) + 13.33/5.76;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT4wdot_6PNSelf2SOCoeff(
> 	REAL8 mByM)
> {
> 	return -49.3/(6.4*mByM*mByM) + 197.47/(5.76*mByM) + 56.45/5.76;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT4wdot_6PNQM2SCoeff(
> 	REAL8 mByM)
> {
> 	return -6.59/(2.24*mByM*mByM) + 7.3/(4.8*mByM) - 43./4.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralTaylorT4wdot_6PNQM2SOCoeff(
> 	REAL8 mByM)
> {
> 	return 19.77/(2.24*mByM*mByM) - 7.3/(1.6*mByM) + 129./4.;
> }
> 
> static REAL8 UNUSED
1131a1364,1487
> /*
>  * For L see eq. 2.9 of arxiv:gr-qc/9506022
>  */
> 
> static REAL8 UNUSED
> XLALSimInspiralLN(REAL8 M,
> 		  REAL8 eta,
> 		  REAL8 v)
> {
>         return M*M*eta/v;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralL_2PN(
>         REAL8 eta)
> {
>         return 2.5 -eta/6.;
> }
> 
> /* Orbital averaged from eq. 2.9c of
>  *arXiv:gr-qc/9506022
>  */
> static REAL8 UNUSED
> XLALSimInspiralL_3PNScoeff(
>         REAL8 mByM)
> {
>         return 0.5*(3.+1./mByM);
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralL_4PN(
>         REAL8 eta)
> {
>         return 75./8. -23.5*eta/2.4 +1.1*eta*eta/7.2;
> }
> 
> /*
>  * dLh
>  *
>  * \f$d \hat{L_N}/d \hat{t} = M * d\hat{L_N} / dt = \Omega_L x \hat{L_N}\f$
>  * This is Eq. (10) of gr-qc/0405090 ( times M b/c we use \f$\hat{t}\f$)
>  */
> 
> static REAL8 UNUSED
> XLALSimInspiralLDot_3PNSOCoeff(
>         REAL8 mByM)
> {
>         return 0.5+1.5/mByM;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralLDot_4PNS1S2Coeff(
>         REAL8 eta)
> {
>         return -1.5/eta;
> }
> 
> /* Using spin-self^2 derivatives at v^6 from
>  * eq. 2.23 of Blanchet et al. 0812.4413
>  * and relating to LNh derivative through (4.25)
>  * of arXiv:0812.4413.
>  */
> static REAL8 UNUSED
> XLALSimInspiralLDot_4PNQMSSCoeff(
>         REAL8 mByM)
> {
>         return -1.5/(mByM*mByM);
> }
> 
> /* Using spin derivatives at v^7 from
>  * eq. 7.8 of Blanchet et al. gr-qc/0605140
>  * and relating to LNh derivative through (4.25)
>  * of arXiv:0812.4413.
>  */
> static REAL8 UNUSED
> XLALSimInspiralLDot_5PNSOCoeff(
>         REAL8 mByM)
> {
>   return ( 9./8./mByM + 5./8 + 29./24.*mByM +mByM*mByM/24.);
> }
> 
> /* See eq. (A2) of arXiv:1501.01529, see also notes in
>  * https://bugs.ligo.org/redmine/issues/2xxx
>  */
> static REAL8 UNUSED
> XLALSimInspiralLDot_6PNS1S2Coeff(
>         REAL8 mByM)
> {
>         return ( -0.5/(mByM*(1.-mByM))-mByM/(1.-mByM)-2./3.);
> }
> 
> /* See eq. A.2 of arXiv:1501.01529
>  */
> static REAL8 UNUSED
> XLALSimInspiralLDot_6PNS1S1Coeff(
>         REAL8 mByM)
> {
>   return ( 15./(4.*mByM*mByM) - 1./mByM -5./12.);
> }
> 
> // See eq. (A2) of arXiv:1501.01529
> static REAL8 UNUSED
> XLALSimInspiralLDot_6PNQMSSCoeff(
>         REAL8 mByM)
> {
>         return -(2.25/(mByM*mByM) + 2.25/mByM + .75);
> }
> 
> // See (3.4) of arXiv:1212.5520
> static REAL8 UNUSED
> XLALSimInspiralLDot_7PNSOCoeff(
>         REAL8 mByM)
> {
>         return -7.5/1.6 + 2.7/(1.6*mByM) + 53.*mByM/8. + 6.7*mByM*mByM/2.4 + 1.7*mByM*mByM*mByM/4.8 - mByM*mByM*mByM*mByM/48.;
> }
> 
> /*
>  * dS1
>  * d S_1 / d \hat{t} = M * d S_1 / dt = \Omega_{S1,S2,LN,v} x S_1
>  * However, that paper uses spin variables which are M^2 times our spins
>  */
> 
> /* dS1, 1.5PN: eq. (8) of gr-qc/0405090.
>  */
1138a1495,1497
> /* S1S2 contribution
>  * see. eq. 2.23 of arXiv:0812.4413
>  */
1140c1499
< XLALSimInspiralSpinDot_4PNCoeffS1S2=0.5;
---
> XLALSimInspiralSpinDot_4PNS2Coeff=0.5;
1143c1502
< XLALSimInspiralSpinDot_4PNCoeffLS1LS2=-1.5;
---
> XLALSimInspiralSpinDot_4PNS2OCoeff=-1.5;
1144a1504,1506
> /* S1S1 contribution
>  * again eq. 2.23 of arXiv:0812.4413
>  */
1146c1508
< XLALSimInspiralSpinDot_4PNCoeffLSOSself(
---
> XLALSimInspiralSpinDot_4PNQMSOCoeff(
1149c1511
< 	return 1.5 * (1./mByM - 1.);
---
> 	return 1.5 * (1. - 1./mByM);
1151a1514,1516
> /* dS1, 2.5PN
>  * eq. 7.8 of Blanchet et al. gr-qc/0605140
>  */
1158a1524,1565
> /* dS1, 3PN
>  * eq. A1 of Bohe' et al. arXiv:1501.01529
>  * See also https://bugs.ligo.org/redmine/issues/2xxx
>  */
> static REAL8 UNUSED
> XLALSimInspiralSpinDot_6PNS1S2Coeff(
>        REAL8 mByM)
> {
>   return 0.5*mByM*mByM + 0.5*mByM;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralSpinDot_6PNS1OCoeff(
> 	REAL8 mByM)
> {
> 	return 15./4./mByM - 19./4. + 7./12.*mByM + 5.*mByM*mByM/12.;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralSpinDot_6PNS2OCoeff(
> 	REAL8 mByM)
> {
> 	return -0.5 - 2./3.*mByM - 1./3.*mByM*mByM;
> }
> 
> static REAL8 UNUSED
> XLALSimInspiralSpinDot_6PNQMSOCoeff(
> 	REAL8 mByM)
> {
>         return 0.75*mByM*mByM + 1.5*mByM -2.25/mByM;
> }
> 
> /* dS1, 3.5PN
>  * eq. 3.4 of Bohe' et al. arXiv:1212.5520
>  */
> 
> static REAL8 UNUSED
> XLALSimInspiralSpinDot_7PNCoeff(
> 	REAL8 mByM)
> {
>   return (mByM*mByM*mByM*mByM*mByM*mByM/48. - 3./8.*mByM*mByM*mByM*mByM*mByM - 3.9/1.6*mByM*mByM*mByM*mByM - 23./6.*mByM*mByM*mByM +18.1/1.6*mByM*mByM -51./8.*mByM + 2.7/1.6);
> }
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralPNMode.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralPNMode.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralPrecess.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralPrecess.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralSpinDominatedWaveform.c ./LALSimInspiralSpinDominatedWaveform.c
30a31
> #include <lal/LALSimIMR.h>
38d38
< 
44a45,47
> // TODO do not compare double with equality
> 
> static const REAL8 G_CP2 = LAL_G_SI / LAL_C_SI / LAL_C_SI;
46c49,74
< /*
---
> enum {
>     PNDEF = -1 ,PN00 = 0, PN05 = 1, PN10 = 2, PN15 =3, PN20 =4, PN25 =5, PN3 =6, PN_ORDER =7,
> };
> 
> typedef enum {
>     PHI, OMEGA, PSI, PHASE = PSI,
> } TIME_DEPENDANT;
> 
> typedef enum {
>     PLUS_ = 0, MINUS = 1, CROSS_ = 1, PLUS_MINUS_DIM = 2, PLUS_CROSS_DIM = 2,
> } COMPONENTS;
> 
> typedef enum {
>     PN00DIM = 2, PN05DIM = 11, PN10DIM = 15, PN15DIM = 17,
> } COEFFICIENT_DIMENSIONS;
> 
> typedef enum {
>     TRIGONOMETRIC_POWER = 5, AMPCOEFF_DIM = 11, OMEGA_POWER_DIM = 6, PHI_PSI_DIM = 6,
> } CONSTANTS;
> 
> #define vectorProd(lhs, rhs, denominator, result)                    \
>     result[X] = (lhs[Y] * rhs[Z] - lhs[Z] * rhs[Y]) / denominator;    \
>     result[Y] = (lhs[Z] * rhs[X] - lhs[X] * rhs[Z]) / denominator;    \
>     result[Z] = (lhs[X] * rhs[Y] - lhs[Y] * rhs[X]) / denominator;
> 
> /**
50,66c78,94
< 	REAL8 totalmass; //total mass of the binary
< 	REAL8 nu;  // mass ratio, <1
< 	REAL8 chi1; // chi1 dimensionless spin parameter
< 	REAL8 dist; // distance to the source
< 	REAL8 kappa1; // angle between L and S1
< 	REAL8 beta1;  // angle between J and S1
< 	REAL8 theta; // angle between J and N
< 	REAL8 eps; // PN paramter
< 	REAL8 xi; // second small parameter
< 	REAL8 omega;
< 	int pnamp;
< 	int pnphase;
< 	REAL8 ccoeff0pn[4];
< 	REAL8 ccoeff0_5pn[22];
< 	REAL8 ccoeff1pn[30];
< 	REAL8 ccoeff1_5pn[34];
< 	REAL8 prevdomega;
---
>     REAL8 totalmass; //total mass of the binary
>     REAL8 nu;  // mass ratio, <1
>     REAL8 chi1; // chi1 dimensionless spin parameter
>     REAL8 dist; // distance to the source
>     REAL8 kappa1; // angle between L and S1
>     REAL8 beta1;  // angle between J and S1
>     REAL8 theta; // angle between J and N
>     REAL8 eps; // PN paramter
>     REAL8 xi; // second small parameter
>     REAL8 omega;
>     int pnamp;
>     int pnphase;
>     REAL8 ccoeff00pn[4];
>     REAL8 ccoeff05pn[22];
>     REAL8 ccoeff10pn[30];
>     REAL8 ccoeff15pn[34];
>     REAL8 prevdomega;
69c97,99
< static INT4 XLALSpinDominatedWaveformStoppingTest(UNUSED REAL8 t, const REAL8 values[], REAL8 dvalues[], UNUSED void *mparams);
---
> static INT4 XLALSpinDominatedWaveformStoppingTest(UNUSED REAL8 t, const REAL8 values[], REAL8 dvalues[],
> UNUSED void *mparams);
> 
71d100
< static int XLALSpinDominatedWaveformConstantCoefficients (LALSDWaveformParams * params);
73c102,107
< /*
---
> int XLALSpinDominatedWaveformBuild(LALSDWaveformParams *params, REAL8 expr[], REAL8TimeSeries **hplus,
>         REAL8TimeSeries **hcross, int idx);
> 
> int XLALSpinDominatedWaveformConstantCoefficients(LALSDWaveformParams * params);
> 
> /**
76,83c110,117
< static REAL8 * XLALDmatrix(INT8 nrh, INT8 nch);
< 
< static REAL8 * XLALDmatrix(INT8 nrh, INT8 nch){
< INT8 size = (nrh)*(nch)*sizeof(REAL8);
< REAL8 *ptr = (REAL8 *)LALMalloc(size);
< if (ptr != NULL) return ptr;
< printf("malloc error");
< return NULL;
---
> static REAL8 *XLALDmatrix(INT8 nrh, INT8 nch) {
>     INT8 size = (nrh) * (nch) * sizeof(REAL8);
>     REAL8 *ptr = (REAL8 *) LALMalloc(size);
>     if (ptr != NULL) {
>         return ptr;
>     }
>     printf("malloc error");
>     return NULL;
89,92c123,124
< static void XLALFreeDmatrix(REAL8 *m);
< 
< static void XLALFreeDmatrix(REAL8 *m){
< LALFree(m);
---
> static void XLALFreeDmatrix(REAL8 *m) {
>     LALFree(m);
95c127
< /*
---
> /**
99,102c131
< static int XLALSpinDominatedWaveformConstantCoefficients (LALSDWaveformParams * params){
< 
< int i,j;
< REAL8 *acoeff0pn, *b0coeff0pn, *d0coeff0pn, *acoeff0_5pn, *b0coeff0_5pn, *d0coeff0_5pn, *acoeff1pn, *b0coeff1pn, *d0coeff1pn, *b1coeff1pn, *d1coeff1pn,	*acoeff1_5pn, *b0coeff1_5pn, *d0coeff1_5pn, *b1coeff1_5pn, *d1coeff1_5pn;
---
> int XLALSpinDominatedWaveformConstantCoefficients(LALSDWaveformParams * params) {
104,684c133,605
< REAL8 sk1=sin(params->kappa1);
< REAL8 sk12 = sk1 * sk1;
< REAL8 st = sin (params->theta) ;
< REAL8 st2 = st*st;
< REAL8 st4 = st2*st2;
< REAL8 ck1=cos(params->kappa1);
< REAL8 ct = cos (params->theta) ;
< REAL8 ct2 = ct*ct;
< REAL8 c2t = cos (2. * params->theta);
< REAL8 kplus = ck1-1.;
< REAL8 kmin = ck1+1.;
< 
< acoeff0pn=XLALDmatrix(2,2);
< b0coeff0pn=XLALDmatrix(2,2);
< d0coeff0pn=XLALDmatrix(2,2);
< acoeff0_5pn=XLALDmatrix(11,2);
< b0coeff0_5pn=XLALDmatrix(11,2);
< d0coeff0_5pn=XLALDmatrix(11,2);
< acoeff1pn=XLALDmatrix(15,2);
< b0coeff1pn=XLALDmatrix(15,2);
< d0coeff1pn=XLALDmatrix(15,2);
< b1coeff1pn=XLALDmatrix(15,2);
< d1coeff1pn=XLALDmatrix(15,2);
< acoeff1_5pn=XLALDmatrix(17,2);
< b0coeff1_5pn=XLALDmatrix(17,2);
< d0coeff1_5pn=XLALDmatrix(17,2);
< b1coeff1_5pn=XLALDmatrix(17,2);
< d1coeff1_5pn=XLALDmatrix(17,2);
< /*
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%   0 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< */
< acoeff0pn[0+2*0]=-2.*kplus;
< acoeff0pn[0+2*1]=2.*kmin;
< acoeff0pn[1+2*0]=-kplus;
< acoeff0pn[1+2*1]=kmin;
< b0coeff0pn[0+2*0]=-1.;
< b0coeff0pn[0+2*1]=-1.;
< b0coeff0pn[1+2*0]=-2.;
< b0coeff0pn[1+2*1]=-2.;
< d0coeff0pn[0+2*0]=0.;
< d0coeff0pn[0+2*1]=0.;
< d0coeff0pn[1+2*0]=0.;
< d0coeff0pn[1+2*1]=0.;
< for (i=0; i<=1; i++){
< 	for (j=0; j<=1; j++){
< 		params->ccoeff0pn[i+2*j] = acoeff0pn[i+2*j] + sk12*(b0coeff0pn[i+2*j]+ck1*d0coeff0pn[i+2*j]);
< 	}
< }
< /*
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%   0.5 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< */
< acoeff0_5pn[0+11*0]=4.*kplus*(6.-st2);
< acoeff0_5pn[0+11*1]=4.*kmin*(6.-st2);
< acoeff0_5pn[1+11*0]=4.*kplus;
< acoeff0_5pn[1+11*1]=4.*kmin;
< acoeff0_5pn[2+11*0]=2.*kplus*(6.-st2);
< acoeff0_5pn[2+11*1]=-2.*kmin*(6.-st2);
< acoeff0_5pn[3+11*0]=12.*kplus;
< acoeff0_5pn[3+11*1]=12.*kmin;
< acoeff0_5pn[4+11*0]=2.*kplus*(2.*st2-3.);
< acoeff0_5pn[4+11*1]=-2.*kmin*(2.*st2-3.);
< acoeff0_5pn[5+11*0]=-2.*kplus;
< acoeff0_5pn[5+11*1]=-2.*kmin;
< acoeff0_5pn[6+11*0]=-2.*params->ccoeff0pn[1+2*0]*(6.-st2);
< acoeff0_5pn[6+11*1]=2.*params->ccoeff0pn[1+2*1]*(6.-st2);
< acoeff0_5pn[7+11*0]=2.*kplus;
< acoeff0_5pn[7+11*1]=-2.*kmin;
< acoeff0_5pn[8+11*0]=(44.-34.*st2+2.*(5.*st2-46.)*ck1);
< acoeff0_5pn[8+11*1]=(44.-34.*st2-2.*(5.*st2-46.)*ck1);
< acoeff0_5pn[9+11*0]=22.+46.*ck1;
< acoeff0_5pn[9+11*1]=22.-46.*ck1;
< acoeff0_5pn[10+11*0]=-2.*kplus*(3.-2.*st2);
< acoeff0_5pn[10+11*1]=-2.*kmin*(3.-2.*st2);
< b0coeff0_5pn[0+11*0]=(46.-5.*st2);
< b0coeff0_5pn[0+11*1]=-(46.-5.*st2);
< b0coeff0_5pn[1+11*0]=3.;
< b0coeff0_5pn[1+11*1]=-3.;
< b0coeff0_5pn[2+11*0]=(2.-3.*st2);
< b0coeff0_5pn[2+11*1]=(2.-3.*st2);
< b0coeff0_5pn[3+11*0]=23.;
< b0coeff0_5pn[3+11*1]=-23.;
< b0coeff0_5pn[4+11*0]=-c2t;
< b0coeff0_5pn[4+11*1]=-c2t;
< b0coeff0_5pn[5+11*0]=-4.;
< b0coeff0_5pn[5+11*1]=4.;
< b0coeff0_5pn[6+11*0]=0.;
< b0coeff0_5pn[6+11*1]=0.;
< b0coeff0_5pn[7+11*0]=3.;
< b0coeff0_5pn[7+11*1]=3.;
< b0coeff0_5pn[8+11*0]=-15.*(2.-3.*st2);
< b0coeff0_5pn[8+11*1]=-15.*(2.-3.*st2);
< b0coeff0_5pn[9+11*0]=-15.;
< b0coeff0_5pn[9+11*1]=-15.;
< b0coeff0_5pn[10+11*0]=-4.*(3.-2.*st2);
< b0coeff0_5pn[10+11*1]=4.*(3.-2.*st2);
< d0coeff0_5pn[0+11*0]=5.*(3.*st2-2.);
< d0coeff0_5pn[0+11*1]=5.*(3.*st2-2.);
< d0coeff0_5pn[1+11*0]=-1.;
< d0coeff0_5pn[1+11*1]=-1.;
< d0coeff0_5pn[2+11*0]=0.;
< d0coeff0_5pn[2+11*1]=0.;
< d0coeff0_5pn[3+11*0]=-5.;
< d0coeff0_5pn[3+11*1]=-5.;
< d0coeff0_5pn[4+11*0]=0.;
< d0coeff0_5pn[4+11*1]=0.;
< d0coeff0_5pn[5+11*0]=3.;
< d0coeff0_5pn[5+11*1]=3.;
< d0coeff0_5pn[6+11*0]=-3.*(2.-3.*st2);
< d0coeff0_5pn[6+11*1]=-3.*(2.-3.*st2);
< d0coeff0_5pn[7+11*0]=0.;
< d0coeff0_5pn[7+11*1]=0.;
< d0coeff0_5pn[8+11*0]=0.;
< d0coeff0_5pn[8+11*1]=0.;
< d0coeff0_5pn[9+11*0]=0.;
< d0coeff0_5pn[9+11*1]=0.;
< d0coeff0_5pn[10+11*0]=3.*c2t;
< d0coeff0_5pn[10+11*1]=3.*c2t;
< for (i=0; i<=10; i++){
< 	for (j=0; j<=1; j++){
< 		params->ccoeff0_5pn[i+11*j] = acoeff0_5pn[i+11*j] + sk12*(b0coeff0_5pn[i+11*j]+ck1*d0coeff0_5pn[i+11*j]);
< 	}
< }
< /*
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%   1 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< */
< acoeff1pn[0+15*0]=8.*kplus;
< acoeff1pn[0+15*1]=-8.*kmin;
< acoeff1pn[1+15*0]=6.*kplus*(st2+5.);
< acoeff1pn[1+15*1]=6.*kmin*(st2+5.);
< acoeff1pn[2+15*0]=2.*kplus*(4.-st2);
< acoeff1pn[2+15*1]=2.*kmin*(4.-st2);
< acoeff1pn[3+15*0]=2.*kplus*(2.*st4+11.*st2-38.);
< acoeff1pn[3+15*1]=-2.*kmin*(2.*st4+11.*st2-38.);
< acoeff1pn[4+15*0]=6.*kplus*(3.*st2+5.);
< acoeff1pn[4+15*1]=6.*kmin*(3.*st2+5.);
< acoeff1pn[5+15*0]=2.*kplus*(4.*st2+19.);
< acoeff1pn[5+15*1]=-2.*kmin*(4.*st2+19.);
< acoeff1pn[6+15*0]=-2.*kplus*(3.*st2-4.);
< acoeff1pn[6+15*1]=-2.*kmin*(3.*st2-4.);
< acoeff1pn[7+15*0]=2.*kplus*(4.-st2);
< acoeff1pn[7+15*1]=-2.*kmin*(4.-st2);
< acoeff1pn[8+15*0]=6.*kplus*(5.+st2);
< acoeff1pn[8+15*1]=-6.*kmin*(5.+st2);
< acoeff1pn[9+15*0]=-4.*kplus;
< acoeff1pn[9+15*1]=4.*kmin;
< acoeff1pn[10+15*0]=kplus*(22.+29.*st2-16.*st4);
< acoeff1pn[10+15*1]=kmin*(22.+29.*st2-16.*st4);
< acoeff1pn[11+15*0]=2.*kplus;
< acoeff1pn[11+15*1]=2.*kmin;
< acoeff1pn[12+15*0]=6.*kplus*(3.*st2+5.);
< acoeff1pn[12+15*1]=-6.*kmin*(3.*st2+5.);
< acoeff1pn[13+15*0]=-kplus*(20.*st2+11.);
< acoeff1pn[13+15*1]=-kmin*(20.*st2+11.);
< acoeff1pn[14+15*0]=-2.*kplus*(3.*st2-4.);
< acoeff1pn[14+15*1]=2.*kmin*(3.*st2-4.);
< b0coeff1pn[0+15*0]=8.;
< b0coeff1pn[0+15*1]=8.;
< b0coeff1pn[1+15*0]=-18.+7.*st2;
< b0coeff1pn[1+15*1]=18.-7.*st2;
< b0coeff1pn[2+15*0]=-3.*st2+6.;
< b0coeff1pn[2+15*1]=3.*st2-6.;
< b0coeff1pn[3+15*0]=(-22.-29.*st2+16.*st4);
< b0coeff1pn[3+15*1]=(-22.-29.*st2+16.*st4);
< b0coeff1pn[4+15*0]=26.*st2-18.;
< b0coeff1pn[4+15*1]=-26.*st2+18.;
< b0coeff1pn[5+15*0]=11.+20.*st2;
< b0coeff1pn[5+15*1]=11.+20.*st2;
< b0coeff1pn[6+15*0]=-6.*st2+6.;
< b0coeff1pn[6+15*1]=6.*st2-6.;
< b0coeff1pn[7+15*0]=2.*(11.-5.*st2);
< b0coeff1pn[7+15*1]=2.*(11.-5.*st2);
< b0coeff1pn[8+15*0]=6.*(7.+9.*st2);
< b0coeff1pn[8+15*1]=6.*(7.+9.*st2);
< b0coeff1pn[9+15*0]=-11.;
< b0coeff1pn[9+15*1]=-11.;
< b0coeff1pn[10+15*0]=-3.*(8.-20.*st2+7.*st4);
< b0coeff1pn[10+15*1]=3.*(8.-20.*st2+7.*st4);
< b0coeff1pn[11+15*0]=3.;
< b0coeff1pn[11+15*1]=-3.;
< b0coeff1pn[12+15*0]=3.*(19.*st2+14.);
< b0coeff1pn[12+15*1]=3.*(19.*st2+14.);
< b0coeff1pn[13+15*0]=12.*c2t;
< b0coeff1pn[13+15*1]=-12.*c2t;
< b0coeff1pn[14+15*0]=(22.-21.*st2);
< b0coeff1pn[14+15*1]=(22.-21.*st2);
< d0coeff1pn[0+15*0]=-4.;
< d0coeff1pn[0+15*1]=4.;
< d0coeff1pn[1+15*0]=(6.-14.*st2);
< d0coeff1pn[1+15*1]=(6.-14.*st2);
< d0coeff1pn[2+15*0]=2.*(st2-1.);
< d0coeff1pn[2+15*1]=2.*(st2-1.);
< d0coeff1pn[3+15*0]=-2.*(8.-20.*st2+7.*st4);
< d0coeff1pn[3+15*1]=2.*(8.-20.*st2+7.*st4);
< d0coeff1pn[4+15*0]=(6.-7.*st2);
< d0coeff1pn[4+15*1]=(6.-7.*st2);
< d0coeff1pn[5+15*0]=(-16.*st2+8.);
< d0coeff1pn[5+15*1]=(16.*st2-8.);
< d0coeff1pn[6+15*0]=(3.*st2-2.);
< d0coeff1pn[6+15*1]=(3.*st2-2.);
< d0coeff1pn[7+15*0]=9.*(st2-2.);
< d0coeff1pn[7+15*1]=-9.*(st2-2.);
< d0coeff1pn[8+15*0]=3.*(18.-7.*st2);
< d0coeff1pn[8+15*1]=-3.*(18.-7.*st2);
< d0coeff1pn[9+15*0]=9.;
< d0coeff1pn[9+15*1]=-9.;
< d0coeff1pn[10+15*0]=4.*(2.-8.*st2+7.*st4);
< d0coeff1pn[10+15*1]=4.*(2.-8.*st2+7.*st4);
< d0coeff1pn[11+15*0]=-2.;
< d0coeff1pn[11+15*1]=-2.;
< d0coeff1pn[12+15*0]=6.*(9.-13.*st2);
< d0coeff1pn[12+15*1]=-6.*(9.-13.*st2);
< d0coeff1pn[13+15*0]=2.*(7.*st2-2.);
< d0coeff1pn[13+15*1]=2.*(7.*st2-2.);
< d0coeff1pn[14+15*0]=-18.*ct2;
< d0coeff1pn[14+15*1]=18.*ct2;
< b1coeff1pn[0+15*0]=-1.;
< b1coeff1pn[0+15*1]=-1.;
< b1coeff1pn[1+15*0]=0.;
< b1coeff1pn[1+15*1]=0.;
< b1coeff1pn[2+15*0]=0.;
< b1coeff1pn[2+15*1]=0.;
< b1coeff1pn[3+15*0]=-2.*(2.-8.*st2+7.*st4);
< b1coeff1pn[3+15*1]=-2.*(2.-8.*st2+7.*st4);
< b1coeff1pn[4+15*0]=0.;
< b1coeff1pn[4+15*1]=0.;
< b1coeff1pn[5+15*0]=(2.-7.*st2);
< b1coeff1pn[5+15*1]=(2.-7.*st2);
< b1coeff1pn[6+15*0]=0.;
< b1coeff1pn[6+15*1]=0.;
< b1coeff1pn[7+15*0]=-8.*ct2;
< b1coeff1pn[7+15*1]=-8.*ct2;
< b1coeff1pn[8+15*0]=8.*(3.-7.*st2);
< b1coeff1pn[8+15*1]=8.*(3.-7.*st2);
< b1coeff1pn[9+15*0]=4.;
< b1coeff1pn[9+15*1]=4.;
< b1coeff1pn[10+15*0]=0.;
< b1coeff1pn[10+15*1]=0.;
< b1coeff1pn[11+15*0]=0.;
< b1coeff1pn[11+15*1]=0.;
< b1coeff1pn[12+15*0]=-4.*(7.*st2-6.);
< b1coeff1pn[12+15*1]=-4.*(7.*st2-6.);
< b1coeff1pn[13+15*0]=0.;
< b1coeff1pn[13+15*1]=0.;
< b1coeff1pn[14+15*0]=-4.*(2.-3.*st2);
< b1coeff1pn[14+15*1]=-4.*(2.-3.*st2);
< for (i=0;i<15;i++){
< 	d1coeff1pn[i+15*0]=0.;
< 	d1coeff1pn[i+15*1]=0.;
< }
< for (i=0; i<=14; i++){
< 	for (j=0; j<=1; j++){
< 		params->ccoeff1pn[i+15*j] = acoeff1pn[i+15*j] + sk12*(b0coeff1pn[i+15*j]+ck1*d0coeff1pn[i+15*j]) + sk12*sk12*(b1coeff1pn[i+15*j]+ck1*d1coeff1pn[i+15*j]);
< 	}
< }
< /*
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%   1.5 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%
< %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< */
< acoeff1_5pn[0+17*0]=4.*kplus*(st2-6.);
< acoeff1_5pn[0+17*1]=-4.*kmin*(st2-6.);
< acoeff1_5pn[1+17*0]=4.*kplus*(st4+42.*st2-166.);
< acoeff1_5pn[1+17*1]=-4.*kmin*(st4+42.*st2-166.);
< acoeff1_5pn[2+17*0]=16.*kplus;
< acoeff1_5pn[2+17*1]=16.*kmin;
< acoeff1_5pn[3+17*0]=8.*kplus*(st4+8.*st2-28.);
< acoeff1_5pn[3+17*1]=8.*kmin*(st4+8.*st2-28.);
< acoeff1_5pn[4+17*0]=8.*kplus*(-332.+94.*st2+st4);
< acoeff1_5pn[4+17*1]=8.*kmin*(-332.+94.*st2+st4);
< acoeff1_5pn[5+17*0]=8.*kplus*(38.-42.*st2-9.*st4);
< acoeff1_5pn[5+17*1]=-8.*kmin*(38.-42.*st2-9.*st4);
< acoeff1_5pn[6+17*0]=-16.*kplus*(152.-46.*st2-9.*st4);
< acoeff1_5pn[6+17*1]=-16.*kmin*(152.-46.*st2-9.*st4);
< acoeff1_5pn[7+17*0]=24.*kplus*(3.*st2-10.);
< acoeff1_5pn[7+17*1]=-24.*kmin*(3.*st2-10.);
< acoeff1_5pn[8+17*0]=-8.*kplus*(160.-204.*st2-63.*st4);
< acoeff1_5pn[8+17*1]=-8.*kmin*(160.-204.*st2-63.*st4);
< acoeff1_5pn[9+17*0]=4.*kplus*(3.-2.*st2);
< acoeff1_5pn[9+17*1]=-4.*kmin*(3.-2.*st2);
< acoeff1_5pn[10+17*0]=-8.*kplus*(14.+3.*st2);
< acoeff1_5pn[10+17*1]=-8.*kmin*(14.+3.*st2);
< acoeff1_5pn[11+17*0]=-16.*kplus*(15.*st2+76.);
< acoeff1_5pn[11+17*1]=-16.*kmin*(15.*st2+76.);
< acoeff1_5pn[12+17*0]=-8.*kplus*(5.*st2+166.);
< acoeff1_5pn[12+17*1]=-8.*kmin*(5.*st2+166.);
< acoeff1_5pn[13+17*0]=-8.*kplus*(80.+63.*st2);
< acoeff1_5pn[13+17*1]=-8.*kmin*(80.+63.*st2);
< acoeff1_5pn[14+17*0]=4.*kplus*(166.-125.*st2-8.*st4);
< acoeff1_5pn[14+17*1]=-4.*kmin*(166.-125.*st2-8.*st4);
< acoeff1_5pn[15+17*0]=-8.*kplus*(38.-61.*st2-24.*st4);
< acoeff1_5pn[15+17*1]=8.*kmin*(38.-61.*st2-24.*st4);
< acoeff1_5pn[16+17*0]=8.*kplus*(5.-4.*st2);
< acoeff1_5pn[16+17*1]=-8.*kmin*(5.-4.*st2);
< b0coeff1_5pn[0+17*0]=(5.*st2-6.);
< b0coeff1_5pn[0+17*1]=(5.*st2-6.);
< b0coeff1_5pn[1+17*0]=(18.*st4+252.*st2-188.);
< b0coeff1_5pn[1+17*1]=(18.*st4+252.*st2-188.);
< b0coeff1_5pn[2+17*0]=20.;
< b0coeff1_5pn[2+17*1]=-20.;
< b0coeff1_5pn[3+17*0]=(9.*st4-90.*st2+56.);
< b0coeff1_5pn[3+17*1]=(-9.*st4+90.*st2-56.);
< b0coeff1_5pn[4+17*0]=-4.*(1184.-172.*st2-7.*st4);
< b0coeff1_5pn[4+17*1]=4.*(1184.-172.*st2-7.*st4);
< b0coeff1_5pn[5+17*0]=2.*(46.+48.*st2-99.*st4);
< b0coeff1_5pn[5+17*1]=2.*(46.+48.*st2-99.*st4);
< b0coeff1_5pn[6+17*0]=-12.*(72.+110.*st2-63.*st4);
< b0coeff1_5pn[6+17*1]=12.*(72.+110.*st2-63.*st4);
< b0coeff1_5pn[7+17*0]=144.*(st2-2.);
< b0coeff1_5pn[7+17*1]=144.*(st2-2.);
< b0coeff1_5pn[8+17*0]=-3.*(-204.+406.*st2-189.*st4);
< b0coeff1_5pn[8+17*1]=3.*(-204.+406.*st2-189.*st4);
< b0coeff1_5pn[9+17*0]=3.-4.*st2;
< b0coeff1_5pn[9+17*1]=3.-4.*st2;
< b0coeff1_5pn[10+17*0]=28.-31.*st2;
< b0coeff1_5pn[10+17*1]=-28.+31.*st2;
< b0coeff1_5pn[11+17*0]=-432.-876.*st2;
< b0coeff1_5pn[11+17*1]=432.+876.*st2;
< b0coeff1_5pn[12+17*0]=-4.*(71.*st2+592.);
< b0coeff1_5pn[12+17*1]=4.*(71.*st2+592.);
< b0coeff1_5pn[13+17*0]=306.-651.*st2;
< b0coeff1_5pn[13+17*1]=-306.+651.*st2;
< b0coeff1_5pn[14+17*0]=2.*(94.-173.*st2-24.*st4);
< b0coeff1_5pn[14+17*1]=2.*(94.-173.*st2-24.*st4);
< b0coeff1_5pn[15+17*0]=-2.*(46.+25.*st2-180.*st4);
< b0coeff1_5pn[15+17*1]=-2.*(46.+25.*st2-180.*st4);
< b0coeff1_5pn[16+17*0]=48.*ct2;
< b0coeff1_5pn[16+17*1]=48.*ct2;
< d0coeff1_5pn[0+17*0]=0.;
< d0coeff1_5pn[0+17*1]=0.;
< d0coeff1_5pn[1+17*0]=(-6.*st4+72.*st2-20.);
< d0coeff1_5pn[1+17*1]=(+6.*st4-72.*st2+20.);
< d0coeff1_5pn[2+17*0]=-12.;
< d0coeff1_5pn[2+17*1]=-12.;
< d0coeff1_5pn[3+17*0]=(-15.*st4+22.*st2-8.);
< d0coeff1_5pn[3+17*1]=(-15.*st4+22.*st2-8.);
< d0coeff1_5pn[4+17*0]=(1920.-2832.*st2-84.*st4);
< d0coeff1_5pn[4+17*1]=(1920.-2832.*st2-84.*st4);
< d0coeff1_5pn[5+17*0]=6.*(10.-44.*st2+27.*st4);
< d0coeff1_5pn[5+17*1]=-6.*(10.-44.*st2+27.*st4);
< d0coeff1_5pn[6+17*0]=-4.*(88.-422.*st2+171.*st4);
< d0coeff1_5pn[6+17*1]=-4.*(88.-422.*st2+171.*st4);
< d0coeff1_5pn[7+17*0]=+12.*(14.-9.*st2);
< d0coeff1_5pn[7+17*1]=-12.*(14.-9.*st2);
< d0coeff1_5pn[8+17*0]=-9.*(28.-126.*st2+105.*st4);
< d0coeff1_5pn[8+17*1]=-9.*(28.-126.*st2+105.*st4);
< d0coeff1_5pn[9+17*0]=0.;
< d0coeff1_5pn[9+17*1]=0.;
< d0coeff1_5pn[10+17*0]=(9.*st2-4.);
< d0coeff1_5pn[10+17*1]=(9.*st2-4.);
< d0coeff1_5pn[11+17*0]=(-176.+756.*st2);
< d0coeff1_5pn[11+17*1]=(-176.+756.*st2);
< d0coeff1_5pn[12+17*0]=12.*(7.*st2+80.);
< d0coeff1_5pn[12+17*1]=12.*(7.*st2+80.);
< d0coeff1_5pn[13+17*0]=(-126.+189.*st2);
< d0coeff1_5pn[13+17*1]=(-126.+189.*st2);
< d0coeff1_5pn[14+17*0]=2.*(10.-41.*st2+36.*st4);
< d0coeff1_5pn[14+17*1]=-2.*(10.-41.*st2+36.*st4);
< d0coeff1_5pn[15+17*0]=-6.*(10.-49.*st2+44.*st4);
< d0coeff1_5pn[15+17*1]=6.*(10.-49.*st2+44.*st4);
< d0coeff1_5pn[16+17*0]=-4.*(7.-8.*st2);
< d0coeff1_5pn[16+17*1]=4.*(7.-8.*st2);
< b1coeff1_5pn[0+17*0]=0.;
< b1coeff1_5pn[0+17*1]=0.;
< b1coeff1_5pn[1+17*0]=(-15.*st4+12.*st2-2.);
< b1coeff1_5pn[1+17*1]=(-15.*st4+12.*st2-2.);
< b1coeff1_5pn[2+17*0]=-5.;
< b1coeff1_5pn[2+17*1]=5.;
< b1coeff1_5pn[3+17*0]=0.;
< b1coeff1_5pn[3+17*1]=0.;
< b1coeff1_5pn[4+17*0]=-(236.-294.*st2+21.*st4);
< b1coeff1_5pn[4+17*1]=(236.-294.*st2+21.*st4);
< b1coeff1_5pn[5+17*0]=3.*(6.-36.*st2+45.*st4);
< b1coeff1_5pn[5+17*1]=3.*(6.-36.*st2+45.*st4);
< b1coeff1_5pn[6+17*0]=-3.*(232.-510.*st2+243.*st4);
< b1coeff1_5pn[6+17*1]=3.*(232.-510.*st2+243.*st4);
< b1coeff1_5pn[7+17*0]=9.*(6.-5.*st2);
< b1coeff1_5pn[7+17*1]=9.*(6.-5.*st2);
< b1coeff1_5pn[8+17*0]=0.;
< b1coeff1_5pn[8+17*1]=0.;
< b1coeff1_5pn[9+17*0]=0.;
< b1coeff1_5pn[9+17*1]=0.;
< b1coeff1_5pn[10+17*0]=0.;
< b1coeff1_5pn[10+17*1]=0.;
< b1coeff1_5pn[11+17*0]=(-348.+591.*st2);
< b1coeff1_5pn[11+17*1]=(+348.-591.*st2);
< b1coeff1_5pn[12+17*0]=(273.*st2-118.);
< b1coeff1_5pn[12+17*1]=(-273.*st2+118.);
< b1coeff1_5pn[13+17*0]=0.;
< b1coeff1_5pn[13+17*1]=0.;
< b1coeff1_5pn[14+17*0]=(2.-13.*st2+12.*st4);
< b1coeff1_5pn[14+17*1]=(2.-13.*st2+12.*st4);
< b1coeff1_5pn[15+17*0]=-9.*(2.-13.*st2+12.*st4);
< b1coeff1_5pn[15+17*1]=-9.*(2.-13.*st2+12.*st4);
< b1coeff1_5pn[16+17*0]=-3.*(3.-4.*st2);
< b1coeff1_5pn[16+17*1]=-3.*(3.-4.*st2);
< d1coeff1_5pn[0+17*0]=0.;
< d1coeff1_5pn[0+17*1]=0.;
< d1coeff1_5pn[1+17*0]=0.;
< d1coeff1_5pn[1+17*1]=0.;
< d1coeff1_5pn[2+17*0]=1.;
< d1coeff1_5pn[2+17*1]=1.;
< d1coeff1_5pn[3+17*0]=0.;
< d1coeff1_5pn[3+17*1]=0.;
< d1coeff1_5pn[4+17*0]=(28.-126.*st2+105.*st4);
< d1coeff1_5pn[4+17*1]=(28.-126.*st2+105.*st4);
< d1coeff1_5pn[5+17*0]=0.;
< d1coeff1_5pn[5+17*1]=0.;
< d1coeff1_5pn[6+17*0]=27.*(8.-22.*st2+15.*st4);
< d1coeff1_5pn[6+17*1]=27.*(8.-22.*st2+15.*st4);
< d1coeff1_5pn[7+17*0]=0.;
< d1coeff1_5pn[7+17*1]=0.;
< d1coeff1_5pn[8+17*0]=0.;
< d1coeff1_5pn[8+17*1]=0.;
< d1coeff1_5pn[9+17*0]=0.;
< d1coeff1_5pn[9+17*1]=0.;
< d1coeff1_5pn[10+17*0]=0.;
< d1coeff1_5pn[10+17*1]=0.;
< d1coeff1_5pn[11+17*0]=(-243.*st2+108.);
< d1coeff1_5pn[11+17*1]=(-243.*st2+108.);
< d1coeff1_5pn[12+17*0]=7.*(2.-3.*st2);
< d1coeff1_5pn[12+17*1]=7.*(2.-3.*st2);
< d1coeff1_5pn[13+17*0]=0.;
< d1coeff1_5pn[13+17*1]=0.;
< d1coeff1_5pn[14+17*0]=0.;
< d1coeff1_5pn[14+17*1]=0.;
< d1coeff1_5pn[15+17*0]=0.;
< d1coeff1_5pn[15+17*1]=0.;
< d1coeff1_5pn[16+17*0]=0.;
< d1coeff1_5pn[16+17*1]=0.;
< for (i=0; i<=16; i++){
< 	for (j=0; j<=1; j++){
< 		params->ccoeff1_5pn[i+17*j] = acoeff1_5pn[i+17*j] + sk12*(b0coeff1_5pn[i+17*j]+ck1*d0coeff1_5pn[i+17*j]) + sk12*sk12*(b1coeff1_5pn[i+17*j]+ck1*d1coeff1_5pn[i+17*j]);
< 	}
< }
< XLALFreeDmatrix(acoeff0pn);
< XLALFreeDmatrix(b0coeff0pn);
< XLALFreeDmatrix(d0coeff0pn);
< XLALFreeDmatrix(acoeff0_5pn);
< XLALFreeDmatrix(b0coeff0_5pn);
< XLALFreeDmatrix(d0coeff0_5pn);
< XLALFreeDmatrix(acoeff1pn);
< XLALFreeDmatrix(b0coeff1pn);
< XLALFreeDmatrix(d0coeff1pn);
< XLALFreeDmatrix(b1coeff1pn);
< XLALFreeDmatrix(d1coeff1pn);
< XLALFreeDmatrix(acoeff1_5pn);
< XLALFreeDmatrix(b0coeff1_5pn);
< XLALFreeDmatrix(d0coeff1_5pn);
< XLALFreeDmatrix(b1coeff1_5pn);
< XLALFreeDmatrix(d1coeff1_5pn);
< return XLAL_SUCCESS;
< }
< 
< /*
< * Function building the wavefrom from the calculated parameters at a given time
< * For the formulae see the appendix of Arxiv:1209.1722
< */
< static int XLALSpinDominatedWaveformBuild (LALSDWaveformParams *params, REAL8 expr[], REAL8TimeSeries **hplus, REAL8TimeSeries **hcross, int idx);
< 
< static int XLALSpinDominatedWaveformBuild (
< 	LALSDWaveformParams *params,  		/**< The SDW parameters */
< 	REAL8 expr[], 				/**< The 3 time dependent variables of the waveform at the time indexed by idx */
< 	REAL8TimeSeries **hplus,        	/**< +-polarization waveform */
< 	REAL8TimeSeries **hcross,      		/**< x-polarization waveform */
< 	int idx					/**< \todo UNDOCUMENTED */
< )
< {
< REAL8 *waveampcoeffs;
< REAL8 ampcoeff;
< REAL8 chi1_1=params->chi1;
< REAL8 sk1=sin(params->kappa1);
< REAL8 sk12 = sk1 * sk1;
< REAL8 sk13 = sk12 * sk1;
< REAL8 sk14 = sk12 * sk12;
< REAL8 s2k1=sin( 2. * params->kappa1);
< REAL8 st = sin (params->theta) ;
< REAL8 st2 = st*st;
< REAL8 st3 = st2*st;
< REAL8 s2t = sin (2.* params->theta);
< REAL8 st4 = st2*st2;
< REAL8 ck1=cos(params->kappa1);
< REAL8 c2k1=cos(2. * params->kappa1);
< REAL8 ck12 = ck1 * ck1;
< REAL8 ct = cos (params->theta) ;
< REAL8 ct2 = ct*ct;
< REAL8 c2t = cos (2. * params->theta);
< REAL8 kplus = ck1-1.;
< REAL8 kmin = ck1+1.;
< REAL8 omega0=1;
< REAL8 v=cbrt(LAL_G_SI*params->totalmass*expr[1]/LAL_C_SI/LAL_C_SI/LAL_C_SI);
< params->eps=v*v;
< REAL8 eps0pn1pncorr, eps0_5pn1pncorr, eps0pn1_5pncorr;
< eps0_5pn1pncorr=params->eps*(1.+v*v*(1.-params->nu/(1.+ params->nu)/(1.+ params->nu)/3.)+v*v*v*(params->nu/(1.+ params->nu)/(1.+ params->nu)+2./3./(1.+ params->nu)/(1.+ params->nu)));
< eps0pn1pncorr=params->eps*(1.+v*v*(1.-params->nu/(1.+ params->nu)/(1.+ params->nu)/3.)+v*v*v*(params->nu/(1.+ params->nu)/(1.+ params->nu)+2./3./(1.+ params->nu)/(1.+ params->nu)));
< eps0pn1_5pncorr=params->eps*(1.+v*v*(1.-params->nu/(1.+ params->nu)/(1.+ params->nu)/3.)+v*v*v*(params->nu/(1.+ params->nu)/(1.+ params->nu)+2./3./(1.+ params->nu)/(1.+ params->nu))+v*v*v*v*(1.-65./12.*params->nu/(1.+ params->nu)/(1.+ params->nu)-params->chi1*params->chi1*params->nu*params->nu/(1.+ params->nu)/(1.+ params->nu)*(3.*ck12-1.)/4.));
< params->xi=params->nu/sqrt(params->eps); // second small parameter
< waveampcoeffs=XLALDmatrix(11,2); // amplitude coefficients
< REAL8 epssqrt=sqrt(params->eps);
< REAL8 phin_1=expr[0];
< REAL8 phin_2=2.*expr[0];
< REAL8 phin_3=3.*expr[0];
< REAL8 phin_4=4.*expr[0];
< REAL8 phin_5=5.*expr[0];
< REAL8 phi1_1=LAL_PI/2.;
< REAL8 psi_1 = 1. * expr[2];
< REAL8 psi_2 = 2. * expr[2];
< REAL8 psi_3 = 3. * expr[2];
< REAL8 psi_4 = 4. * expr[2];
< REAL8 psi_5 = 5. * expr[2];
< /*
<  computing the coefficients
< */
< (*hplus)->data->data[idx]=0.;
< (*hcross)->data->data[idx]=0.;
< ampcoeff=LAL_G_SI*params->totalmass/LAL_C_SI/LAL_C_SI*params->eps*epssqrt*params->xi*2./params->dist;
< switch (params->pnamp) {
< 	case (3):
< 	waveampcoeffs[8+11*0]=1./12288.*(12.*ct*sk1*st2*(cos(psi_3)*(1701.*(2.-3.*st2)*sk14+72.*sk12*(63.*st2+178.))+cos(psi_1)*(-14.*(2.-3.*st2)*sk14-8.*sk12*(7.*st2+162.)+16.*(st2+66.))-4375.*(2.-3.*st2)*sk14*cos(psi_5))+(2.*(st2-2.)*sk14*st3*(sin(phin_5+psi_1)*kplus+sin(phin_5-psi_1)*kmin)+4.*ct*sk13*st2*(cos(phin_4+psi_1)*params->ccoeff1_5pn[0+17*0]+cos(phin_4-psi_1)*params->ccoeff1_5pn[0+17*1])+16.*ct*sk1*(cos(phin_2+psi_1)*params->ccoeff1_5pn[1+17*0]+cos(phin_2-psi_1)*params->ccoeff1_5pn[1+17*1])+1250.*sk14*st*(105.*st4-126.*st2+28.)*(sin(phin_1+psi_5)*kplus+sin(phin_1-psi_5)*kmin)+625.*(st2-2.)*st3*(sin(phin_5+psi_5)*params->ccoeff1_5pn[2+17*0]+sin(phin_5-psi_5)*params->ccoeff1_5pn[2+17*1])+6.*sk12*st*(sin(phin_3+psi_1)*params->ccoeff1_5pn[3+17*0]+sin(phin_3-psi_1)*params->ccoeff1_5pn[3+17*1])+243.*(st2-2.)*sk12*st3*(sin(phin_5+psi_3)*params->ccoeff0_5pn[1+11*0]+sin(phin_5-psi_3)*params->ccoeff0_5pn[1+11*1])+4.*st*(sin(phin_1+psi_1)*params->ccoeff1_5pn[4+17*0]+sin(phin_1-psi_1)*params->ccoeff1_5pn[4+17*1])+5000.*ct*sk13*(15.*st4-12.*st2+2.)*(cos(phin_2+psi_5)*params->ccoeff0pn[0+2*0]+cos(phin_2-psi_5)*params->ccoeff0pn[0+2*1])-1250.*ct*sk1*st2*(5.*st2-6.)*(cos(phin_4+psi_5)*params->ccoeff1pn[0+15*0]+cos(phin_4-psi_5)*params->ccoeff1pn[0+15*1])+1875.*sk12*st*(8.-22.*st2+15.*st4)*(sin(phin_3+psi_5)*params->ccoeff0_5pn[1+11*0]+sin(phin_3-psi_5)*params->ccoeff0_5pn[1+11*1])+216.*ct*sk1*(cos(phin_2+psi_3)*params->ccoeff1_5pn[5+17*0]+cos(phin_2-psi_3)*params->ccoeff1_5pn[5+17*1])+27.*st*(sin(phin_3+psi_3)*params->ccoeff1_5pn[6+17*0]+sin(phin_3-psi_3)*params->ccoeff1_5pn[6+17*1])+54.*ct*sk1*st2*(cos(phin_4+psi_3)*params->ccoeff1_5pn[7+17*0]+cos(phin_4-psi_3)*params->ccoeff1_5pn[7+17*1])+54.*sk12*st*(sin(phin_1+psi_3)*params->ccoeff1_5pn[8+17*0]+sin(phin_1-psi_3)*params->ccoeff1_5pn[8+17*1])));
< 	waveampcoeffs[8+11*1]=1./6144.*(192.*ck1*sk1*st2*(sin(psi_1)*(64.-sk12*(7.*st2-6.)+4.*st2)+27.*sin(psi_3)*sk12*(7.*st2-6.))+(4.*sk13*st2*(sin(phin_4+psi_1)*params->ccoeff1_5pn[9+17*0]+sin(phin_4-psi_1)*params->ccoeff1_5pn[9+17*1])-2.*ct*sk14*st3*(cos(phin_5+psi_1)*kplus+cos(phin_5-psi_1)*kmin)-243.*ct*sk12*st3*(cos(phin_5+psi_3)*params->ccoeff0_5pn[1+11*0]+cos(phin_5-psi_3)*params->ccoeff0_5pn[1+11*1])-625.*ct*st3*(cos(phin_5+psi_5)*params->ccoeff1_5pn[2+17*0]+cos(phin_5-psi_5)*params->ccoeff1_5pn[2+17*1])+3.*sk12*s2t*(cos(phin_3+psi_1)*params->ccoeff1_5pn[10+17*0]+cos(phin_3-psi_1)*params->ccoeff1_5pn[10+17*1])+27.*ct*st*(cos(phin_3+psi_3)*params->ccoeff1_5pn[11+17*0]+cos(phin_3-psi_3)*params->ccoeff1_5pn[11+17*1])+1875.*ct*sk12*st*(4.-9.*st2)*(cos(phin_3+psi_5)*params->ccoeff0_5pn[1+11*0]+cos(phin_3-psi_5)*params->ccoeff0_5pn[1+11*1])+2.*s2t*(cos(phin_1+psi_1)*params->ccoeff1_5pn[12+17*0]+cos(phin_1-psi_1)*params->ccoeff1_5pn[12+17*1])+27.*sk12*s2t*(cos(phin_1+psi_3)*params->ccoeff1_5pn[13+17*0]+cos(phin_1-psi_3)*params->ccoeff1_5pn[13+17*1])+8.*sk1*(sin(phin_2+psi_1)*params->ccoeff1_5pn[14+17*0]+sin(phin_2-psi_1)*params->ccoeff1_5pn[14+17*1])+4375.*(2.-3.*st2)*sk14*s2t*(cos(phin_1+psi_5)*kplus+cos(phin_1-psi_5)*kmin)+108.*sk1*(sin(phin_2+psi_3)*params->ccoeff1_5pn[15+17*0]+sin(phin_2-psi_3)*params->ccoeff1_5pn[15+17*1])+162.*sk1*st2*(sin(phin_4+psi_3)*params->ccoeff1_5pn[16+17*0]+sin(phin_4-psi_3)*params->ccoeff1_5pn[16+17*1])-2500.*sk13*(2.-13.*st2+12.*st4)*(sin(phin_2+psi_5)*params->ccoeff0pn[0+2*0]+sin(phin_2-psi_5)*params->ccoeff0pn[0+2*1])-1250.*sk1*st2*(3.-4.*st2)*(sin(phin_4+psi_5)*params->ccoeff1pn[0+15*0]+sin(phin_4-psi_5)*params->ccoeff1pn[0+15*1])));
< 	waveampcoeffs[9+11*0]=chi1_1/2.*(4.*sk1*(ck1*sk1*cos(phin_2)-c2k1*ct*sin(phin_1)*st+ck1*sk1*st2*(6.*sin(psi_1)*sin(psi_1)-2.+sin(phin_1)*sin(phin_1)))+(2.*ct*sk1*st*((-3.*kplus-4.*sk12)*sin(phin_1+psi_2)+(3.*kmin-4.*sk12)*sin(phin_1-psi_2))+(st2-2.)*((-2.*kplus+(2.*ck1-3.)*sk12)*cos(phin_2+psi_2)+(-2.*kmin+(2.*ck1+3.)*sk12)*cos(phin_2-psi_2))));
< 	waveampcoeffs[9+11*1]=chi1_1*(-2.*cos(phin_1)*sk1*(st*c2k1+ct*s2k1*sin(phin_1))+(ct*((-2.*kplus+(2.*ck1-3.)*sk12)*sin(phin_2+psi_2)+(-2.*kmin+(2.*ck1+3.)*sk12)*sin(phin_2-psi_2))+sk1*st*((-3.*kplus-4.*sk12)*cos(phin_1+psi_2)+(3.*kmin-4.*sk12)*cos(phin_1-psi_2))));
< 	waveampcoeffs[10+11*0]=LAL_PI/2.*(6.*sk12*st2*cos(psi_2)+((st2-2.)*(cos(phin_2+psi_2)*params->ccoeff0pn[0+2*0]+cos(phin_2-psi_2)*params->ccoeff0pn[0+2*1])-2.*sk1*s2t*(sin(phin_1+psi_2)*kplus+sin(phin_1-psi_2)*kmin)))	+3.*log(expr[1]/omega0)*(4.*ct*sk1*st*(-kmin*cos(phin_1-psi_2)+kplus*cos(phin_1+psi_2))+(-st2+2.)*(2.*ck1-sk12+2.)*sin(phin_2-psi_2)+(2.*ck1+sk12-2.)*sin(phin_2+psi_2)+6.*sk12*sin(psi_2)*st2);
< 	waveampcoeffs[10+11*1]=LAL_PI*(ct*(sin(phin_2+psi_2)*params->ccoeff0pn[0+2*0]+sin(phin_2-psi_2)*params->ccoeff0pn[0+2*1])-2.*sk1*st*(cos(phin_1+psi_2)*kplus+cos(phin_1-psi_2)*kmin))+6.*log(expr[1]/omega0)*((2.*ck1-sk12+2.)*ct*cos(phin_2-psi_2)+(2.*ck1+sk12-2.)*ct*cos(phin_2+psi_2)+kmin*2.*sk1*st*sin(phin_1-psi_2)-kplus*2.*sk1*st*sin(phin_1+psi_2));
< 	// Highest order, only leading order of eps(omega) is needed.
< 	(*hplus)->data->data[idx]+=ampcoeff*(params->eps*epssqrt*(waveampcoeffs[8+11*0]+waveampcoeffs[9+11*0]+waveampcoeffs[10+11*0]));
< 	(*hcross)->data->data[idx]+=ampcoeff*(params->eps*epssqrt*(waveampcoeffs[8+11*1]+waveampcoeffs[9+11*1]+waveampcoeffs[10+11*1]));
< 	case (2):
< 	waveampcoeffs[4+11*0]=1./48.*(2.*sk12*st2*(5.*sk12*(7.*st2-6.)*(cos(psi_2)-4.*cos(psi_4))-2.*(15.*st2+51.)*cos(psi_2))+(16.*sk13*s2t*(7.*st2-3.)*(sin(phin_1+psi_4)*kplus+sin(phin_1-psi_4)*kmin)-(st2-2.)*sk12*st2*(cos(phin_4+psi_2)*params->ccoeff0pn[0+2*0]+cos(phin_4-psi_2)*params->ccoeff0pn[0+2*1])+4.*(st2-2.)*st2*(cos(phin_4+psi_4)*params->ccoeff1pn[0+15*0]+cos(phin_4-psi_4)*params->ccoeff1pn[0+15*1])+2.*sk1*s2t*((sin(phin_1+psi_2)*params->ccoeff1pn[1+15*0]+sin(phin_1-psi_2)*params->ccoeff1pn[1+15*1])+(sin(phin_3+psi_2)*params->ccoeff1pn[2+15*0]+sin(phin_3-psi_2)*params->ccoeff1pn[2+15*1])-8.*ct2*(sin(phin_3+psi_4)*params->ccoeff0_5pn[1+11*0]+sin(phin_3-psi_4)*params->ccoeff0_5pn[1+11*1]))+2.*(cos(phin_2+psi_2)*params->ccoeff1pn[3+15*0]+cos(phin_2-psi_2)*params->ccoeff1pn[3+15*1])-16.*sk12*(7.*st4-2.*(4.*st2-1.))*(cos(phin_2+psi_4)*params->ccoeff0pn[0+2*0]+cos(phin_2-psi_4)*params->ccoeff0pn[0+2*1])));
< 	waveampcoeffs[4+11*1]=1./24.*(60.*ck1*ct*sk12*sin(psi_2)*st2+(8.*sk13*st*(7.*st2-6.)*(cos(phin_1+psi_4)*kplus+cos(phin_1-psi_4)*kmin)-ct*sk12*st2*(sin(phin_4+psi_2)*params->ccoeff0pn[0+2*0]+sin(phin_4-psi_2)*params->ccoeff0pn[0+2*1])+2.*sk1*st*(cos(phin_1+psi_2)*params->ccoeff1pn[4+15*0]+cos(phin_1-psi_2)*params->ccoeff1pn[4+15*1])+4.*ct*st2*(sin(phin_4+psi_4)*params->ccoeff1pn[0+15*0]+sin(phin_4-psi_4)*params->ccoeff1pn[0+15*0])+2.*ct*(sin(phin_2+psi_2)*params->ccoeff1pn[5+15*0]+sin(phin_2-psi_2)*params->ccoeff1pn[5+15*1])-8.*ct*sk12*(7.*st2-2.)*(sin(phin_2+psi_4)*params->ccoeff0pn[0+2*0]+sin(phin_2-psi_4)*params->ccoeff0pn[0+2*1])-8.*(2.-3.*st2)*sk1*st*(cos(phin_3+psi_4)*params->ccoeff0_5pn[1+11*0]+cos(phin_3-psi_4)*params->ccoeff0_5pn[1+11*1])+2.*sk1*st*(cos(phin_3+psi_2)*params->ccoeff1pn[6+15*0]+cos(phin_3-psi_2)*params->ccoeff1pn[6+15*1])));
< 	waveampcoeffs[5+11*0]=1./24.*(ck1*sk1*st2*(4.*(15.*st2+51.)*cos(psi_2)+20.*sk12*(7.*st2-6.)*(4.*cos(psi_4)-cos(psi_2)))+(s2t*(sin(phin_3+psi_2)*params->ccoeff1pn[7+15*0]+sin(phin_3-psi_2)*params->ccoeff1pn[7+15*1])+s2t*(sin(phin_1+psi_2)*params->ccoeff1pn[8+15*0]+sin(phin_1-psi_2)*params->ccoeff1pn[8+15*1])+ct2*s2t*8.*(sin(phin_3+psi_4)*params->ccoeff1pn[9+15*0]+sin(phin_3-psi_4)*params->ccoeff1pn[9+15*1])+2.*sk1*(cos(phin_2+psi_2)*params->ccoeff1pn[10+15*0]+cos(phin_2-psi_2)*params->ccoeff1pn[10+15*1])+8.*sk12*s2t*(7.*st2-3.)*(sin(phin_1+psi_4)*(3.*kplus+4.*sk12)+sin(phin_1-psi_4)*(-3.*kmin+4.*sk12))+16.*sk1*(2.-8.*st2+7.*st4)*(cos(phin_2+psi_4)*params->ccoeff1pn[11+15*0]+cos(phin_2-psi_4)*params->ccoeff1pn[11+15*1])+sk1*st2*(st2-2.)*(cos(phin_4+psi_2)*params->ccoeff1pn[11+15*0]+cos(phin_4-psi_2)*params->ccoeff1pn[11+15*1]-8.*(cos(phin_4+psi_4)*params->ccoeff0_5pn[1+11*0]+cos(phin_4-psi_4)*params->ccoeff0_5pn[1+11*1]))));
< 	waveampcoeffs[5+11*1]=1./12.*(30.*ct*sk1*sin(psi_2)*st2*(3.*sk12-2.)+(st*(cos(phin_1+psi_2)*params->ccoeff1pn[12+15*0]+cos(phin_1-psi_2)*params->ccoeff1pn[12+15*1])+2.*ct*sk1*((sin(phin_2+psi_2)*params->ccoeff1pn[13+15*0]+sin(phin_2-psi_2)*params->ccoeff1pn[13+15*1])+4.*(7.*st2-2.)*(sin(phin_2+psi_4)*params->ccoeff1pn[11+15*0]+sin(phin_2-psi_4)*params->ccoeff1pn[11+15*1]))+ct*sk1*st2*((sin(phin_4+psi_2)*params->ccoeff1pn[11+15*0]+sin(phin_4-psi_2)*params->ccoeff1pn[11+15*1])-8.*(sin(phin_4+psi_4)*params->ccoeff0_5pn[1+11*0]+sin(phin_4-psi_4)*params->ccoeff0_5pn[1+11*1]))+st*((cos(phin_3+psi_2)*params->ccoeff1pn[14+15*0]+cos(phin_3-psi_2)*params->ccoeff1pn[14+15*1])+4.*(2.-3.*st2)*(cos(phin_3+psi_4)*params->ccoeff1pn[9+15*0]+cos(phin_3-psi_4)*params->ccoeff1pn[9+15*1]))+4.*sk12*st*(6.-7.*st2)*((-3.*kplus-4.*sk12)*cos(phin_1+psi_4)+(+3.*kmin-4.*sk12)*cos(phin_1-psi_4))));
< 	waveampcoeffs[6+11*0]=chi1_1/2.*st*(kplus*sin(phin_1+psi_1)-kmin*sin(phin_1-psi_1));
< 	waveampcoeffs[6+11*1]=chi1_1/2.*st*(2.*sk1*sin(psi_1)*st+ct*(kplus*cos(phin_1+psi_1)-kmin*cos(phin_1-psi_1)));
< 	waveampcoeffs[7+11*0]=chi1_1/2.*((-kplus*ct*sin(phin_2+psi_1-phi1_1)+kmin*ct*sin(phin_2-psi_1-phi1_1))+sk1*st*(sin(phin_1+psi_1)-sin(phin_1-psi_1)
< +cos(phin_1+psi_1-phi1_1)-cos(phin_1-psi_1-phi1_1)));
< 	waveampcoeffs[7+11*1]=chi1_1/4.*(-st2*(2.*(sin(phi1_1)+2.)*ck1*sin(psi_1)+2.*cos(phi1_1)*cos(psi_1))+(2.*ct*sk1*st*(cos(phin_1+psi_1)-cos(phin_1-psi_1)-sin(phin_1+psi_1-phi1_1)+sin(phin_1-psi_1-phi1_1))+(st2-2.)*(kplus*cos(phin_2+psi_1-phi1_1)-kmin*cos(phin_2-psi_1-phi1_1))));
< 	// Since highest order is 1.5 PN and there is no 0.5 PN order correction to eps(omega), leading order eps is enough.
< 	(*hplus)->data->data[idx]+=ampcoeff*(params->eps*(waveampcoeffs[4+11*0]+waveampcoeffs[2+11*0]*4.*params->xi+params->beta1*waveampcoeffs[5+11*0]+waveampcoeffs[6+11*0]+waveampcoeffs[7+11*0]*params->beta1));
< 	(*hcross)->data->data[idx]+=ampcoeff*(params->eps*(waveampcoeffs[4+11*1]+waveampcoeffs[2+11*1]*4.*params->xi+params->beta1*waveampcoeffs[5+11*1]+waveampcoeffs[6+11*1]+waveampcoeffs[7+11*1]*params->beta1));
< 	case (1):
< 	waveampcoeffs[2+11*0]=1./64.*(4.*ct*sk1*st2*(-45.*sk12*cos(psi_3)+cos(psi_1)*(5.*sk12-4.))-sk12*st*((st2-2.)*(sin(phin_3+psi_1)*kplus+sin(phin_3-psi_1)*kmin)-45.*(2.-3.*st2)*(sin(phin_1+psi_3)*kplus+sin(phin_1-psi_3)*kmin))+st*(sin(phin_1+psi_1)*params->ccoeff0_5pn[0+11*0]+sin(phin_1-psi_1)*params->ccoeff0_5pn[0+11*1]-9.*(st2-2.)*(sin(phin_3+psi_3)*params->ccoeff0_5pn[1+11*0]+sin(phin_3-psi_3)*params->ccoeff0_5pn[1+11*1]))+2.*ct*sk1*(cos(phin_2+psi_1)*params->ccoeff0_5pn[2+11*0]+cos(phin_2-psi_1)*params->ccoeff0_5pn[2+11*1]+9.*(2-3.*st2)*(cos(phin_2+psi_3)*params->ccoeff0pn[0+2*0]+cos(phin_2-psi_3)*params->ccoeff0pn[0+2*1])));
< 	waveampcoeffs[2+11*1]=1./32.*(-16.*s2k1*st2*sin(psi_1)+ct*st*sk12*(cos(phin_3+psi_1)*kplus+cos(phin_3-psi_1)*kmin+45.*(cos(phin_1+psi_3)*kplus+cos(phin_1-psi_3)*kmin))+0.5*s2t*(cos(phin_1+psi_1)*params->ccoeff0_5pn[3+11*0]+cos(phin_1-psi_1)*params->ccoeff0_5pn[3+11*1]+9.*(cos(phin_3+psi_3)*params->ccoeff0_5pn[1+11*0]+cos(phin_3-psi_3)*params->ccoeff0_5pn[1+11*1]))+2.*sk1*(sin(phin_2+psi_1)*params->ccoeff0_5pn[4+11*0]+sin(phin_2-psi_1)*params->ccoeff0_5pn[4+11*1]-9.*c2t*(sin(phin_2+psi_3)*params->ccoeff0pn[0+2*0]+sin(phin_2-psi_3)*params->ccoeff0pn[0+2*1])));
< 	waveampcoeffs[3+11*0]=1./64.*(4.*ck1*ct*st2*(135.*cos(psi_3)*sk12+cos(psi_1)*(4.-15.*sk12))+(2.*ct*(9.*(2.-3.*st2)*(cos(phin_2+psi_3)*params->ccoeff0_5pn[5+11*0]+cos(phin_2-psi_3)*params->ccoeff0_5pn[5+11*1])+cos(phin_2+psi_1)*params->ccoeff0_5pn[6+11*0]+cos(phin_2-psi_1)*params->ccoeff0_5pn[6+11*1])-sk1*st*(st2-2.)*(27.*(sin(phin_3+psi_3)*params->ccoeff0pn[0+2*0]+sin(phin_3-psi_3)*params->ccoeff0pn[0+2*0])+sin(phin_3+psi_1)*params->ccoeff0_5pn[7+11*0]+sin(phin_3-psi_1)*params->ccoeff0_5pn[7+11*1])+sk1*st*(45.*(2.-3.*st2)*(sin(phin_1+psi_3)*params->ccoeff0_5pn[7+11*0]+sin(phin_1-psi_3)*params->ccoeff0_5pn[7+11*1])+sin(phin_1+psi_1)*params->ccoeff0_5pn[8+11*0]+sin(phin_1-psi_1)*params->ccoeff0_5pn[8+11*1])));
< 	waveampcoeffs[3+11*1]=1./32.*(32.*sin(psi_1)*st2*c2k1+(ct*sk1*st*(27.*(cos(phin_3+psi_3)*params->ccoeff0pn[0+2*0]+cos(phin_3-psi_3)*params->ccoeff0pn[0+2*1])+(cos(phin_3+psi_1)+45.*cos(phin_1+psi_3))*params->ccoeff0_5pn[7+11*0]+(cos(phin_3-psi_1)+45*cos(phin_1-psi_3))*params->ccoeff0_5pn[7+11*1]+(params->ccoeff0_5pn[9+11*0]*cos(phin_1+psi_1)+params->ccoeff0_5pn[9+11*1]*cos(phin_1-psi_1)))-(18.*c2t)*(sin(phin_2+psi_3)*params->ccoeff0_5pn[5+11*0]+sin(phin_2-psi_3)*params->ccoeff0_5pn[5+11*1])-2.*(sin(phin_2+psi_1)*params->ccoeff0_5pn[10+11*0]+sin(phin_2-psi_1)*params->ccoeff0_5pn[10+11*1])));
< 	//The 0.5 PN correction needs to include 1 PN correction of eps(omega) the amplitude is taken to 1.5 PN order
< 	if (params->pnamp == 3){
< 	(*hplus)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*(eps0_5pn1pncorr*eps0_5pn1pncorr*(waveampcoeffs[2+11*0]+params->beta1*waveampcoeffs[3+11*0]-2.*params->xi*waveampcoeffs[0+11*0]));
< 	(*hcross)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*(eps0_5pn1pncorr*eps0_5pn1pncorr*(waveampcoeffs[2+11*1]+params->beta1*waveampcoeffs[3+11*1]-2.*params->xi*waveampcoeffs[0+11*1]));
< 	}
< 	else{
< 	(*hplus)->data->data[idx]+=ampcoeff*(epssqrt*(waveampcoeffs[2+11*0]+params->beta1*waveampcoeffs[3+11*0]-2.*params->xi*waveampcoeffs[0+11*0]));
< 	(*hcross)->data->data[idx]+=ampcoeff*(epssqrt*(waveampcoeffs[2+11*1]+params->beta1*waveampcoeffs[3+11*1]-2.*params->xi*waveampcoeffs[0+11*1]));
< 	}
< 	case (0):
< 	waveampcoeffs[0+11*0]=0.25*((st2-2.)*(cos(phin_2+psi_2)*params->ccoeff0pn[0+2*0]+cos(phin_2-psi_2)*params->ccoeff0pn[0+2*1])-2.*sk1*s2t*(sin(phin_1+psi_2)*kplus+sin(phin_1-psi_2)*kmin)+6.*sk12*st2*cos(psi_2));
< 	waveampcoeffs[0+11*1]=0.5*(ct*(sin(phin_2+psi_2)*params->ccoeff0pn[0+2*0]+sin(phin_2-psi_2)*params->ccoeff0pn[0+2*1])-2.*st*sk1*(cos(phin_1+psi_2)*kplus+cos(phin_1-psi_2)*kmin));
< 	waveampcoeffs[1+11*0]=0.5*(s2t*(sin(phin_1+psi_2)*params->ccoeff0pn[1+2*0]+sin(phin_1-psi_2)*params->ccoeff0pn[1+2*1])+sk1*(st2-2.)*(cos(phin_2+psi_2)*kplus+cos(phin_2-psi_2)*kmin)-3.*s2k1*st2*cos(psi_2));
< 	waveampcoeffs[1+11*1]=ct*sk1*(sin(phin_2+psi_2)*kplus+sin(phin_2-psi_2)*kmin)+st*(cos(phin_1+psi_2)*params->ccoeff0pn[1+2*0]+cos(phin_1-psi_2)*params->ccoeff0pn[1+2*1]);
< 	// If the amplitude is taken to 1 PN order, the eps(omega) needs to include the 1 PN correction, if amplitude is taken to 1.5 PN order, that eps(omega) needs to include corrections up to 1.5 PN order
< 	if (params->pnamp == 3){
< 	(*hplus)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*eps0pn1_5pncorr*sqrt(eps0pn1_5pncorr)*(waveampcoeffs[0+11*0]+params->beta1*waveampcoeffs[1+11*0]);
< 	(*hcross)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*eps0pn1_5pncorr*sqrt(eps0pn1_5pncorr)*(waveampcoeffs[0+11*1]+params->beta1*waveampcoeffs[1+11*1]);
< 	}
< 	else if (params->pnamp == 2){
< 	(*hplus)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*eps0pn1_5pncorr*sqrt(eps0pn1pncorr)*(waveampcoeffs[0+11*0]+params->beta1*waveampcoeffs[1+11*0]);
< 	(*hcross)->data->data[idx]+=ampcoeff/(params->eps*epssqrt)*eps0pn1_5pncorr*sqrt(eps0pn1pncorr)*(waveampcoeffs[0+11*1]+params->beta1*waveampcoeffs[1+11*1]);
< 	}
< 	else{
< 	(*hplus)->data->data[idx]+=ampcoeff*(waveampcoeffs[0+11*0]+params->beta1*waveampcoeffs[1+11*0]);
< 	(*hcross)->data->data[idx]+=ampcoeff*(waveampcoeffs[0+11*1]+params->beta1*waveampcoeffs[1+11*1]);
< 	}
< 	break;
< }
< XLALFreeDmatrix(waveampcoeffs);
< return XLAL_SUCCESS;
---
>     int i, j;
>     REAL8 *acoeff00pn, *b0coeff0pn, *d0coeff0pn, *acoeff0_5pn, *b0coeff0_5pn, *d0coeff0_5pn, *acoeff1pn, *b0coeff1pn,
>             *d0coeff1pn, *b1coeff1pn, *d1coeff1pn, *acoeff1_5pn, *b0coeff1_5pn, *d0coeff1_5pn, *b1coeff1_5pn,
>             *d1coeff1_5pn;
> 
>     REAL8 skp[TRIGONOMETRIC_POWER], ckp[TRIGONOMETRIC_POWER], stp[TRIGONOMETRIC_POWER], ctp[TRIGONOMETRIC_POWER];
>     skp[0] = ckp[0] = stp[0] = ctp[0] = 1.;
>     skp[1] = sin(params->kappa1);
>     ckp[1] = cos(params->kappa1);
>     stp[1] = sin(params->theta);
>     ctp[1] = cos(params->theta);
>     for (i = 2; i < TRIGONOMETRIC_POWER; ++i) {
>         skp[i] = skp[1] * skp[i - 1];
>         ckp[i] = ckp[1] * ckp[i - 1];
>         stp[i] = stp[1] * stp[i - 1];
>         ctp[i] = ctp[1] * ctp[i - 1];
>     }
>     REAL8 k[PLUS_MINUS_DIM] = { ckp[1] - 1., ckp[1] + 1. };
>     REAL8 c2t = cos(2. * params->theta);
> 
>     // TODO inner variables can be rewritten into multidimensional arrays
>     // TODO can be separated into different functions according to pn order
>     acoeff00pn = XLALDmatrix(PN00DIM, PLUS_MINUS_DIM);
>     b0coeff0pn = XLALDmatrix(PN00DIM, PLUS_MINUS_DIM);
>     d0coeff0pn = XLALDmatrix(PN00DIM, PLUS_MINUS_DIM);
>     acoeff0_5pn = XLALDmatrix(PN05DIM, PLUS_MINUS_DIM);
>     b0coeff0_5pn = XLALDmatrix(PN05DIM, PLUS_MINUS_DIM);
>     d0coeff0_5pn = XLALDmatrix(PN05DIM, PLUS_MINUS_DIM);
>     acoeff1pn = XLALDmatrix(PN10DIM, PLUS_MINUS_DIM);
>     b0coeff1pn = XLALDmatrix(PN10DIM, PLUS_MINUS_DIM);
>     d0coeff1pn = XLALDmatrix(PN10DIM, PLUS_MINUS_DIM);
>     b1coeff1pn = XLALDmatrix(PN10DIM, PLUS_MINUS_DIM);
>     d1coeff1pn = XLALDmatrix(PN10DIM, PLUS_MINUS_DIM);
>     acoeff1_5pn = XLALDmatrix(PN15DIM, PLUS_MINUS_DIM);
>     b0coeff1_5pn = XLALDmatrix(PN15DIM, PLUS_MINUS_DIM);
>     d0coeff1_5pn = XLALDmatrix(PN15DIM, PLUS_MINUS_DIM);
>     b1coeff1_5pn = XLALDmatrix(PN15DIM, PLUS_MINUS_DIM);
>     d1coeff1_5pn = XLALDmatrix(PN15DIM, PLUS_MINUS_DIM);
>     /*
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%   0 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      */
>     acoeff00pn[0 + PN00DIM * PLUS_] = -2. * k[PLUS_];
>     acoeff00pn[0 + PN00DIM * MINUS] = +2. * k[MINUS];
>     acoeff00pn[1 + PN00DIM * PLUS_] = -k[PLUS_];
>     acoeff00pn[1 + PN00DIM * MINUS] = +k[MINUS];
>     b0coeff0pn[0 + PN00DIM * PLUS_] = -1.;
>     b0coeff0pn[0 + PN00DIM * MINUS] = -1.;
>     b0coeff0pn[1 + PN00DIM * PLUS_] = -2.;
>     b0coeff0pn[1 + PN00DIM * MINUS] = -2.;
>     d0coeff0pn[0 + PN00DIM * PLUS_] = +0.;
>     d0coeff0pn[0 + PN00DIM * MINUS] = +0.;
>     d0coeff0pn[1 + PN00DIM * PLUS_] = +0.;
>     d0coeff0pn[1 + PN00DIM * MINUS] = +0.;
>     for (i = 0; i <= 1; i++) {
>         for (j = 0; j <= 1; j++) {
>             params->ccoeff00pn[i + PN00DIM * j] = acoeff00pn[i + PN00DIM * j]
>                     + skp[2] * (b0coeff0pn[i + PN00DIM * j] + ckp[1] * d0coeff0pn[i + PN00DIM * j]);
>         }
>     }
>     /*
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%   0.5 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      */
>     acoeff0_5pn[0 + PN05DIM * PLUS_] = +4. * k[PLUS_] * (6. - stp[2]);
>     acoeff0_5pn[0 + PN05DIM * MINUS] = +4. * k[MINUS] * (6. - stp[2]);
>     acoeff0_5pn[1 + PN05DIM * PLUS_] = +4. * k[PLUS_];
>     acoeff0_5pn[1 + PN05DIM * MINUS] = +4. * k[MINUS];
>     acoeff0_5pn[2 + PN05DIM * PLUS_] = +2. * k[PLUS_] * (6. - stp[2]);
>     acoeff0_5pn[2 + PN05DIM * MINUS] = -2. * k[MINUS] * (6. - stp[2]);
>     acoeff0_5pn[3 + PN05DIM * PLUS_] = 12. * k[PLUS_];
>     acoeff0_5pn[3 + PN05DIM * MINUS] = 12. * k[MINUS];
>     acoeff0_5pn[4 + PN05DIM * PLUS_] = +2. * k[PLUS_] * (2. * stp[2] - 3.);
>     acoeff0_5pn[4 + PN05DIM * MINUS] = -2. * k[MINUS] * (2. * stp[2] - 3.);
>     acoeff0_5pn[5 + PN05DIM * PLUS_] = -2. * k[PLUS_];
>     acoeff0_5pn[5 + PN05DIM * MINUS] = -2. * k[MINUS];
>     acoeff0_5pn[6 + PN05DIM * PLUS_] = -2. * params->ccoeff00pn[1 + PN00DIM * PLUS_] * (6. - stp[2]);
>     acoeff0_5pn[6 + PN05DIM * MINUS] = +2. * params->ccoeff00pn[1 + PN00DIM * MINUS] * (6. - stp[2]);
>     acoeff0_5pn[7 + PN05DIM * PLUS_] = +2. * k[PLUS_];
>     acoeff0_5pn[7 + PN05DIM * MINUS] = -2. * k[MINUS];
>     acoeff0_5pn[8 + PN05DIM * PLUS_] = (44. - 34. * stp[2] + 2. * (5. * stp[2] - 46.) * ckp[1]);
>     acoeff0_5pn[8 + PN05DIM * MINUS] = (44. - 34. * stp[2] - 2. * (5. * stp[2] - 46.) * ckp[1]);
>     acoeff0_5pn[9 + PN05DIM * PLUS_] = 22. + 46. * ckp[1];
>     acoeff0_5pn[9 + PN05DIM * MINUS] = 22. - 46. * ckp[1];
>     acoeff0_5pn[10 + PN05DIM * PLUS_] = -2. * k[PLUS_] * (3. - 2. * stp[2]);
>     acoeff0_5pn[10 + PN05DIM * MINUS] = -2. * k[MINUS] * (3. - 2. * stp[2]);
>     b0coeff0_5pn[0 + PN05DIM * PLUS_] = +(46. - 5. * stp[2]);
>     b0coeff0_5pn[0 + PN05DIM * MINUS] = -(46. - 5. * stp[2]);
>     b0coeff0_5pn[1 + PN05DIM * PLUS_] = +3.;
>     b0coeff0_5pn[1 + PN05DIM * MINUS] = -3.;
>     b0coeff0_5pn[2 + PN05DIM * PLUS_] = (2. - 3. * stp[2]);
>     b0coeff0_5pn[2 + PN05DIM * MINUS] = (2. - 3. * stp[2]);
>     b0coeff0_5pn[3 + PN05DIM * PLUS_] = +23.;
>     b0coeff0_5pn[3 + PN05DIM * MINUS] = -23.;
>     b0coeff0_5pn[4 + PN05DIM * PLUS_] = -c2t;
>     b0coeff0_5pn[4 + PN05DIM * MINUS] = -c2t;
>     b0coeff0_5pn[5 + PN05DIM * PLUS_] = -4.;
>     b0coeff0_5pn[5 + PN05DIM * MINUS] = +4.;
>     b0coeff0_5pn[6 + PN05DIM * PLUS_] = +0.;
>     b0coeff0_5pn[6 + PN05DIM * MINUS] = +0.;
>     b0coeff0_5pn[7 + PN05DIM * PLUS_] = +3.;
>     b0coeff0_5pn[7 + PN05DIM * MINUS] = +3.;
>     b0coeff0_5pn[8 + PN05DIM * PLUS_] = -15. * (2. - 3. * stp[2]);
>     b0coeff0_5pn[8 + PN05DIM * MINUS] = -15. * (2. - 3. * stp[2]);
>     b0coeff0_5pn[9 + PN05DIM * PLUS_] = -15.;
>     b0coeff0_5pn[9 + PN05DIM * MINUS] = -15.;
>     b0coeff0_5pn[10 + PN05DIM * PLUS_] = -4. * (3. - 2. * stp[2]);
>     b0coeff0_5pn[10 + PN05DIM * MINUS] = +4. * (3. - 2. * stp[2]);
>     d0coeff0_5pn[0 + PN05DIM * PLUS_] = +5. * (3. * stp[2] - 2.);
>     d0coeff0_5pn[0 + PN05DIM * MINUS] = +5. * (3. * stp[2] - 2.);
>     d0coeff0_5pn[1 + PN05DIM * PLUS_] = -1.;
>     d0coeff0_5pn[1 + PN05DIM * MINUS] = -1.;
>     d0coeff0_5pn[2 + PN05DIM * PLUS_] = +0.;
>     d0coeff0_5pn[2 + PN05DIM * MINUS] = +0.;
>     d0coeff0_5pn[3 + PN05DIM * PLUS_] = -5.;
>     d0coeff0_5pn[3 + PN05DIM * MINUS] = -5.;
>     d0coeff0_5pn[4 + PN05DIM * PLUS_] = +0.;
>     d0coeff0_5pn[4 + PN05DIM * MINUS] = +0.;
>     d0coeff0_5pn[5 + PN05DIM * PLUS_] = +3.;
>     d0coeff0_5pn[5 + PN05DIM * MINUS] = +3.;
>     d0coeff0_5pn[6 + PN05DIM * PLUS_] = -3. * (2. - 3. * stp[2]);
>     d0coeff0_5pn[6 + PN05DIM * MINUS] = -3. * (2. - 3. * stp[2]);
>     d0coeff0_5pn[7 + PN05DIM * PLUS_] = +0.;
>     d0coeff0_5pn[7 + PN05DIM * MINUS] = +0.;
>     d0coeff0_5pn[8 + PN05DIM * PLUS_] = +0.;
>     d0coeff0_5pn[8 + PN05DIM * MINUS] = +0.;
>     d0coeff0_5pn[9 + PN05DIM * PLUS_] = +0.;
>     d0coeff0_5pn[9 + PN05DIM * MINUS] = +0.;
>     d0coeff0_5pn[10 + PN05DIM * PLUS_] = +3. * c2t;
>     d0coeff0_5pn[10 + PN05DIM * MINUS] = +3. * c2t;
>     for (i = 0; i <= 10; i++) {
>         for (j = 0; j <= 1; j++) {
>             params->ccoeff05pn[i + PN05DIM * j] = acoeff0_5pn[i + PN05DIM * j]
>                     + skp[2] * (b0coeff0_5pn[i + PN05DIM * j] + ckp[1] * d0coeff0_5pn[i + PN05DIM * j]);
>         }
>     }
>     /*
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%   1 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      */
>     acoeff1pn[0 + PN10DIM * PLUS_] = +8. * k[PLUS_];
>     acoeff1pn[0 + PN10DIM * MINUS] = -8. * k[MINUS];
>     acoeff1pn[1 + PN10DIM * PLUS_] = +6. * k[PLUS_] * (stp[2] + 5.);
>     acoeff1pn[1 + PN10DIM * MINUS] = +6. * k[MINUS] * (stp[2] + 5.);
>     acoeff1pn[2 + PN10DIM * PLUS_] = +2. * k[PLUS_] * (4. - stp[2]);
>     acoeff1pn[2 + PN10DIM * MINUS] = +2. * k[MINUS] * (4. - stp[2]);
>     acoeff1pn[3 + PN10DIM * PLUS_] = +2. * k[PLUS_] * (2. * stp[4] + 11. * stp[2] - 38.);
>     acoeff1pn[3 + PN10DIM * MINUS] = -2. * k[MINUS] * (2. * stp[4] + 11. * stp[2] - 38.);
>     acoeff1pn[4 + PN10DIM * PLUS_] = +6. * k[PLUS_] * (3. * stp[2] + 5.);
>     acoeff1pn[4 + PN10DIM * MINUS] = +6. * k[MINUS] * (3. * stp[2] + 5.);
>     acoeff1pn[5 + PN10DIM * PLUS_] = +2. * k[PLUS_] * (4. * stp[2] + 19.);
>     acoeff1pn[5 + PN10DIM * MINUS] = -2. * k[MINUS] * (4. * stp[2] + 19.);
>     acoeff1pn[6 + PN10DIM * PLUS_] = -2. * k[PLUS_] * (3. * stp[2] - 4.);
>     acoeff1pn[6 + PN10DIM * MINUS] = -2. * k[MINUS] * (3. * stp[2] - 4.);
>     acoeff1pn[7 + PN10DIM * PLUS_] = +2. * k[PLUS_] * (4. - stp[2]);
>     acoeff1pn[7 + PN10DIM * MINUS] = -2. * k[MINUS] * (4. - stp[2]);
>     acoeff1pn[8 + PN10DIM * PLUS_] = +6. * k[PLUS_] * (5. + stp[2]);
>     acoeff1pn[8 + PN10DIM * MINUS] = -6. * k[MINUS] * (5. + stp[2]);
>     acoeff1pn[9 + PN10DIM * PLUS_] = -4. * k[PLUS_];
>     acoeff1pn[9 + PN10DIM * MINUS] = +4. * k[MINUS];
>     acoeff1pn[10 + PN10DIM * PLUS_] = k[PLUS_] * (22. + 29. * stp[2] - 16. * stp[4]);
>     acoeff1pn[10 + PN10DIM * MINUS] = k[MINUS] * (22. + 29. * stp[2] - 16. * stp[4]);
>     acoeff1pn[11 + PN10DIM * PLUS_] = +2. * k[PLUS_];
>     acoeff1pn[11 + PN10DIM * MINUS] = +2. * k[MINUS];
>     acoeff1pn[12 + PN10DIM * PLUS_] = +6. * k[PLUS_] * (3. * stp[2] + 5.);
>     acoeff1pn[12 + PN10DIM * MINUS] = -6. * k[MINUS] * (3. * stp[2] + 5.);
>     acoeff1pn[13 + PN10DIM * PLUS_] = -k[PLUS_] * (20. * stp[2] + 11.);
>     acoeff1pn[13 + PN10DIM * MINUS] = -k[MINUS] * (20. * stp[2] + 11.);
>     acoeff1pn[14 + PN10DIM * PLUS_] = -2. * k[PLUS_] * (3. * stp[2] - 4.);
>     acoeff1pn[14 + PN10DIM * MINUS] = +2. * k[MINUS] * (3. * stp[2] - 4.);
>     b0coeff1pn[0 + PN10DIM * PLUS_] = +8.;
>     b0coeff1pn[0 + PN10DIM * MINUS] = +8.;
>     b0coeff1pn[1 + PN10DIM * PLUS_] = -18. + 7. * stp[2];
>     b0coeff1pn[1 + PN10DIM * MINUS] = +18. - 7. * stp[2];
>     b0coeff1pn[2 + PN10DIM * PLUS_] = -3. * stp[2] + 6.;
>     b0coeff1pn[2 + PN10DIM * MINUS] = +3. * stp[2] - 6.;
>     b0coeff1pn[3 + PN10DIM * PLUS_] = (-22. - 29. * stp[2] + 16. * stp[4]);
>     b0coeff1pn[3 + PN10DIM * MINUS] = (-22. - 29. * stp[2] + 16. * stp[4]);
>     b0coeff1pn[4 + PN10DIM * PLUS_] = +26. * stp[2] - 18.;
>     b0coeff1pn[4 + PN10DIM * MINUS] = -26. * stp[2] + 18.;
>     b0coeff1pn[5 + PN10DIM * PLUS_] = +11. + 20. * stp[2];
>     b0coeff1pn[5 + PN10DIM * MINUS] = +11. + 20. * stp[2];
>     b0coeff1pn[6 + PN10DIM * PLUS_] = -6. * stp[2] + 6.;
>     b0coeff1pn[6 + PN10DIM * MINUS] = +6. * stp[2] - 6.;
>     b0coeff1pn[7 + PN10DIM * PLUS_] = +2. * (11. - 5. * stp[2]);
>     b0coeff1pn[7 + PN10DIM * MINUS] = +2. * (11. - 5. * stp[2]);
>     b0coeff1pn[8 + PN10DIM * PLUS_] = +6. * (7. + 9. * stp[2]);
>     b0coeff1pn[8 + PN10DIM * MINUS] = +6. * (7. + 9. * stp[2]);
>     b0coeff1pn[9 + PN10DIM * PLUS_] = -11.;
>     b0coeff1pn[9 + PN10DIM * MINUS] = -11.;
>     b0coeff1pn[10 + PN10DIM * PLUS_] = -3. * (8. - 20. * stp[2] + 7. * stp[4]);
>     b0coeff1pn[10 + PN10DIM * MINUS] = +3. * (8. - 20. * stp[2] + 7. * stp[4]);
>     b0coeff1pn[11 + PN10DIM * PLUS_] = +3.;
>     b0coeff1pn[11 + PN10DIM * MINUS] = -3.;
>     b0coeff1pn[12 + PN10DIM * PLUS_] = +3. * (19. * stp[2] + 14.);
>     b0coeff1pn[12 + PN10DIM * MINUS] = +3. * (19. * stp[2] + 14.);
>     b0coeff1pn[13 + PN10DIM * PLUS_] = +12. * c2t;
>     b0coeff1pn[13 + PN10DIM * MINUS] = -12. * c2t;
>     b0coeff1pn[14 + PN10DIM * PLUS_] = (22. - 21. * stp[2]);
>     b0coeff1pn[14 + PN10DIM * MINUS] = (22. - 21. * stp[2]);
>     d0coeff1pn[0 + PN10DIM * PLUS_] = -4.;
>     d0coeff1pn[0 + PN10DIM * MINUS] = +4.;
>     d0coeff1pn[1 + PN10DIM * PLUS_] = (6. - 14. * stp[2]);
>     d0coeff1pn[1 + PN10DIM * MINUS] = (6. - 14. * stp[2]);
>     d0coeff1pn[2 + PN10DIM * PLUS_] = +2. * (stp[2] - 1.);
>     d0coeff1pn[2 + PN10DIM * MINUS] = +2. * (stp[2] - 1.);
>     d0coeff1pn[3 + PN10DIM * PLUS_] = -2. * (8. - 20. * stp[2] + 7. * stp[4]);
>     d0coeff1pn[3 + PN10DIM * MINUS] = +2. * (8. - 20. * stp[2] + 7. * stp[4]);
>     d0coeff1pn[4 + PN10DIM * PLUS_] = (6. - 7. * stp[2]);
>     d0coeff1pn[4 + PN10DIM * MINUS] = (6. - 7. * stp[2]);
>     d0coeff1pn[5 + PN10DIM * PLUS_] = (-16. * stp[2] + 8.);
>     d0coeff1pn[5 + PN10DIM * MINUS] = (+16. * stp[2] - 8.);
>     d0coeff1pn[6 + PN10DIM * PLUS_] = (3. * stp[2] - 2.);
>     d0coeff1pn[6 + PN10DIM * MINUS] = (3. * stp[2] - 2.);
>     d0coeff1pn[7 + PN10DIM * PLUS_] = +9. * (stp[2] - 2.);
>     d0coeff1pn[7 + PN10DIM * MINUS] = -9. * (stp[2] - 2.);
>     d0coeff1pn[8 + PN10DIM * PLUS_] = +3. * (18. - 7. * stp[2]);
>     d0coeff1pn[8 + PN10DIM * MINUS] = -3. * (18. - 7. * stp[2]);
>     d0coeff1pn[9 + PN10DIM * PLUS_] = +9.;
>     d0coeff1pn[9 + PN10DIM * MINUS] = -9.;
>     d0coeff1pn[10 + PN10DIM * PLUS_] = +4. * (2. - 8. * stp[2] + 7. * stp[4]);
>     d0coeff1pn[10 + PN10DIM * MINUS] = +4. * (2. - 8. * stp[2] + 7. * stp[4]);
>     d0coeff1pn[11 + PN10DIM * PLUS_] = -2.;
>     d0coeff1pn[11 + PN10DIM * MINUS] = -2.;
>     d0coeff1pn[12 + PN10DIM * PLUS_] = +6. * (9. - 13. * stp[2]);
>     d0coeff1pn[12 + PN10DIM * MINUS] = -6. * (9. - 13. * stp[2]);
>     d0coeff1pn[13 + PN10DIM * PLUS_] = +2. * (7. * stp[2] - 2.);
>     d0coeff1pn[13 + PN10DIM * MINUS] = +2. * (7. * stp[2] - 2.);
>     d0coeff1pn[14 + PN10DIM * PLUS_] = -18. * ctp[2];
>     d0coeff1pn[14 + PN10DIM * MINUS] = +18. * ctp[2];
>     b1coeff1pn[0 + PN10DIM * PLUS_] = -1.;
>     b1coeff1pn[0 + PN10DIM * MINUS] = -1.;
>     b1coeff1pn[1 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[1 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[2 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[2 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[3 + PN10DIM * PLUS_] = -2. * (2. - 8. * stp[2] + 7. * stp[4]);
>     b1coeff1pn[3 + PN10DIM * MINUS] = -2. * (2. - 8. * stp[2] + 7. * stp[4]);
>     b1coeff1pn[4 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[4 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[5 + PN10DIM * PLUS_] = (2. - 7. * stp[2]);
>     b1coeff1pn[5 + PN10DIM * MINUS] = (2. - 7. * stp[2]);
>     b1coeff1pn[6 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[6 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[7 + PN10DIM * PLUS_] = -8. * ctp[2];
>     b1coeff1pn[7 + PN10DIM * MINUS] = -8. * ctp[2];
>     b1coeff1pn[8 + PN10DIM * PLUS_] = +8. * (3. - 7. * stp[2]);
>     b1coeff1pn[8 + PN10DIM * MINUS] = +8. * (3. - 7. * stp[2]);
>     b1coeff1pn[9 + PN10DIM * PLUS_] = +4.;
>     b1coeff1pn[9 + PN10DIM * MINUS] = +4.;
>     b1coeff1pn[10 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[10 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[11 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[11 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[12 + PN10DIM * PLUS_] = -4. * (7. * stp[2] - 6.);
>     b1coeff1pn[12 + PN10DIM * MINUS] = -4. * (7. * stp[2] - 6.);
>     b1coeff1pn[13 + PN10DIM * PLUS_] = +0.;
>     b1coeff1pn[13 + PN10DIM * MINUS] = +0.;
>     b1coeff1pn[14 + PN10DIM * PLUS_] = -4. * (2. - 3. * stp[2]);
>     b1coeff1pn[14 + PN10DIM * MINUS] = -4. * (2. - 3. * stp[2]);
>     for (i = 0; i < 15; i++) {
>         d1coeff1pn[i + PN10DIM * PLUS_] = +0.;
>         d1coeff1pn[i + PN10DIM * MINUS] = +0.;
>     }
>     for (i = 0; i <= 14; i++) {
>         for (j = 0; j <= 1; j++) {
>             params->ccoeff10pn[i + PN10DIM * j] = acoeff1pn[i + PN10DIM * j]
>                     + skp[2] * (b0coeff1pn[i + PN10DIM * j] + ckp[1] * d0coeff1pn[i + PN10DIM * j])
>                     + skp[4] * (b1coeff1pn[i + PN10DIM * j] + ckp[1] * d1coeff1pn[i + PN10DIM * j]);
>         }
>     }
>     /*
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%   1.5 PN   %%%%%%%%%%%%%%%%%%%%%%%%%%%
>      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>      */
>     acoeff1_5pn[0 + PN15DIM * PLUS_] = +4. * k[PLUS_] * (stp[2] - 6.);
>     acoeff1_5pn[0 + PN15DIM * MINUS] = -4. * k[MINUS] * (stp[2] - 6.);
>     acoeff1_5pn[1 + PN15DIM * PLUS_] = +4. * k[PLUS_] * (stp[4] + 42. * stp[2] - 166.);
>     acoeff1_5pn[1 + PN15DIM * MINUS] = -4. * k[MINUS] * (stp[4] + 42. * stp[2] - 166.);
>     acoeff1_5pn[2 + PN15DIM * PLUS_] = +16. * k[PLUS_];
>     acoeff1_5pn[2 + PN15DIM * MINUS] = +16. * k[MINUS];
>     acoeff1_5pn[3 + PN15DIM * PLUS_] = +8. * k[PLUS_] * (stp[4] + 8. * stp[2] - 28.);
>     acoeff1_5pn[3 + PN15DIM * MINUS] = +8. * k[MINUS] * (stp[4] + 8. * stp[2] - 28.);
>     acoeff1_5pn[4 + PN15DIM * PLUS_] = +8. * k[PLUS_] * (-332. + 94. * stp[2] + stp[4]);
>     acoeff1_5pn[4 + PN15DIM * MINUS] = +8. * k[MINUS] * (-332. + 94. * stp[2] + stp[4]);
>     acoeff1_5pn[5 + PN15DIM * PLUS_] = +8. * k[PLUS_] * (38. - 42. * stp[2] - 9. * stp[4]);
>     acoeff1_5pn[5 + PN15DIM * MINUS] = -8. * k[MINUS] * (38. - 42. * stp[2] - 9. * stp[4]);
>     acoeff1_5pn[6 + PN15DIM * PLUS_] = -16. * k[PLUS_] * (152. - 46. * stp[2] - 9. * stp[4]);
>     acoeff1_5pn[6 + PN15DIM * MINUS] = -16. * k[MINUS] * (152. - 46. * stp[2] - 9. * stp[4]);
>     acoeff1_5pn[7 + PN15DIM * PLUS_] = +24. * k[PLUS_] * (3. * stp[2] - 10.);
>     acoeff1_5pn[7 + PN15DIM * MINUS] = -24. * k[MINUS] * (3. * stp[2] - 10.);
>     acoeff1_5pn[8 + PN15DIM * PLUS_] = -8. * k[PLUS_] * (160. - 204. * stp[2] - 63. * stp[4]);
>     acoeff1_5pn[8 + PN15DIM * MINUS] = -8. * k[MINUS] * (160. - 204. * stp[2] - 63. * stp[4]);
>     acoeff1_5pn[9 + PN15DIM * PLUS_] = +4. * k[PLUS_] * (3. - 2. * stp[2]);
>     acoeff1_5pn[9 + PN15DIM * MINUS] = -4. * k[MINUS] * (3. - 2. * stp[2]);
>     acoeff1_5pn[10 + PN15DIM * PLUS_] = -8. * k[PLUS_] * (14. + 3. * stp[2]);
>     acoeff1_5pn[10 + PN15DIM * MINUS] = -8. * k[MINUS] * (14. + 3. * stp[2]);
>     acoeff1_5pn[11 + PN15DIM * PLUS_] = -16. * k[PLUS_] * (15. * stp[2] + 76.);
>     acoeff1_5pn[11 + PN15DIM * MINUS] = -16. * k[MINUS] * (15. * stp[2] + 76.);
>     acoeff1_5pn[12 + PN15DIM * PLUS_] = -8. * k[PLUS_] * (5. * stp[2] + 166.);
>     acoeff1_5pn[12 + PN15DIM * MINUS] = -8. * k[MINUS] * (5. * stp[2] + 166.);
>     acoeff1_5pn[13 + PN15DIM * PLUS_] = -8. * k[PLUS_] * (80. + 63. * stp[2]);
>     acoeff1_5pn[13 + PN15DIM * MINUS] = -8. * k[MINUS] * (80. + 63. * stp[2]);
>     acoeff1_5pn[14 + PN15DIM * PLUS_] = +4. * k[PLUS_] * (166. - 125. * stp[2] - 8. * stp[4]);
>     acoeff1_5pn[14 + PN15DIM * MINUS] = -4. * k[MINUS] * (166. - 125. * stp[2] - 8. * stp[4]);
>     acoeff1_5pn[15 + PN15DIM * PLUS_] = -8. * k[PLUS_] * (38. - 61. * stp[2] - 24. * stp[4]);
>     acoeff1_5pn[15 + PN15DIM * MINUS] = +8. * k[MINUS] * (38. - 61. * stp[2] - 24. * stp[4]);
>     acoeff1_5pn[16 + PN15DIM * PLUS_] = +8. * k[PLUS_] * (5. - 4. * stp[2]);
>     acoeff1_5pn[16 + PN15DIM * MINUS] = -8. * k[MINUS] * (5. - 4. * stp[2]);
>     b0coeff1_5pn[0 + PN15DIM * PLUS_] = (5. * stp[2] - 6.);
>     b0coeff1_5pn[0 + PN15DIM * MINUS] = (5. * stp[2] - 6.);
>     b0coeff1_5pn[1 + PN15DIM * PLUS_] = (18. * stp[4] + 252. * stp[2] - 188.);
>     b0coeff1_5pn[1 + PN15DIM * MINUS] = (18. * stp[4] + 252. * stp[2] - 188.);
>     b0coeff1_5pn[2 + PN15DIM * PLUS_] = +20.;
>     b0coeff1_5pn[2 + PN15DIM * MINUS] = -20.;
>     b0coeff1_5pn[3 + PN15DIM * PLUS_] = (+9. * stp[4] - 90. * stp[2] + 56.);
>     b0coeff1_5pn[3 + PN15DIM * MINUS] = (-9. * stp[4] + 90. * stp[2] - 56.);
>     b0coeff1_5pn[4 + PN15DIM * PLUS_] = -4. * (1184. - 172. * stp[2] - 7. * stp[4]);
>     b0coeff1_5pn[4 + PN15DIM * MINUS] = +4. * (1184. - 172. * stp[2] - 7. * stp[4]);
>     b0coeff1_5pn[5 + PN15DIM * PLUS_] = +2. * (46. + 48. * stp[2] - 99. * stp[4]);
>     b0coeff1_5pn[5 + PN15DIM * MINUS] = +2. * (46. + 48. * stp[2] - 99. * stp[4]);
>     b0coeff1_5pn[6 + PN15DIM * PLUS_] = -12. * (72. + 110. * stp[2] - 63. * stp[4]);
>     b0coeff1_5pn[6 + PN15DIM * MINUS] = +12. * (72. + 110. * stp[2] - 63. * stp[4]);
>     b0coeff1_5pn[7 + PN15DIM * PLUS_] = +144. * (stp[2] - 2.);
>     b0coeff1_5pn[7 + PN15DIM * MINUS] = +144. * (stp[2] - 2.);
>     b0coeff1_5pn[8 + PN15DIM * PLUS_] = -3. * (-204. + 406. * stp[2] - 189. * stp[4]);
>     b0coeff1_5pn[8 + PN15DIM * MINUS] = +3. * (-204. + 406. * stp[2] - 189. * stp[4]);
>     b0coeff1_5pn[9 + PN15DIM * PLUS_] = +3. - 4. * stp[2];
>     b0coeff1_5pn[9 + PN15DIM * MINUS] = +3. - 4. * stp[2];
>     b0coeff1_5pn[10 + PN15DIM * PLUS_] = +28. - 31. * stp[2];
>     b0coeff1_5pn[10 + PN15DIM * MINUS] = -28. + 31. * stp[2];
>     b0coeff1_5pn[11 + PN15DIM * PLUS_] = -432. - 876. * stp[2];
>     b0coeff1_5pn[11 + PN15DIM * MINUS] = +432. + 876. * stp[2];
>     b0coeff1_5pn[12 + PN15DIM * PLUS_] = -4. * (71. * stp[2] + 592.);
>     b0coeff1_5pn[12 + PN15DIM * MINUS] = +4. * (71. * stp[2] + 592.);
>     b0coeff1_5pn[13 + PN15DIM * PLUS_] = +306. - 651. * stp[2];
>     b0coeff1_5pn[13 + PN15DIM * MINUS] = -306. + 651. * stp[2];
>     b0coeff1_5pn[14 + PN15DIM * PLUS_] = +2. * (94. - 173. * stp[2] - 24. * stp[4]);
>     b0coeff1_5pn[14 + PN15DIM * MINUS] = +2. * (94. - 173. * stp[2] - 24. * stp[4]);
>     b0coeff1_5pn[15 + PN15DIM * PLUS_] = -2. * (46. + 25. * stp[2] - 180. * stp[4]);
>     b0coeff1_5pn[15 + PN15DIM * MINUS] = -2. * (46. + 25. * stp[2] - 180. * stp[4]);
>     b0coeff1_5pn[16 + PN15DIM * PLUS_] = +48. * ctp[2];
>     b0coeff1_5pn[16 + PN15DIM * MINUS] = +48. * ctp[2];
>     d0coeff1_5pn[0 + PN15DIM * PLUS_] = +0.;
>     d0coeff1_5pn[0 + PN15DIM * MINUS] = +0.;
>     d0coeff1_5pn[1 + PN15DIM * PLUS_] = (-6. * stp[4] + 72. * stp[2] - 20.);
>     d0coeff1_5pn[1 + PN15DIM * MINUS] = (+6. * stp[4] - 72. * stp[2] + 20.);
>     d0coeff1_5pn[2 + PN15DIM * PLUS_] = -12.;
>     d0coeff1_5pn[2 + PN15DIM * MINUS] = -12.;
>     d0coeff1_5pn[3 + PN15DIM * PLUS_] = (-15. * stp[4] + 22. * stp[2] - 8.);
>     d0coeff1_5pn[3 + PN15DIM * MINUS] = (-15. * stp[4] + 22. * stp[2] - 8.);
>     d0coeff1_5pn[4 + PN15DIM * PLUS_] = (1920. - 2832. * stp[2] - 84. * stp[4]);
>     d0coeff1_5pn[4 + PN15DIM * MINUS] = (1920. - 2832. * stp[2] - 84. * stp[4]);
>     d0coeff1_5pn[5 + PN15DIM * PLUS_] = +6. * (10. - 44. * stp[2] + 27. * stp[4]);
>     d0coeff1_5pn[5 + PN15DIM * MINUS] = -6. * (10. - 44. * stp[2] + 27. * stp[4]);
>     d0coeff1_5pn[6 + PN15DIM * PLUS_] = -4. * (88. - 422. * stp[2] + 171. * stp[4]);
>     d0coeff1_5pn[6 + PN15DIM * MINUS] = -4. * (88. - 422. * stp[2] + 171. * stp[4]);
>     d0coeff1_5pn[7 + PN15DIM * PLUS_] = +12. * (14. - 9. * stp[2]);
>     d0coeff1_5pn[7 + PN15DIM * MINUS] = -12. * (14. - 9. * stp[2]);
>     d0coeff1_5pn[8 + PN15DIM * PLUS_] = -9. * (28. - 126. * stp[2] + 105. * stp[4]);
>     d0coeff1_5pn[8 + PN15DIM * MINUS] = -9. * (28. - 126. * stp[2] + 105. * stp[4]);
>     d0coeff1_5pn[9 + PN15DIM * PLUS_] = +0.;
>     d0coeff1_5pn[9 + PN15DIM * MINUS] = +0.;
>     d0coeff1_5pn[10 + PN15DIM * PLUS_] = (9. * stp[2] - 4.);
>     d0coeff1_5pn[10 + PN15DIM * MINUS] = (9. * stp[2] - 4.);
>     d0coeff1_5pn[11 + PN15DIM * PLUS_] = (-176. + 756. * stp[2]);
>     d0coeff1_5pn[11 + PN15DIM * MINUS] = (-176. + 756. * stp[2]);
>     d0coeff1_5pn[12 + PN15DIM * PLUS_] = +12. * (7. * stp[2] + 80.);
>     d0coeff1_5pn[12 + PN15DIM * MINUS] = +12. * (7. * stp[2] + 80.);
>     d0coeff1_5pn[13 + PN15DIM * PLUS_] = (-126. + 189. * stp[2]);
>     d0coeff1_5pn[13 + PN15DIM * MINUS] = (-126. + 189. * stp[2]);
>     d0coeff1_5pn[14 + PN15DIM * PLUS_] = +2. * (10. - 41. * stp[2] + 36. * stp[4]);
>     d0coeff1_5pn[14 + PN15DIM * MINUS] = -2. * (10. - 41. * stp[2] + 36. * stp[4]);
>     d0coeff1_5pn[15 + PN15DIM * PLUS_] = -6. * (10. - 49. * stp[2] + 44. * stp[4]);
>     d0coeff1_5pn[15 + PN15DIM * MINUS] = +6. * (10. - 49. * stp[2] + 44. * stp[4]);
>     d0coeff1_5pn[16 + PN15DIM * PLUS_] = -4. * (7. - 8. * stp[2]);
>     d0coeff1_5pn[16 + PN15DIM * MINUS] = +4. * (7. - 8. * stp[2]);
>     b1coeff1_5pn[0 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[0 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[1 + PN15DIM * PLUS_] = (-15. * stp[4] + 12. * stp[2] - 2.);
>     b1coeff1_5pn[1 + PN15DIM * MINUS] = (-15. * stp[4] + 12. * stp[2] - 2.);
>     b1coeff1_5pn[2 + PN15DIM * PLUS_] = -5.;
>     b1coeff1_5pn[2 + PN15DIM * MINUS] = +5.;
>     b1coeff1_5pn[3 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[3 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[4 + PN15DIM * PLUS_] = -(236. - 294. * stp[2] + 21. * stp[4]);
>     b1coeff1_5pn[4 + PN15DIM * MINUS] = +(236. - 294. * stp[2] + 21. * stp[4]);
>     b1coeff1_5pn[5 + PN15DIM * PLUS_] = +3. * (6. - 36. * stp[2] + 45. * stp[4]);
>     b1coeff1_5pn[5 + PN15DIM * MINUS] = +3. * (6. - 36. * stp[2] + 45. * stp[4]);
>     b1coeff1_5pn[6 + PN15DIM * PLUS_] = -3. * (232. - 510. * stp[2] + 243. * stp[4]);
>     b1coeff1_5pn[6 + PN15DIM * MINUS] = +3. * (232. - 510. * stp[2] + 243. * stp[4]);
>     b1coeff1_5pn[7 + PN15DIM * PLUS_] = +9. * (6. - 5. * stp[2]);
>     b1coeff1_5pn[7 + PN15DIM * MINUS] = +9. * (6. - 5. * stp[2]);
>     b1coeff1_5pn[8 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[8 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[9 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[9 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[10 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[10 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[11 + PN15DIM * PLUS_] = (-348. + 591. * stp[2]);
>     b1coeff1_5pn[11 + PN15DIM * MINUS] = (+348. - 591. * stp[2]);
>     b1coeff1_5pn[12 + PN15DIM * PLUS_] = (+273. * stp[2] - 118.);
>     b1coeff1_5pn[12 + PN15DIM * MINUS] = (-273. * stp[2] + 118.);
>     b1coeff1_5pn[13 + PN15DIM * PLUS_] = +0.;
>     b1coeff1_5pn[13 + PN15DIM * MINUS] = +0.;
>     b1coeff1_5pn[14 + PN15DIM * PLUS_] = (2. - 13. * stp[2] + 12. * stp[4]);
>     b1coeff1_5pn[14 + PN15DIM * MINUS] = (2. - 13. * stp[2] + 12. * stp[4]);
>     b1coeff1_5pn[15 + PN15DIM * PLUS_] = -9. * (2. - 13. * stp[2] + 12. * stp[4]);
>     b1coeff1_5pn[15 + PN15DIM * MINUS] = -9. * (2. - 13. * stp[2] + 12. * stp[4]);
>     b1coeff1_5pn[16 + PN15DIM * PLUS_] = -3. * (3. - 4. * stp[2]);
>     b1coeff1_5pn[16 + PN15DIM * MINUS] = -3. * (3. - 4. * stp[2]);
>     d1coeff1_5pn[0 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[0 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[1 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[1 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[2 + PN15DIM * PLUS_] = +1.;
>     d1coeff1_5pn[2 + PN15DIM * MINUS] = +1.;
>     d1coeff1_5pn[3 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[3 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[4 + PN15DIM * PLUS_] = (28. - 126. * stp[2] + 105. * stp[4]);
>     d1coeff1_5pn[4 + PN15DIM * MINUS] = (28. - 126. * stp[2] + 105. * stp[4]);
>     d1coeff1_5pn[5 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[5 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[6 + PN15DIM * PLUS_] = +27. * (8. - 22. * stp[2] + 15. * stp[4]);
>     d1coeff1_5pn[6 + PN15DIM * MINUS] = +27. * (8. - 22. * stp[2] + 15. * stp[4]);
>     d1coeff1_5pn[7 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[7 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[8 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[8 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[9 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[9 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[10 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[10 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[11 + PN15DIM * PLUS_] = (-243. * stp[2] + 108.);
>     d1coeff1_5pn[11 + PN15DIM * MINUS] = (-243. * stp[2] + 108.);
>     d1coeff1_5pn[12 + PN15DIM * PLUS_] = +7. * (2. - 3. * stp[2]);
>     d1coeff1_5pn[12 + PN15DIM * MINUS] = +7. * (2. - 3. * stp[2]);
>     d1coeff1_5pn[13 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[13 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[14 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[14 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[15 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[15 + PN15DIM * MINUS] = +0.;
>     d1coeff1_5pn[16 + PN15DIM * PLUS_] = +0.;
>     d1coeff1_5pn[16 + PN15DIM * MINUS] = +0.;
>     for (i = 0; i <= 16; i++) {
>         for (j = 0; j <= 1; j++) {
>             params->ccoeff15pn[i + PN15DIM * j] = acoeff1_5pn[i + PN15DIM * j]
>                     + skp[2] * (b0coeff1_5pn[i + PN15DIM * j] + ckp[1] * d0coeff1_5pn[i + PN15DIM * j])
>                     + skp[4] * (b1coeff1_5pn[i + PN15DIM * j] + ckp[1] * d1coeff1_5pn[i + PN15DIM * j]);
>         }
>     }
>     XLALFreeDmatrix(acoeff00pn);
>     XLALFreeDmatrix(b0coeff0pn);
>     XLALFreeDmatrix(d0coeff0pn);
>     XLALFreeDmatrix(acoeff0_5pn);
>     XLALFreeDmatrix(b0coeff0_5pn);
>     XLALFreeDmatrix(d0coeff0_5pn);
>     XLALFreeDmatrix(acoeff1pn);
>     XLALFreeDmatrix(b0coeff1pn);
>     XLALFreeDmatrix(d0coeff1pn);
>     XLALFreeDmatrix(b1coeff1pn);
>     XLALFreeDmatrix(d1coeff1pn);
>     XLALFreeDmatrix(acoeff1_5pn);
>     XLALFreeDmatrix(b0coeff1_5pn);
>     XLALFreeDmatrix(d0coeff1_5pn);
>     XLALFreeDmatrix(b1coeff1_5pn);
>     XLALFreeDmatrix(d1coeff1_5pn);
>     return XLAL_SUCCESS;
687d607
< 
689,691c609,610
<  * @addtogroup LALSimInspiralSpinDominatedWaveform_c
<  * @brief Routines to generate spin-dominanted precessing inspiral waveforms.
<  * @{
---
>  * Function building the wavefrom from the calculated parameters at a given time
>  * For the formulae see the appendix of Arxiv:1209.1722
692a612,1168
> int XLALSpinDominatedWaveformBuild(LALSDWaveformParams *params, /**< The SDW parameters */
> REAL8 expr[], /**< The 3 time dependent variables of the waveform at the time indexed by idx */
> REAL8TimeSeries **hplus, /**< +-polarization waveform */
> REAL8TimeSeries **hcross, /**< x-polarization waveform */
> int idx /**< index of the time dependent variables */) {
>     enum {
>         PN00_A, PN00_B, PN05_A, PN05_B, PN10_A, PN10_B, PN10_C, PN10_D, PN15_A, PN15_B, PN15_C,
>     };
>     REAL8 omega0 = 1;
>     REAL8 chi1_1 = params->chi1;
>     REAL8 skp[TRIGONOMETRIC_POWER], ckp[TRIGONOMETRIC_POWER], stp[TRIGONOMETRIC_POWER], ctp[TRIGONOMETRIC_POWER];
>     skp[0] = ckp[0] = stp[0] = ctp[0] = 1.;
>     skp[1] = sin(params->kappa1);
>     ckp[1] = cos(params->kappa1);
>     stp[1] = sin(params->theta);
>     ctp[1] = cos(params->theta);
>     for (int i = 2; i < TRIGONOMETRIC_POWER; ++i) {
>         skp[i] = skp[1] * skp[i - 1];
>         ckp[i] = ckp[1] * ckp[i - 1];
>         stp[i] = stp[1] * stp[i - 1];
>         ctp[i] = ctp[1] * ctp[i - 1];
>     }
>     REAL8 s2t = sin(2. * params->theta);
>     REAL8 c2t = cos(2. * params->theta);
>     REAL8 k[PLUS_MINUS_DIM] = { ckp[1] - 1., ckp[1] + 1. };
>     REAL8 s2k1 = sin(2. * params->kappa1);
>     REAL8 c2k1 = cos(2. * params->kappa1);
>     REAL8 phin[PHI_PSI_DIM], psin[PHI_PSI_DIM];
>     phin[0] = psin[0] = 1.;
>     for (int i = 1; i < PHI_PSI_DIM; ++i) {
>         phin[i] = i * expr[PHI];
>         psin[i] = i * expr[PSI];
>     }
>     REAL8 *waveampcoeffs = XLALDmatrix(AMPCOEFF_DIM, PLUS_MINUS_DIM);
>     switch (params->pnamp) {
>     case (PNDEF): //default value -1 contains all corrections
>     case (PN15): {
>         waveampcoeffs[PN15_C + AMPCOEFF_DIM * PLUS_] = LAL_PI_2 * (    //
>                 6. * skp[2] * stp[2] * cos(psin[2]) + (    //
>                         (stp[2] - 2.) * (    //
>                                 /*  */cos(phin[2] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                                 /**/+ cos(phin[2] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS]    //
>                                 ) - 2. * skp[1] * s2t * (    //
>                                 /*  */sin(phin[1] + psin[2]) * k[PLUS_]    //
>                                 /**/+ sin(phin[1] - psin[2]) * k[MINUS]    //
>                                 )//
>                         )//
>                 ) + 3. * log(expr[OMEGA] / omega0) * (    //
>                 4. * ctp[1] * skp[1] * stp[1] * (    //
>                         /* */-k[MINUS] * cos(phin[1] - psin[2])
>                         /**/+ k[PLUS_] * cos(phin[1] + psin[2])    //
>                         )//
>                 + sin(phin[2] - psin[2]) * (2. * ckp[1] - skp[2] + 2.) * (-stp[2] + 2.)  //
>                 + sin(phin[2] + psin[2]) * (2. * ckp[1] + skp[2] - 2.) //
>                 + 6. * skp[2] * sin(psin[2]) * stp[2] //
>                 );
>         waveampcoeffs[PN15_C + AMPCOEFF_DIM * MINUS] = LAL_PI * ( //
>                 ctp[1] * ( //
>                         /*  */sin(phin[2] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         ) - 2. * skp[1] * stp[1] * ( //
>                         /*  */cos(phin[1] + psin[2]) * k[PLUS_]
>                         /**/+ cos(phin[1] - psin[2]) * k[MINUS] //
>                         )//
>                 ) + 6. * log(expr[OMEGA] / omega0) * ( //
>                 /*  */(2. * ckp[1] - skp[2] + 2.) * ctp[1] * cos(phin[2] - psin[2])
>                 /**/+ (2. * ckp[1] + skp[2] - 2.) * ctp[1] * cos(phin[2] + psin[2])
>                 /**/+ 2. * k[MINUS] * skp[1] * stp[1] * sin(phin[1] - psin[2])
>                 /**/- 2. * k[PLUS_] * skp[1] * stp[1] * sin(phin[1] + psin[2]) //
>                 );
>         waveampcoeffs[PN15_B + AMPCOEFF_DIM * PLUS_] = chi1_1 / 2. * (4. * skp[1] * ( //
>                 /**/ckp[1] * skp[1] * cos(phin[2]) - c2k1 * ctp[1] * stp[1] * sin(phin[1])
>                 /**/+ ckp[1] * skp[1] * stp[2] * ( //
>                         /*  */6. * sin(psin[1]) * sin(psin[1]) - 2. * sin(phin[1]) * sin(phin[1]) //
>                         )//
>                 ) + ( //
>                 2. * ctp[1] * skp[1] * stp[1] * ( //
>                         /*  */(-3. * k[PLUS_] - 4. * skp[2]) * sin(phin[1] + psin[2])
>                         /**/+ (+3. * k[MINUS] - 4. * skp[2]) * sin(phin[1] - psin[2]) //
>                         ) + (stp[2] - 2.) * ( //
>                         /*  */(-2. * k[PLUS_] + (2. * ckp[1] - 3.) * skp[2]) * cos(phin[2] + psin[2])
>                         /**/+ (-2. * k[MINUS] + (2. * ckp[1] + 3.) * skp[2]) * cos(phin[2] - psin[2]) //
>                         )//
>                 ));
>         waveampcoeffs[PN15_B + AMPCOEFF_DIM * MINUS] = chi1_1 * ( //
>                 -2. * cos(phin[1]) * skp[1] * (stp[1] * c2k1 + ctp[1] * s2k1 * sin(phin[1])) + ( //
>                         ctp[1] * ( //
>                                 /*  */(-2. * k[PLUS_] + (2. * ckp[1] - 3.) * skp[2]) * sin(phin[2] + psin[2])
>                                 /**/+ (-2. * k[MINUS] + (2. * ckp[1] + 3.) * skp[2]) * sin(phin[2] - psin[2]) //
>                                 ) + skp[1] * stp[1] * ( //
>                                 /*  */(-3. * k[PLUS_] - 4. * skp[2]) * cos(phin[1] + psin[2])
>                                 /**/+ (+3. * k[MINUS] - 4. * skp[2]) * cos(phin[1] - psin[2]) //
>                                 )//
>                         )//
>                 );
>         waveampcoeffs[PN15_A + AMPCOEFF_DIM * PLUS_] = 1. / 12288. * (12. * ctp[1] * skp[1] * stp[2] * ( //
>                 cos(psin[3]) * ( //
>                         /**/1701. * (2. - 3. * stp[2]) * skp[4] + 72. * skp[2] * (63. * stp[2] + 178.) //
>                         ) + cos(psin[1]) * ( //
>                         /**/-14. * (2. - 3. * stp[2]) * skp[4] //
>                         /**/- 8. * skp[2] * (7. * stp[2] + 162.) + 16. * (stp[2] + 66.) //
>                         ) - 4375. * (2. - 3. * stp[2]) * skp[4] * cos(psin[5]) //
>                 ) + ( //
>                 2. * (stp[2] - 2.) * skp[4] * stp[3] * ( //
>                         /*  */sin(phin[5] + psin[1]) * k[PLUS_]
>                         /**/+ sin(phin[5] - psin[1]) * k[MINUS] //
>                         ) + 4. * ctp[1] * skp[3] * stp[2] * ( //
>                         /*  */cos(phin[4] + psin[1]) * params->ccoeff15pn[0 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[4] - psin[1]) * params->ccoeff15pn[0 + PN15DIM * MINUS] //
>                         ) + 16. * ctp[1] * skp[1] * ( //
>                         /*  */cos(phin[2] + psin[1]) * params->ccoeff15pn[1 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[1]) * params->ccoeff15pn[1 + PN15DIM * MINUS] //
>                         ) + 1250. * skp[4] * stp[1] * (105. * stp[4] - 126. * stp[2] + 28.) * ( //
>                         /*  */sin(phin[1] + psin[5]) * k[PLUS_]
>                         /**/+ sin(phin[1] - psin[5]) * k[MINUS] //
>                         ) + 625. * (stp[2] - 2.) * stp[3] * ( //
>                         /*  */sin(phin[5] + psin[5]) * params->ccoeff15pn[2 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[5] - psin[5]) * params->ccoeff15pn[2 + PN15DIM * MINUS] //
>                         ) + 6. * skp[2] * stp[1] * ( //
>                         /*  */sin(phin[3] + psin[1]) * params->ccoeff15pn[3 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[1]) * params->ccoeff15pn[3 + PN15DIM * MINUS] //
>                         ) + 243. * (stp[2] - 2.) * skp[2] * stp[3] * ( //
>                         /*  */sin(phin[5] + psin[3]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[5] - psin[3]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         ) + 4. * stp[1] * ( //
>                         /*  */sin(phin[1] + psin[1]) * params->ccoeff15pn[4 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[1] - psin[1]) * params->ccoeff15pn[4 + PN15DIM * MINUS] //
>                         ) + 5000. * ctp[1] * skp[3] * (15. * stp[4] - 12. * stp[2] + 2.) * ( //
>                         /*  */cos(phin[2] + psin[5]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[5]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         ) - 1250. * ctp[1] * skp[1] * stp[2] * (5. * stp[2] - 6.) * ( //
>                         /*  */cos(phin[4] + psin[5]) * params->ccoeff10pn[0 + PN10DIM * PLUS_]
>                         /**/+ cos(phin[4] - psin[5]) * params->ccoeff10pn[0 + PN10DIM * MINUS] //
>                         ) + 1875. * skp[2] * stp[1] * (8. - 22. * stp[2] + 15. * stp[4]) * ( //
>                         /*  */sin(phin[3] + psin[5]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[5]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         ) + 216. * ctp[1] * skp[1] * ( //
>                         /*  */cos(phin[2] + psin[3]) * params->ccoeff15pn[5 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[3]) * params->ccoeff15pn[5 + PN15DIM * MINUS] //
>                         ) + 27. * stp[1] * ( //
>                         /*  */sin(phin[3] + psin[3]) * params->ccoeff15pn[6 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[3]) * params->ccoeff15pn[6 + PN15DIM * MINUS] //
>                         ) + 54. * ctp[1] * skp[1] * stp[2] * ( //
>                         /*  */cos(phin[4] + psin[3]) * params->ccoeff15pn[7 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[4] - psin[3]) * params->ccoeff15pn[7 + PN15DIM * MINUS] //
>                         ) + 54. * skp[2] * stp[1] * ( //
>                         /*  */sin(phin[1] + psin[3]) * params->ccoeff15pn[8 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[1] - psin[3]) * params->ccoeff15pn[8 + PN15DIM * MINUS] //
>                         )//
>                 ));
>         waveampcoeffs[PN15_A + AMPCOEFF_DIM * MINUS] = 1. / 6144. * (192. * ckp[1] * skp[1] * stp[2] * ( //
>                 /*        */sin(psin[1]) * (64. - skp[2] * (7. * stp[2] - 6.) + 4. * stp[2])
>                 /**/+ 27. * sin(psin[3]) * skp[2] * (7. * stp[2] - 6.) //
>                 ) + ( //
>                 4. * skp[3] * stp[2] * ( //
>                         /*  */sin(phin[4] + psin[1]) * params->ccoeff15pn[9 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[4] - psin[1]) * params->ccoeff15pn[9 + PN15DIM * MINUS] //
>                         ) - 2. * ctp[1] * skp[4] * stp[3] * ( //
>                         /*  */cos(phin[5] + psin[1]) * k[PLUS_]
>                         /**/+ cos(phin[5] - psin[1]) * k[MINUS] //
>                         ) - 243. * ctp[1] * skp[2] * stp[3] * ( //
>                         /*  */cos(phin[5] + psin[3]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ cos(phin[5] - psin[3]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         ) - 625. * ctp[1] * stp[3] * ( //
>                         /*  */cos(phin[5] + psin[5]) * params->ccoeff15pn[2 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[5] - psin[5]) * params->ccoeff15pn[2 + PN15DIM * MINUS] //
>                         ) + 3. * skp[2] * s2t * ( //
>                         /*  */cos(phin[3] + psin[1]) * params->ccoeff15pn[10 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[3] - psin[1]) * params->ccoeff15pn[10 + PN15DIM * MINUS] //
>                         ) + 27. * ctp[1] * stp[1] * ( //
>                         /*  */cos(phin[3] + psin[3]) * params->ccoeff15pn[11 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[3] - psin[3]) * params->ccoeff15pn[11 + PN15DIM * MINUS] //
>                         ) + 1875. * ctp[1] * skp[2] * stp[1] * (4. - 9. * stp[2]) * ( //
>                         /*  */cos(phin[3] + psin[5]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ cos(phin[3] - psin[5]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         ) + 2. * s2t * ( //
>                         /*  */cos(phin[1] + psin[1]) * params->ccoeff15pn[12 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[1] - psin[1]) * params->ccoeff15pn[12 + PN15DIM * MINUS] //
>                         ) + 27. * skp[2] * s2t * ( //
>                         /*  */cos(phin[1] + psin[3]) * params->ccoeff15pn[13 + PN15DIM * PLUS_]
>                         /**/+ cos(phin[1] - psin[3]) * params->ccoeff15pn[13 + PN15DIM * MINUS] //
>                         ) + 8. * skp[1] * ( //
>                         /*  */sin(phin[2] + psin[1]) * params->ccoeff15pn[14 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[1]) * params->ccoeff15pn[14 + PN15DIM * MINUS] //
>                         ) + 4375. * (2. - 3. * stp[2]) * skp[4] * s2t * ( //
>                         /*  */cos(phin[1] + psin[5]) * k[PLUS_]
>                         /**/+ cos(phin[1] - psin[5]) * k[MINUS] //
>                         ) + 108. * skp[1] * ( //
>                         /*  */sin(phin[2] + psin[3]) * params->ccoeff15pn[15 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[3]) * params->ccoeff15pn[15 + PN15DIM * MINUS] //
>                         ) + 162. * skp[1] * stp[2] * ( //
>                         /*  */sin(phin[4] + psin[3]) * params->ccoeff15pn[16 + PN15DIM * PLUS_]
>                         /**/+ sin(phin[4] - psin[3]) * params->ccoeff15pn[16 + PN15DIM * MINUS] //
>                         ) - 2500. * skp[3] * (2. - 13. * stp[2] + 12. * stp[4]) * ( //
>                         /*  */sin(phin[2] + psin[5]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[5]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         ) - 1250. * skp[1] * stp[2] * (3. - 4. * stp[2]) * ( //
>                         /*  */sin(phin[4] + psin[5]) * params->ccoeff10pn[0 + PN10DIM * PLUS_]
>                         /**/+ sin(phin[4] - psin[5]) * params->ccoeff10pn[0 + PN10DIM * MINUS] //
>                         )//
>                 ));
>     }
>         /* no break */
>     case (PN10): {
>         REAL8 phi1_1 = LAL_PI_2;
>         waveampcoeffs[PN10_D + AMPCOEFF_DIM * PLUS_] = chi1_1 / 2. * (    //
>                 (    //
>                 /* */-k[PLUS_] * ctp[1] * sin(phin[2] + psin[1] - phi1_1)
>                 /**/+ k[MINUS] * ctp[1] * sin(phin[2] - psin[1] - phi1_1)    //
>                 ) + skp[1] * stp[1] * (    //
>                         /*  */sin(phin[1] + psin[1]) - sin(phin[1] - psin[1])
>                         /**/+ cos(phin[1] + psin[1] - phi1_1) - cos(phin[1] - psin[1] - phi1_1)    //
>                         )//
>                 );
>         waveampcoeffs[PN10_D + AMPCOEFF_DIM * MINUS] = chi1_1 / 4. * (-stp[2] * (    //
>                 2. * (sin(phi1_1) + 2.) * ckp[1] * sin(psin[1]) + 2. * cos(phi1_1) * cos(psin[1])    //
>                 ) + (    //
>                 2. * ctp[1] * skp[1] * stp[1] * (    //
>                         /**/cos(phin[1] + psin[1]) - cos(phin[1] - psin[1])
>                         /**/- sin(phin[1] + psin[1] - phi1_1) + sin(phin[1] - psin[1] - phi1_1)    //
>                         ) + (stp[2] - 2.) * (    //
>                         /*  */k[PLUS_] * cos(phin[2] + psin[1] - phi1_1)
>                         /**/- k[MINUS] * cos(phin[2] - psin[1] - phi1_1) //
>                         )//
>                 ));
>         waveampcoeffs[PN10_C + AMPCOEFF_DIM * PLUS_] = chi1_1 / 2. * stp[1]
>                 * (k[PLUS_] * sin(phin[1] + psin[1]) - k[MINUS] * sin(phin[1] - psin[1]));
>         waveampcoeffs[PN10_C + AMPCOEFF_DIM * MINUS] = chi1_1 / 2. * stp[1]
>                 * (2. * skp[1] * sin(psin[1]) * stp[1]
>                         + ctp[1] * (k[PLUS_] * cos(phin[1] + psin[1]) - k[MINUS] * cos(phin[1] - psin[1])));
>         waveampcoeffs[PN10_B + AMPCOEFF_DIM * PLUS_] = 1. / 24. * ( //
>                 ckp[1] * skp[1] * stp[2] * ( //
>                         4. * (15. * stp[2] + 51.) * cos(psin[2])
>                                 + 20. * skp[2] * (7. * stp[2] - 6.) * (4. * cos(psin[4]) - cos(psin[2])) //
>                         ) + ( //
>                         s2t * ( //
>                                 /*  */sin(phin[3] + psin[2]) * params->ccoeff10pn[7 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[3] - psin[2]) * params->ccoeff10pn[7 + PN10DIM * MINUS] //
>                                 ) + s2t * ( //
>                                 /*  */sin(phin[1] + psin[2]) * params->ccoeff10pn[8 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[1] - psin[2]) * params->ccoeff10pn[8 + PN10DIM * MINUS] //
>                                 ) + ctp[2] * s2t * 8. * ( //
>                                 /*  */sin(phin[3] + psin[4]) * params->ccoeff10pn[9 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[3] - psin[4]) * params->ccoeff10pn[9 + PN10DIM * MINUS] //
>                                 ) + 2. * skp[1] * ( //
>                                 /*  */cos(phin[2] + psin[2]) * params->ccoeff10pn[10 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[2] - psin[2]) * params->ccoeff10pn[10 + PN10DIM * MINUS] //
>                                 ) + 8. * skp[2] * s2t * (7. * stp[2] - 3.) * ( //
>                                 /*  */sin(phin[1] + psin[4]) * (+3. * k[PLUS_] + 4. * skp[2])
>                                 /**/+ sin(phin[1] - psin[4]) * (-3. * k[MINUS] + 4. * skp[2]) //
>                                 ) + 16. * skp[1] * (2. - 8. * stp[2] + 7. * stp[4]) * ( //
>                                 /*  */cos(phin[2] + psin[4]) * params->ccoeff10pn[11 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[2] - psin[4]) * params->ccoeff10pn[11 + PN10DIM * MINUS] //
>                                 ) + skp[1] * stp[2] * (stp[2] - 2.) * ( //
>                                 /*  */cos(phin[4] + psin[2]) * params->ccoeff10pn[11 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[4] - psin[2]) * params->ccoeff10pn[11 + PN10DIM * MINUS] - 8. * ( //
>                                         /*  */cos(phin[4] + psin[4]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                                         /**/+ cos(phin[4] - psin[4]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                                         )//
>                                 )//
>                         )//
>                 );
>         waveampcoeffs[PN10_B + AMPCOEFF_DIM * MINUS] = 1. / 12. * ( //
>                 30. * ctp[1] * skp[1] * sin(psin[2]) * stp[2] * (3. * skp[2] - 2.) + (stp[1] * ( //
>                         /*  */cos(phin[1] + psin[2]) * params->ccoeff10pn[12 + PN10DIM * PLUS_]
>                         /**/+ cos(phin[1] - psin[2]) * params->ccoeff10pn[12 + PN10DIM * MINUS] //
>                         ) + 2. * ctp[1] * skp[1] * ( //
>                         ( //
>                         /*  */sin(phin[2] + psin[2]) * params->ccoeff10pn[13 + PN10DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[2]) * params->ccoeff10pn[13 + PN10DIM * MINUS] //
>                         ) + 4. * (7. * stp[2] - 2.) * ( //
>                                 /*  */sin(phin[2] + psin[4]) * params->ccoeff10pn[11 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[2] - psin[4]) * params->ccoeff10pn[11 + PN10DIM * MINUS] //
>                                 )//
>                         ) + ctp[1] * skp[1] * stp[2] * ( //
>                         ( //
>                         /*  */sin(phin[4] + psin[2]) * params->ccoeff10pn[11 + PN10DIM * PLUS_]
>                         /**/+ sin(phin[4] - psin[2]) * params->ccoeff10pn[11 + PN10DIM * MINUS] //
>                         ) - 8. * ( //
>                                 /*  */sin(phin[4] + psin[4]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                                 /**/+ sin(phin[4] - psin[4]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                                 )//
>                         ) + stp[1] * ( //
>                         ( //
>                         /*  */cos(phin[3] + psin[2]) * params->ccoeff10pn[14 + PN10DIM * PLUS_]
>                         /**/+ cos(phin[3] - psin[2]) * params->ccoeff10pn[14 + PN10DIM * MINUS] //
>                         ) + 4. * (2. - 3. * stp[2]) * ( //
>                                 /*  */cos(phin[3] + psin[4]) * params->ccoeff10pn[9 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[3] - psin[4]) * params->ccoeff10pn[9 + PN10DIM * MINUS] //
>                                 )//
>                         ) + 4. * skp[2] * stp[1] * (6. - 7. * stp[2]) * ( //
>                         /*  */(-3. * k[PLUS_] - 4. * skp[2]) * cos(phin[1] + psin[4])
>                         /**/+ (+3. * k[MINUS] - 4. * skp[2]) * cos(phin[1] - psin[4]) //
>                         ))//
>                 );
>         waveampcoeffs[PN10_A + AMPCOEFF_DIM * PLUS_] = 1. / 48. * (2. * skp[2] * stp[2] * ( //
>                 /*  */5. * skp[2] * (7. * stp[2] - 6.) * (cos(psin[2]) - 4. * cos(psin[4]))
>                 /**/- 2. * (15. * stp[2] + 51.) * cos(psin[2]) //
>                 ) + ( //
>                 /*  */16. * skp[3] * s2t * (7. * stp[2] - 3.) * ( //
>                         /*  */sin(phin[1] + psin[4]) * k[PLUS_]
>                         /**/+ sin(phin[1] - psin[4]) * k[MINUS] //
>                         ) - (stp[2] - 2.) * skp[2] * stp[2] * ( //
>                         /*  */cos(phin[4] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ cos(phin[4] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         ) + 4. * (stp[2] - 2.) * stp[2] * ( //
>                         /*  */cos(phin[4] + psin[4]) * params->ccoeff10pn[0 + PN10DIM * PLUS_]
>                         /**/+ cos(phin[4] - psin[4]) * params->ccoeff10pn[0 + PN10DIM * MINUS] //
>                         ) + 2. * skp[1] * s2t * ( //
>                         ( //
>                         /*  */sin(phin[1] + psin[2]) * params->ccoeff10pn[1 + PN10DIM * PLUS_]
>                         /**/+ sin(phin[1] - psin[2]) * params->ccoeff10pn[1 + PN10DIM * MINUS] //
>                         ) + (
>                         /*  */sin(phin[3] + psin[2]) * params->ccoeff10pn[2 + PN10DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[2]) * params->ccoeff10pn[2 + PN10DIM * MINUS] //
>                         ) - 8. * ctp[2] * (
>                         /*  */sin(phin[3] + psin[4]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[4]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         )//
>                         ) + 2. * ( //
>                         /*  */cos(phin[2] + psin[2]) * params->ccoeff10pn[3 + PN10DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[2]) * params->ccoeff10pn[3 + PN10DIM * MINUS] //
>                         ) - 16. * skp[2] * (7. * stp[4] - 2. * (4. * stp[2] - 1.)) * ( //
>                         /*  */cos(phin[2] + psin[4]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[4]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         )//
>                 ));
>         waveampcoeffs[PN10_A + AMPCOEFF_DIM * MINUS] = 1. / 24. * ( //
>                 60. * ckp[1] * ctp[1] * skp[2] * sin(psin[2]) * stp[2] + ( //
>                         8. * skp[3] * stp[1] * (7. * stp[2] - 6.) * ( //
>                                 /*  */cos(phin[1] + psin[4]) * k[PLUS_]
>                                 /**/+ cos(phin[1] - psin[4]) * k[MINUS] //
>                                 ) - ctp[1] * skp[2] * stp[2] * ( //
>                                 /*  */sin(phin[4] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                                 /**/+ sin(phin[4] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                                 ) + 2. * skp[1] * stp[1] * ( //
>                                 /*  */cos(phin[1] + psin[2]) * params->ccoeff10pn[4 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[1] - psin[2]) * params->ccoeff10pn[4 + PN10DIM * MINUS] //
>                                 ) + 4. * ctp[1] * stp[2] * ( //
>                                 /*  */sin(phin[4] + psin[4]) * params->ccoeff10pn[0 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[4] - psin[4]) * params->ccoeff10pn[0 + PN10DIM * MINUS] //
>                                 ) + 2. * ctp[1] * ( //
>                                 /*  */sin(phin[2] + psin[2]) * params->ccoeff10pn[5 + PN10DIM * PLUS_]
>                                 /**/+ sin(phin[2] - psin[2]) * params->ccoeff10pn[5 + PN10DIM * MINUS] //
>                                 ) - 8. * ctp[1] * skp[2] * (7. * stp[2] - 2.) * ( //
>                                 /*  */sin(phin[2] + psin[4]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                                 /**/+ sin(phin[2] - psin[4]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                                 ) - 8. * (2. - 3. * stp[2]) * skp[1] * stp[1] * ( //
>                                 /*  */cos(phin[3] + psin[4]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                                 /**/+ cos(phin[3] - psin[4]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                                 ) + 2. * skp[1] * stp[1] * ( //
>                                 /*  */cos(phin[3] + psin[2]) * params->ccoeff10pn[6 + PN10DIM * PLUS_]
>                                 /**/+ cos(phin[3] - psin[2]) * params->ccoeff10pn[6 + PN10DIM * MINUS] //
>                                 )//
>                         )//
>                 );
>     }
>         /* no break */
>     case (PN05): {
>         waveampcoeffs[PN05_B + AMPCOEFF_DIM * PLUS_] = 1. / 64. * (    //
>                 4. * ckp[1] * ctp[1] * stp[2] * (135. * cos(psin[3]) * skp[2] + cos(psin[1]) * (4. - 15. * skp[2])    //
>                 ) + (    //
>                         2. * ctp[1] * (    //
>                                 9. * (2. - 3. * stp[2]) * (    //
>                                         /*  */cos(phin[2] + psin[3]) * params->ccoeff05pn[5 + PN05DIM * PLUS_]
>                                         /**/+ cos(phin[2] - psin[3]) * params->ccoeff05pn[5 + PN05DIM * MINUS]    //
>                                         )//
>                                 /*    */+ cos(phin[2] + psin[1]) * params->ccoeff05pn[6 + PN05DIM * PLUS_]
>                                         + cos(phin[2] - psin[1]) * params->ccoeff05pn[6 + PN05DIM * MINUS]    //
>                                 ) - skp[1] * stp[1] * (stp[2] - 2.) * (    //
>                                 27. * (    //
>                                         /*  */sin(phin[3] + psin[3]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                                         /**/+ sin(phin[3] - psin[3]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                                         )//
>                                 /**/+ sin(phin[3] + psin[1]) * params->ccoeff05pn[7 + PN05DIM * PLUS_]
>                                 /**/+ sin(phin[3] - psin[1]) * params->ccoeff05pn[7 + PN05DIM * MINUS]    //
>                                 ) + skp[1] * stp[1] * (    //
>                                 45. * (2. - 3. * stp[2]) * (    //
>                                         /*  */sin(phin[1] + psin[3]) * params->ccoeff05pn[7 + PN05DIM * PLUS_]
>                                         /**/+ sin(phin[1] - psin[3]) * params->ccoeff05pn[7 + PN05DIM * MINUS] //
>                                         )//
>                                 /**/+ sin(phin[1] + psin[1]) * params->ccoeff05pn[8 + PN05DIM * PLUS_]
>                                 /**/+ sin(phin[1] - psin[1]) * params->ccoeff05pn[8 + PN05DIM * MINUS] //
>                                 ))//
>                 );
>         waveampcoeffs[PN05_B + AMPCOEFF_DIM * MINUS] = 1. / 32. * (32. * sin(psin[1]) * stp[2] * c2k1 + (    //
>                 ctp[1] * skp[1] * stp[1] * (27. * (    //
>                         /*  */cos(phin[3] + psin[3]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ cos(phin[3] - psin[3]) * params->ccoeff00pn[0 + PN00DIM * MINUS]    //
>                         ) + (    //
>                 /**/cos(phin[3] + psin[1]) + 45. * cos(phin[1] + psin[3])    //
>                 ) * params->ccoeff05pn[7 + PN05DIM * PLUS_] + (    //
>                 /**/cos(phin[3] - psin[1]) + 45. * cos(phin[1] - psin[3])    //
>                 ) * params->ccoeff05pn[7 + PN05DIM * MINUS] + (    //
>                         /*  */params->ccoeff05pn[9 + PN05DIM * PLUS_] * cos(phin[1] + psin[1])
>                         /**/+ params->ccoeff05pn[9 + PN05DIM * MINUS] * cos(phin[1] - psin[1])    //
>                         )) - (18. * c2t) * (    //
>                         /*  */sin(phin[2] + psin[3]) * params->ccoeff05pn[5 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[3]) * params->ccoeff05pn[5 + PN05DIM * MINUS]    //
>                         ) - 2. * (    //
>                         /*  */sin(phin[2] + psin[1]) * params->ccoeff05pn[10 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[1]) * params->ccoeff05pn[10 + PN05DIM * MINUS]    //
>                         )//
>                 ));
>         waveampcoeffs[PN05_A + AMPCOEFF_DIM * PLUS_] = 1. / 64. * (4. * ctp[1] * skp[1] * stp[2] * (    //
>                 /**/-45. * skp[2] * cos(psin[3]) + cos(psin[1]) * (5. * skp[2] - 4.)    //
>                 ) - skp[2] * stp[1] * ((stp[2] - 2.) * (    //
>                 /*  */sin(phin[3] + psin[1]) * k[PLUS_]
>                 /**/+ sin(phin[3] - psin[1]) * k[MINUS]    //
>                 ) - 45. * (2. - 3. * stp[2]) * (    //
>                 /*  */sin(phin[1] + psin[3]) * k[PLUS_]
>                 /**/+ sin(phin[1] - psin[3]) * k[MINUS]    //
>                 )) + stp[1] * (    //
>                 /*  */sin(phin[1] + psin[1]) * params->ccoeff05pn[0 + PN05DIM * PLUS_]
>                 /**/+ sin(phin[1] - psin[1]) * params->ccoeff05pn[0 + PN05DIM * MINUS]    //
>                 - 9. * (stp[2] - 2.) * ( //
>                         /*  */sin(phin[3] + psin[3]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[3] - psin[3]) * params->ccoeff05pn[1 + PN05DIM * MINUS] //
>                         )//
>                 ) + 2. * ctp[1] * skp[1] * ( //
>                 /*  */cos(phin[2] + psin[1]) * params->ccoeff05pn[2 + PN05DIM * PLUS_]
>                 /**/+ cos(phin[2] - psin[1]) * params->ccoeff05pn[2 + PN05DIM * MINUS] //
>                 + 9. * (2 - 3. * stp[2]) * ( //
>                         /*  */cos(phin[2] + psin[3]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                         /**/+ cos(phin[2] - psin[3]) * params->ccoeff00pn[0 + PN00DIM * MINUS] //
>                         )//
>                 ));
>         waveampcoeffs[PN05_A + AMPCOEFF_DIM * MINUS] = 1. / 32. * (    //
>                 -16. * s2k1 * stp[2] * sin(psin[1]) + ctp[1] * stp[1] * skp[2] * (    //
>                         /*  */cos(phin[3] + psin[1]) * k[PLUS_]
>                         /**/+ cos(phin[3] - psin[1]) * k[MINUS]    //
>                         + 45. * (    //
>                                 /*  */cos(phin[1] + psin[3]) * k[PLUS_]
>                                 /**/+ cos(phin[1] - psin[3]) * k[MINUS]    //
>                                 )//
>                         ) + 0.5 * s2t * (    //
>                         /*  */cos(phin[1] + psin[1]) * params->ccoeff05pn[3 + PN05DIM * PLUS_]
>                         /**/+ cos(phin[1] - psin[1]) * params->ccoeff05pn[3 + PN05DIM * MINUS] //
>                         + 9. * (    //
>                                 /*  */cos(phin[3] + psin[3]) * params->ccoeff05pn[1 + PN05DIM * PLUS_]
>                                 /**/+ cos(phin[3] - psin[3]) * params->ccoeff05pn[1 + PN05DIM * MINUS]    //
>                                 )//
>                         ) + 2. * skp[1] * (    //
>                         /*  */sin(phin[2] + psin[1]) * params->ccoeff05pn[4 + PN05DIM * PLUS_]
>                         /**/+ sin(phin[2] - psin[1]) * params->ccoeff05pn[4 + PN05DIM * MINUS] //
>                         - 9. * c2t * (    //
>                                 /*  */sin(phin[2] + psin[3]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                                 /**/+ sin(phin[2] - psin[3]) * params->ccoeff00pn[0 + PN00DIM * MINUS]    //
>                                 )//
>                         )//
>                 );
>     }
>         /* no break */
>     case (PN00): {
>         waveampcoeffs[PN00_B + AMPCOEFF_DIM * PLUS_] = 0.5 * (s2t * (    //
>                 /*  */sin(phin[1] + psin[2]) * params->ccoeff00pn[1 + PN00DIM * PLUS_]
>                 /**/+ sin(phin[1] - psin[2]) * params->ccoeff00pn[1 + PN00DIM * MINUS]    //
>                 ) + skp[1] * (stp[2] - 2.) * (    //
>                 /*  */cos(phin[2] + psin[2]) * k[PLUS_]
>                 /**/+ cos(phin[2] - psin[2]) * k[MINUS]    //
>                 ) - 3. * s2k1 * stp[2] * cos(psin[2]));
>         waveampcoeffs[PN00_B + AMPCOEFF_DIM * MINUS] = ctp[1] * skp[1] * (    //
>                 /*  */sin(phin[2] + psin[2]) * k[PLUS_]
>                 /**/+ sin(phin[2] - psin[2]) * k[MINUS]    //
>                 ) + stp[1] * (    //
>                 /*  */cos(phin[1] + psin[2]) * params->ccoeff00pn[1 + PN00DIM * PLUS_]
>                 /**/+ cos(phin[1] - psin[2]) * params->ccoeff00pn[1 + PN00DIM * MINUS]);
>         waveampcoeffs[PN00_A + AMPCOEFF_DIM * PLUS_] = 0.25 * ((stp[2] - 2.) * (    //
>                 /*  */cos(phin[2] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                 /**/+ cos(phin[2] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS]    //
>                 ) - 2. * skp[1] * s2t * (    //
>                 /*  */sin(phin[1] + psin[2]) * k[PLUS_]
>                 /**/+ sin(phin[1] - psin[2]) * k[MINUS]    //
>                 ) + 6. * skp[2] * stp[2] * cos(psin[2]));
>         waveampcoeffs[PN00_A + AMPCOEFF_DIM * MINUS] = 0.5 * (ctp[1] * (    //
>                 /*  */sin(phin[2] + psin[2]) * params->ccoeff00pn[0 + PN00DIM * PLUS_]
>                 /**/+ sin(phin[2] - psin[2]) * params->ccoeff00pn[0 + PN00DIM * MINUS]    //
>                 ) - 2. * stp[1] * skp[1] * (    //
>                 /*  */cos(phin[1] + psin[2]) * k[PLUS_]
>                 /**/+ cos(phin[1] - psin[2]) * k[MINUS]));
>     }
>     }
>     REAL8 vP[OMEGA_POWER_DIM];// = { 1., };
>     vP[0] = 1.;
>     vP[1] = cbrt(params->totalmass * expr[OMEGA] * G_CP2 / LAL_C_SI);
>     for (int i = 2; i < OMEGA_POWER_DIM; ++i) {
>         vP[i] = vP[1] * vP[i - 1];
>     }
>     params->eps = vP[2];
>     REAL8 eta = params->nu / (1. + params->nu) / (1. + params->nu);
>     REAL8 eps_corr[PN_ORDER][PN_ORDER];
>     eps_corr[PN00][PN10] = params->eps
>             * (1. + vP[2] * (1. - eta / 3.) + vP[3] * (eta + (2. / 3.) * (eta / params->nu)));
>     eps_corr[PN05][PN10] = eps_corr[PN00][PN10];
>     eps_corr[PN00][PN15] = params->eps
>             * (1. + vP[2] * (1. - eta / 3.) + vP[3] * (eta + (2. / 3.) / (eta / params->nu))
>                     + vP[4]
>                             * (1. - 65. / 12. * eta
>                                     - params->chi1 * params->chi1 * params->nu * eta * (3. * ckp[2] - 1.) / 4.));
>     REAL8 epssqrt = sqrt(params->eps);
>     params->xi = params->nu / epssqrt; // second small parameter
> 
>     REAL8 h[PLUS_CROSS_DIM] = { 0., 0. };
>     switch (params->pnamp) {
>     case (PNDEF): //default value -1 contains all corrections
>     case (PN15):
>         // Highest order, only leading order of eps(omega) is needed.
>         for (int i = PLUS_; i < PLUS_CROSS_DIM; ++i) {
>             h[i] += params->eps * epssqrt
>                     * (waveampcoeffs[PN15_A + AMPCOEFF_DIM * i] + waveampcoeffs[PN15_B + AMPCOEFF_DIM * i]
>                             + waveampcoeffs[PN15_C + AMPCOEFF_DIM * i]);
>         }
>         /* no break */
>     case (PN10):
>         // Since highest order is 1.5 PN and there is no 0.5 PN order correction to eps(omega), leading order eps is enough.
>         for (int i = PLUS_; i < PLUS_CROSS_DIM; ++i) {
>             h[i] += params->eps
>                     * (4. * params->xi * waveampcoeffs[PN05_A + AMPCOEFF_DIM * i] //
>                     + waveampcoeffs[PN10_A + AMPCOEFF_DIM * i] + waveampcoeffs[PN10_C + AMPCOEFF_DIM * i]
>                             + params->beta1 * waveampcoeffs[PN10_B + AMPCOEFF_DIM * i]
>                             + params->beta1 * waveampcoeffs[PN10_D + AMPCOEFF_DIM * i]);
>         }
>         /* no break */
>     case (PN05):
>         //The 0.5 PN correction needs to include 1 PN correction of eps(omega) the amplitude is taken to 1.5 PN order
>         for (int i = PLUS_; i < PLUS_CROSS_DIM; ++i) {
>             REAL8 temp = waveampcoeffs[PN05_A + AMPCOEFF_DIM * i]
>                     + params->beta1 * waveampcoeffs[PN05_B + AMPCOEFF_DIM * i]
>                     - 2. * params->xi * waveampcoeffs[PN00_A + AMPCOEFF_DIM * i];
>             if (params->pnamp == PN15) {
>                 h[i] += 1. / (params->eps * epssqrt) * (eps_corr[PN05][PN10] * sqrt(eps_corr[PN05][PN10]) * temp);
>             } else {
>                 h[i] += /*                                                                      */epssqrt * temp;
>             }
>         }
>         /* no break */
>     case (PN00):
>         // If the amplitude is taken to 1 PN order, the eps(omega) needs to include the 1 PN correction, if amplitude is taken to 1.5 PN order, that eps(omega) needs to include corrections up to 1.5 PN order
>         for (int i = PLUS_; i < PLUS_CROSS_DIM; ++i) {
>             REAL8 temp = waveampcoeffs[PN00_A + AMPCOEFF_DIM * i]
>                     + params->beta1 * waveampcoeffs[PN00_B + AMPCOEFF_DIM * i];
>             if (params->pnamp == PN15) {
>                 h[i] += 1. / (params->eps * epssqrt) * eps_corr[PN00][PN15] * sqrt(eps_corr[PN00][PN15]) * temp;
>             } else if (params->pnamp == PN10) {
>                 h[i] += 1. / (params->eps * epssqrt) * eps_corr[PN00][PN10] * sqrt(eps_corr[PN00][PN10]) * temp;
>             } else {
>                 h[i] += /*                                                                               */temp;
>             }
>         }
>         break;
>     }
>     REAL8 ampcoeff = 2. * G_CP2 * params->totalmass * params->eps * epssqrt * params->xi / params->dist;
>     (*hplus)->data->data[idx] = ampcoeff * h[PLUS_];
>     (*hcross)->data->data[idx] = ampcoeff * h[MINUS];
>     XLALFreeDmatrix(waveampcoeffs);
>     return XLAL_SUCCESS;
> }
695c1171
<  * Interface routine, calculating the preferred variables for the Spin-dominated waveforms
---
>  * Interface routine, calculating the prefered variables for the Spin-dominated waveforms
697,769c1173,1257
< int XLALSimInspiralSpinDominatedWaveformInterfaceTD(
< 	REAL8TimeSeries **hplus,        /**< +-polarization waveform */
< 	REAL8TimeSeries **hcross,       /**< x-polarization waveform */
< 	REAL8 deltaT,                   /**< sampling interval (s) */
< 	REAL8 m1,                       /**< mass of companion 1 (kg) */
< 	REAL8 m2,                       /**< mass of companion 2 (kg) */
< 	REAL8 fStart,                   /**< start GW frequency (Hz) */
< 	REAL8 fRef,			/**< end GW frequency (Hz) */
< 	REAL8 D,                        /**< distance of source (m) */
< 	REAL8 s1x,                      /**< initial value of S1x */
< 	REAL8 s1y,                      /**< initial value of S1y */
< 	REAL8 s1z,                      /**< initial value of S1z */
< 	REAL8 lnhatx,                   /**< initial value of LNhatx */
< 	REAL8 lnhaty,                   /**< initial value of LNhaty */
< 	REAL8 lnhatz,                   /**< initial value of LNhatz */
< 	int phaseO,                     /**< twice PN phase order */
< 	int amplitudeO,                 /**< twice PN amplitude order */
< 	REAL8 phiRef			/**< Reference phase at the Reference Frequency */
< )
< {
< REAL8 totalmass, nu, chi1, beta1, kappa1, totalJ, S1, Jx, Jy, Jz, omega, eta, romega, v, LN, theta;
< REAL8 alpha0, phin0, JxNx, JxNy, JxNz, inertiaxx, inertiaxy, inertiaxz, JxLx, JxLy, JxLz, LXYx, LXYy, LXYz;
< int n;
< totalmass=m1+m2;
< if (m1 > m2) nu=m2/m1; else nu=m1/m2;
< if (LAL_SDW_MAX_PN_PARAM < 100.*nu*nu) {
< XLALPrintError("XLAL Error: Spin-dominated waveforms error: Please make sure that the total mass is higher than 45 solar mass, and mass ratio is lower than 0.03125. Also above 130 solar mass be aware that high starting frequency may result in termination right after start, due to high value of the pn parameter. \n");
< XLAL_ERROR(XLAL_EDOM);
< } //too high mass ratio for the waveform, abort
< omega = fStart * LAL_PI;
< eta = nu/(1.+nu)/(1.+nu);
< chi1 = sqrt(s1x*s1x+s1y*s1y+s1z*s1z);
< if (chi1 < 0.5) {
< XLALPrintError("XLAL Error: Spin-dominated waveforms error: Please make sure that the dimensionless spin parameter is higher than 0.5 \n");
< XLAL_ERROR(XLAL_EDOM);
< }
< kappa1 = acos((lnhatx*s1x+lnhaty*s1y+lnhatz*s1z)/chi1);
< // Calculate the orbital angular momentum, up to 1.5 PN, with SO corrections
< v=cbrt(LAL_G_SI*totalmass*omega/LAL_C_SI/LAL_C_SI/LAL_C_SI);
< romega=LAL_G_SI*totalmass/LAL_C_SI/LAL_C_SI/v/v*(1.); //-(3.-eta)*v*v/3.-v*v*v/3.*(2./(1.+nu)/(1.+nu)+3.*eta)-v*v*v*v*(-eta*(19./4.+eta/9.)+1./4.*(-chi1*chi1*eta*nu)*(3.*cos(kappa1)*cos(kappa1)-1.)));
< LN = eta * totalmass * romega * romega * omega;
< // Calculate Spin magnitude, and the total angular momentum J
< S1 = chi1 * LAL_G_SI / LAL_C_SI * totalmass * totalmass * eta / nu;
< Jx = LN*lnhatx + S1 * s1x/chi1;
< Jy = LN*lnhaty + S1 * s1y/chi1;
< Jz = LN*lnhatz + S1 * s1z/chi1;
< totalJ = sqrt(Jx*Jx + Jy*Jy + Jz*Jz);
< // calculate the remaining angles
< theta = acos(Jz/totalJ);
< if (kappa1 == 0) {
< phin0=3.*LAL_PI_2;
< beta1 = 0;
< } else {
< beta1 = acos((Jx*s1x+Jy*s1y+Jz*s1z)/totalJ/chi1);
< // calculating the initial value of the \f$\phi_n\f$ variable
< JxNx = Jx/totalJ*1.0;
< JxNy = - Jx/totalJ*1.0;
< JxNz = 0.;
< inertiaxx = JxNy*Jz/totalJ-JxNz*Jy/totalJ;
< inertiaxy = JxNz*Jx/totalJ-JxNx*Jz/totalJ;
< inertiaxz = JxNx*Jy/totalJ-JxNy*Jx/totalJ;
< JxLx = Jy/totalJ*lnhatz - Jz/totalJ*lnhaty;
< JxLy = Jz/totalJ*lnhatx - Jx/totalJ*lnhatz;
< JxLz = Jx/totalJ*lnhaty - Jy/totalJ*lnhatx;
< LXYx = JxLy*Jz/totalJ-JxLz*Jy/totalJ;
< LXYy = JxLz*Jx/totalJ-JxLy*Jz/totalJ;
< LXYz = JxLx*Jy/totalJ-JxLy*Jx/totalJ;
< alpha0 = acos(inertiaxx*LXYx + inertiaxy*LXYy + inertiaxz*LXYz);
< phin0=3.*LAL_PI_2-alpha0;
< }
< // calling the SDW driver with the prefered variables
< n = XLALSimInspiralSpinDominatedWaveformDriver(hplus, hcross, totalmass, nu, chi1, D, kappa1, beta1, theta, fStart, fRef, phaseO, amplitudeO, deltaT, phiRef, phin0);
< return n;
---
> int XLALSimInspiralSpinDominatedWaveformInterfaceTD(REAL8TimeSeries **hplus, /**< +-polarization waveform */
> REAL8TimeSeries **hcross, /**< x-polarization waveform */
> REAL8 deltaT, /**< sampling interval (s) */
> REAL8 m1, /**< mass of companion 1 (kg) */
> REAL8 m2, /**< mass of companion 2 (kg) */
> REAL8 fStart, /**< start GW frequency (Hz) */
> REAL8 fRef, /**< end GW frequency (Hz) */
> REAL8 D, /**< distance of source (m) */
> REAL8 s1x, /**< initial value of S1x */
> REAL8 s1y, /**< initial value of S1y */
> REAL8 s1z, /**< initial value of S1z */
> REAL8 lnhatx, /**< initial value of LNhatx */
> REAL8 lnhaty, /**< initial value of LNhaty */
> REAL8 lnhatz, /**< initial value of LNhatz */
> int phaseO, /**< twice PN phase order */
> int amplitudeO, /**< twice PN amplitude order */
> REAL8 phiRef /**< Reference phase at the Reference Frequency */
> ) {
>     enum {
>         X, Y, Z, DIM_XYZ,
>     };
>     REAL8 totalmass, nu, chi1, beta1, kappa1, totalJ, S1, omega, eta, romega, v, LN, theta;
>     REAL8 alpha0, phin0;
>     totalmass = m1 + m2;
>     if (m1 > m2) {
>         nu = m2 / m1;
>     } else {
>         nu = m1 / m2;
>     }
>     if (LAL_SDW_MAX_PN_PARAM < 100. * nu * nu) {
>         XLALPrintError(
>                 "XLAL Error: Spin-dominated waveforms error: Please make sure that the total mass is higher than 45 solar mass, and mass ratio is lower than 0.03125. Also above 130 solar mass be aware that high starting frequency may result in termination right after start, due to high value of the pn parameter. \n");
>         XLAL_ERROR(XLAL_EDOM);
>     } //too high mass ratio for the waveform, abort
>     omega = fStart * LAL_PI;
>     eta = nu / (1. + nu) / (1. + nu);
>     chi1 = sqrt(s1x * s1x + s1y * s1y + s1z * s1z);
>     if (chi1 < 0.5) {
>         XLALPrintError(
>                 "XLAL Error: Spin-dominated waveforms error: Please make sure that the dimensionless spin parameter is higher than 0.5 \n");
>         XLAL_ERROR(XLAL_EDOM);
>     }
>     REAL8 Lnh[DIM_XYZ] = { lnhatx, lnhaty, lnhatz };
>     REAL8 LNHdotS1 = (Lnh[X] * s1x + Lnh[Y] * s1y + Lnh[Z] * s1z) / chi1;
>     if (LNHdotS1 - 1.0 > 0 && LNHdotS1 - 1.0 < 1.0e-12)
>         {kappa1 = acos(1.0);
>     } else {
>         kappa1 = acos((Lnh[X] * s1x + Lnh[Y] * s1y + Lnh[Z] * s1z) / chi1);
>         }
> 
>     // Calculate the orbital angular momentum, up to 1.5 PN, with SO corrections
>     v = cbrt(G_CP2 * totalmass * omega / LAL_C_SI);
>     romega = G_CP2 * totalmass / v / v * (1.); //-(3.-eta)*v*v/3.-v*v*v/3.*(2./(1.+nu)/(1.+nu)+3.*eta)-v*v*v*v*(-eta*(19./4.+eta/9.)+1./4.*(-chi1*chi1*eta*nu)*(3.*cos(kappa1)*cos(kappa1)-1.)));
>     LN = eta * totalmass * romega * romega * omega;
>     // Calculate Spin magnitude, and the total angular momentum J
>     S1 = chi1 * LAL_G_SI / LAL_C_SI * totalmass * totalmass * eta / nu;
>     REAL8 JxN[DIM_XYZ], JxL[DIM_XYZ], LXY[DIM_XYZ], inertiax[DIM_XYZ];
>     REAL8 J[DIM_XYZ] = { LN * Lnh[X] + S1 * s1x / chi1, LN * Lnh[Y] + S1 * s1y / chi1, LN * Lnh[Z] + S1 * s1z / chi1 };
>     totalJ = sqrt(J[X] * J[X] + J[Y] * J[Y] + J[Z] * J[Z]);
>     // calculate the remaining angles
>     theta = acos(J[Z] / totalJ);
>     if (kappa1 < 1e-7) {
>         kappa1 = 0.;
>         phin0 = 3. * LAL_PI_2;
>         beta1 = 0.;
>     } else if (kappa1 - LAL_PI > 0 && kappa1 - LAL_PI < 1.0e-12) {
> 	    kappa1 = LAL_PI;
>         phin0 = 3. * LAL_PI_2;
>         beta1 = LAL_PI;
> 	} else {
>         beta1 = acos((J[X] * s1x + J[Y] * s1y + J[Z] * s1z) / totalJ / chi1);
>         // calculating the initial value of the phi_n variable
>         JxN[X] = +J[Y] / totalJ * 1.0;
>         JxN[Y] = -J[X] / totalJ * 1.0;
>         JxN[Z] = +0.;
>         vectorProd(JxN, J, totalJ, inertiax);
>         vectorProd(J, Lnh, totalJ, JxL);
>         vectorProd(JxL, J, totalJ, LXY);
>         alpha0 = acos(inertiax[X] * LXY[X] + inertiax[Y] * LXY[Y] + inertiax[Z] * LXY[Z]);
>         phin0 = 3. * LAL_PI_2 - alpha0;
>     }
>     // calling the SDW driver with the prefered variables
>     int n = XLALSimInspiralSpinDominatedWaveformDriver(hplus, hcross, totalmass, nu, chi1, D, kappa1, beta1, theta,
>             fStart, fRef, phaseO, amplitudeO, deltaT, phiRef, phin0);
>     return n;
777,882c1265,1386
< int XLALSimInspiralSpinDominatedWaveformDriver(
< 	REAL8TimeSeries **hplus,        /**< +-polarization waveform */
< 	REAL8TimeSeries **hcross,       /**< x-polarization waveform */
< 	REAL8 totalmass,		/**< total mass of the binary */
< 	REAL8 nu,			/**< mass ratio */
< 	REAL8 chi1,			/**< dimensionless spin paramter */
< 	REAL8 D,			/**< Distance to the source */
< 	REAL8 kappa1,			/**< Angle span by S_1 and L */
< 	REAL8 beta1,			/**< Angle span by J and S_1 */
< 	REAL8 theta,			/**< Angle span by the line of sight and J */
< 	REAL8 fStart,			/**< Starting gravitational wave frequency*/
< 	REAL8 fRef,			/**< Ending gravitational wave frequency*/
< 	int phaseO,                     /**< twice PN phase order */
< 	int amplitudeO,                 /**< twice PN amplitude order */
< 	REAL8 deltaT,			/**< Sampling time interval */
< 	REAL8 phiRef,			/**< Reference phase at the Reference Frequency */
< 	REAL8 phin0			/**< Starting value of the \f$\phi_n\f$ parameter */
< )
< {
< int idx;
< int n;
< unsigned int i;
< REAL8 phiShift;
< LIGOTimeGPS tStart=LIGOTIMEGPSZERO;
< /* check inputs for sanity */
< if (*hplus) XLAL_ERROR(XLAL_EFAULT);
< if (*hcross) XLAL_ERROR(XLAL_EFAULT);
< if (deltaT <= 0) XLAL_ERROR(XLAL_EDOM);
< if (totalmass < 0) XLAL_ERROR(XLAL_EDOM);
< if (fStart <= 0) XLAL_ERROR(XLAL_EDOM);
< /* set up the integrator*/
< LALAdaptiveRungeKutta4Integrator *integrator= XLALAdaptiveRungeKutta4Init(LAL_SDW_NUM_VARIABLES,XLALSpinDominatedWaveformDerivatives,XLALSpinDominatedWaveformStoppingTest,LAL_SDW_ABSOLUTE_TOLERANCE,LAL_SDW_RELATIVE_TOLERANCE);
< if (!integrator) {
< 	XLALPrintError("XLAL Error - %s: Cannot allocate integrator\n", __func__);
< 	XLAL_ERROR(XLAL_EFUNC);
< }
< /* stop the integration only when the test is true */
< integrator->stopontestonly = 1;
< LALSDWaveformParams params;
< params.totalmass=totalmass;
< params.nu=nu;
< params.chi1=chi1;
< params.dist=D;
< params.kappa1=kappa1;
< params.beta1=beta1;
< params.theta=theta;
< params.eps=0.;
< params.xi=0.;
< params.pnamp=amplitudeO;
< params.pnphase=phaseO;
< params.prevdomega=0.;
< n = XLALSpinDominatedWaveformConstantCoefficients(&params);
< if( n < 0 ) XLAL_ERROR(XLAL_EFUNC);
< REAL8 yin[LAL_SDW_NUM_VARIABLES];
< yin[0]=phin0;
< yin[1]=fStart*LAL_PI;
< yin[2]=0.;
< REAL8Array *yout;
< // estimating the length of the waveform
< REAL8 length=5./256.*pow(fStart*LAL_PI,-8./3.)*(1+params.nu)*(1+params.nu)/params.nu*pow(LAL_G_SI*params.totalmass/LAL_C_SI/LAL_C_SI/LAL_C_SI,-5./3.);
< INT4 intLen    = XLALAdaptiveRungeKutta4Hermite(integrator,(void *)&params,yin,0.0,length,deltaT,&yout);
< UNUSED INT4 intReturn = integrator->returncode;
< XLALAdaptiveRungeKutta4Free(integrator);
< REAL8TimeSeries *phin  = XLALCreateREAL8TimeSeries( "PHI_N", &tStart, 0., deltaT, &lalDimensionlessUnit, intLen);
< REAL8TimeSeries *omega = XLALCreateREAL8TimeSeries( "OMEGA", &tStart, 0., deltaT, &lalDimensionlessUnit, intLen);
< REAL8TimeSeries *psi   = XLALCreateREAL8TimeSeries( "ORBITAL_PHASE", &tStart, 0., deltaT, &lalDimensionlessUnit, intLen);
< for (idx=0;idx<intLen;idx++) {
< 	phin->data->data[idx]    = yout->data[intLen+idx];
< 	omega->data->data[idx]  = yout->data[2*intLen+idx];
< 	psi->data->data[idx]  = yout->data[3*intLen+idx];
< }
< 
< if (fRef == 0){
< 	phiShift = phiRef - psi->data->data[0];
< 	for( i=0; i < psi->data->length; i++){
< 		psi->data->data[i] += phiShift;
<         }
< } else if (fRef == fStart) {
< 	phiShift = phiRef - psi->data->data[0];
< 	for( i=0; i < psi->data->length; i++){
< 		psi->data->data[i] += phiShift;
< 	}
< } else {
< 	XLALPrintError("XLAL Error: Spin-dominated waveforms error: Please set the reference frequency as the starting frequency, Setting 0 will default to the starting frequency. \n");
< 	XLAL_ERROR(XLAL_EDOM);
< }
< if ((*hplus) && (*hcross)) {
< 	if ((*hplus)->data->length!=(*hcross)->data->length) {
< 	XLALPrintError("***  h+ and hx differ in length\n");
< 	XLAL_ERROR(XLAL_EFAILED);
< } else {
< 	if ((int)(*hplus)->data->length<intLen) {
< 	XLALPrintError("*** ERROR: h+ and hx too short\n");
< 	XLAL_ERROR(XLAL_EFAILED);
< } else {
< 	XLALGPSAdd(&((*hplus)->epoch),-intLen*deltaT);
< 	XLALGPSAdd(&((*hcross)->epoch),-intLen*deltaT);
< }
< 	}
< } else {
< 	XLALGPSAdd(&tStart,-intLen*deltaT);
< 	*hplus  = XLALCreateREAL8TimeSeries("H+", &tStart, 0.0, deltaT, &lalStrainUnit, intLen);
< 	*hcross = XLALCreateREAL8TimeSeries("Hx", &tStart, 0.0, deltaT, &lalStrainUnit, intLen);
< 	if(*hplus == NULL || *hcross == NULL)
< 	XLAL_ERROR(XLAL_ENOMEM);
< }
---
> int XLALSimInspiralSpinDominatedWaveformDriver(REAL8TimeSeries **hplus, /**< +-polarization waveform */
> REAL8TimeSeries **hcross, /**< x-polarization waveform */
> REAL8 totalmass, /**< total mass of the binary */
> REAL8 nu, /**< mass ratio */
> REAL8 chi1, /**< dimensionless spin paramter */
> REAL8 D, /**< Distance to the source */
> REAL8 kappa1, /**< Angle span by S_1 and L */
> REAL8 beta1, /**< Angle span by J and S_1 */
> REAL8 theta, /**< Angle span by the line of sight and J */
> REAL8 fStart, /**< Starting gravitational wave frequency*/
> REAL8 fRef, /**< Ending gravitational wave frequency*/
> int phaseO, /**< twice PN phase order */
> int amplitudeO, /**< twice PN amplitude order */
> REAL8 deltaT, /**< Sampling time interval */
> REAL8 phiRef, /**< Reference phase at the Reference Frequency */
> REAL8 phin0 /**< Starting value of the phi_n parameter */
> ) {
>     int idx;
>     int n;
>     unsigned int i;
>     REAL8 phiShift;
>     LIGOTimeGPS tStart = LIGOTIMEGPSZERO;
>     /* check inputs for sanity */
>     if (*hplus) {
>         XLAL_ERROR(XLAL_EFAULT);
>     }
>     if (*hcross) {
>         XLAL_ERROR(XLAL_EFAULT);
>     }
>     if (deltaT <= 0) {
>         XLAL_ERROR(XLAL_EDOM);
>     }
>     if (totalmass < 0) {
>         XLAL_ERROR(XLAL_EDOM);
>     }
>     if (fStart <= 0) {
>         XLAL_ERROR(XLAL_EDOM);
>     }
>     /* set up the integrator*/
>     LALAdaptiveRungeKutta4Integrator *integrator = XLALAdaptiveRungeKutta4Init(LAL_SDW_NUM_VARIABLES,
>             XLALSpinDominatedWaveformDerivatives, XLALSpinDominatedWaveformStoppingTest, LAL_SDW_ABSOLUTE_TOLERANCE,
>             LAL_SDW_RELATIVE_TOLERANCE);
>     if (!integrator) {
>         XLALPrintError("XLAL Error - %s: Cannot allocate integrator\n", __func__);
>         XLAL_ERROR(XLAL_EFUNC);
>     }
>     /* stop the integration only when the test is true */
>     integrator->stopontestonly = 1;
>     LALSDWaveformParams params;
>     params.totalmass = totalmass;
>     params.nu = nu;
>     params.chi1 = chi1;
>     params.dist = D;
>     params.kappa1 = kappa1;
>     params.beta1 = beta1;
>     params.theta = theta;
>     params.eps = 0.;
>     params.xi = 0.;
>     params.pnamp = amplitudeO;
>     params.pnphase = phaseO;
>     params.prevdomega = 0.;
>     n = XLALSpinDominatedWaveformConstantCoefficients(&params);
>     if (n < 0) {
>         XLAL_ERROR(XLAL_EFUNC);
>     }
>     REAL8 yin[LAL_SDW_NUM_VARIABLES];
>     yin[PHI] = phin0;
>     yin[OMEGA] = fStart * LAL_PI;
>     yin[PSI] = 0.;
>     REAL8Array *yout;
>     // estimating the length of the waveform
>     REAL8 length = 5. / 256. * pow(fStart * LAL_PI, -8. / 3.) * (1 + params.nu) * (1 + params.nu) / params.nu
>             * pow(G_CP2 * params.totalmass / LAL_C_SI, -5. / 3.);
>     INT4 intLen = XLALAdaptiveRungeKutta4Hermite(integrator, (void *) &params, yin, 0.0, length, deltaT, &yout);
>     UNUSED INT4 intReturn = integrator->returncode;
>     XLALAdaptiveRungeKutta4Free(integrator);
>     REAL8TimeSeries *phin = XLALCreateREAL8TimeSeries("PHI_N", &tStart, 0., deltaT, &lalDimensionlessUnit, intLen);
>     REAL8TimeSeries *omega = XLALCreateREAL8TimeSeries("OMEGA", &tStart, 0., deltaT, &lalDimensionlessUnit, intLen);
>     REAL8TimeSeries *psi = XLALCreateREAL8TimeSeries("ORBITAL_PHASE", &tStart, 0., deltaT, &lalDimensionlessUnit,
>             intLen);
>     for (idx = 0; idx < intLen; idx++) {
>         phin->data->data[idx] = yout->data[intLen + idx];
>         omega->data->data[idx] = yout->data[2 * intLen + idx];
>         psi->data->data[idx] = yout->data[3 * intLen + idx];
>     }
> 
>     if (fRef == 0) {
>         phiShift = phiRef - psi->data->data[0];
>         for (i = 0; i < psi->data->length; i++) {
>             psi->data->data[i] += phiShift;
>         }
>     } else if (fRef == fStart) {
>         phiShift = phiRef - psi->data->data[0];
>         for (i = 0; i < psi->data->length; i++) {
>             psi->data->data[i] += phiShift;
>         }
>     } else {
>         XLALPrintError(
>                 "XLAL Error: Spin-dominated waveforms error: Please set the reference frequency as the starting frequency, Setting 0 will default to the starting frequency. \n");
>         XLAL_ERROR(XLAL_EDOM);
>     }
>     if ((*hplus) && (*hcross)) {
>         if ((*hplus)->data->length != (*hcross)->data->length) {
>             XLALPrintError("***  h+ and hx differ in length\n");
>             XLAL_ERROR(XLAL_EFAILED);
>         } else {
>             if ((int) (*hplus)->data->length < intLen) {
>                 XLALPrintError("*** ERROR: h+ and hx too short\n");
>                 XLAL_ERROR(XLAL_EFAILED);
>             } else {
>                 XLALGPSAdd(&((*hplus)->epoch), -intLen * deltaT);
>                 XLALGPSAdd(&((*hcross)->epoch), -intLen * deltaT);
>             }
>         }
>     } else {
>         XLALGPSAdd(&tStart, -intLen * deltaT);
>         *hplus = XLALCreateREAL8TimeSeries("H+", &tStart, 0.0, deltaT, &lalStrainUnit, intLen);
>         *hcross = XLALCreateREAL8TimeSeries("Hx", &tStart, 0.0, deltaT, &lalStrainUnit, intLen);
>         if (*hplus == NULL || *hcross == NULL) {
>             XLAL_ERROR(XLAL_ENOMEM);
>         }
>     }
884,896c1388,1402
< REAL8 expr[3];
< for (idx=0;idx<intLen;idx++) {
< 	expr[0]=phin->data->data[idx];
< 	expr[1]=omega->data->data[idx];
< 	expr[2]=psi->data->data[idx];
< 	n = XLALSpinDominatedWaveformBuild(&params, expr,hplus,hcross,idx);
< 	if( n < 0 ) XLAL_ERROR(XLAL_EFUNC);
< }
< XLALDestroyREAL8Array(yout);
< XLALDestroyREAL8TimeSeries(phin);
< XLALDestroyREAL8TimeSeries(omega);
< XLALDestroyREAL8TimeSeries(psi);
< return intLen;
---
>     REAL8 expr[3];
>     for (idx = 0; idx < intLen; idx++) {
>         expr[PHI] = phin->data->data[idx];
>         expr[OMEGA] = omega->data->data[idx];
>         expr[PSI] = psi->data->data[idx];
>         n = XLALSpinDominatedWaveformBuild(&params, expr, hplus, hcross, idx);
>         if (n < 0) {
>             XLAL_ERROR(XLAL_EFUNC);
>         }
>     }
>     XLALDestroyREAL8Array(yout);
>     XLALDestroyREAL8TimeSeries(phin);
>     XLALDestroyREAL8TimeSeries(omega);
>     XLALDestroyREAL8TimeSeries(psi);
>     return intLen;
899,901c1405
< /** @} */
< 
< /*
---
> /**
903,904c1407,1408
<  * The first paramter is \f$\phi_n\f$, Eq 27 of Arxiv:1005.5330, taken for 1 spin case, and integrated over an orbital period.
<  * The second parameter is \f$\omega\f$, the derivative is taken from Arxiv: astro-ph/0504538, up to 2 PN orders with 1 spin. (In order to stay consistent with SDW)
---
>  * The first paramter is phi_n, Eq 27 of Arxiv:1005.5330, taken for 1 spin case, and integrated over an orbital period.
>  * The second parameter is omega, the derivative is taken from Arxiv: astro-ph/0504538, up to 2 PN orders with 1 spin. (In order to stay consistent with SDW)
907,934c1411,1451
< static INT4 XLALSpinDominatedWaveformDerivatives(UNUSED REAL8 t,
< 					const REAL8 values[],
< 					REAL8 dvalues[],
< 					void *mparams)
< {
<   LALSDWaveformParams *params = (LALSDWaveformParams *) mparams;
< // parameters required for the time derivatives
< REAL8 v=cbrt(LAL_G_SI*params->totalmass*values[1]/LAL_C_SI/LAL_C_SI/LAL_C_SI);
< params->eps=v*v;
< params->xi=params->nu/sqrt(params->eps); // second small parameter
< REAL8 phasecoeff=96./5.*params->nu/(1.+ params->nu)/(1.+ params->nu)*v*v*v*v*v*values[1]*values[1];
< // Calculating the derivatives
< 
< dvalues[0]=0;
< if (params->kappa1 == 0) {
< dvalues[0]=0;
< } else {
< switch (params->pnphase) {
< 	case 4:
< 	dvalues[0]+=+3./2./LAL_G_SI/params->totalmass/sin(params->kappa1)*params->chi1*params->chi1*LAL_C_SI*LAL_C_SI*LAL_C_SI*params->eps*params->eps*params->eps*sqrt(params->eps)*((1.-2.*params->xi*sqrt(params->eps))*sin(params->kappa1)*cos(params->kappa1)+params->beta1*cos(params->kappa1)*cos(params->kappa1));
< 	case 3:
< 	dvalues[0]+=params->chi1*LAL_C_SI*LAL_C_SI*LAL_C_SI*params->eps*params->eps*params->eps/2./LAL_G_SI/params->totalmass*(-4.*cos(params->kappa1)*params->beta1+5*sqrt(params->eps)*params->xi-4.);
< 	case 2:
< 	case 1:
< 	case 0:
< 	break;
< }
< }
---
> static INT4 XLALSpinDominatedWaveformDerivatives(UNUSED REAL8 t, const REAL8 values[], REAL8 dvalues[], void *mparams) {
>     LALSDWaveformParams *params = (LALSDWaveformParams *) mparams;
>     // parameters required for the time derivatives
>     REAL8 vP[OMEGA_POWER_DIM];
>     vP[0] = 1.;
>     vP[1] = cbrt(LAL_G_SI * params->totalmass * values[OMEGA] / LAL_C_SI / LAL_C_SI / LAL_C_SI);
>     for (int i = 2; i < OMEGA_POWER_DIM; ++i) {
>         vP[i] = vP[1] * vP[i - 1];
>     }
>     // TODO wouldn't be better to use v instead of eps? Or sqrtEpsP[i]?
>     params->eps = vP[2];
>     REAL8 epsP3 = params->eps * params->eps * params->eps;
>     params->xi = params->nu / sqrt(params->eps); // second small parameter
>     REAL8 eta = params->nu / (1. + params->nu) / (1. + params->nu);
>     REAL8 phasecoeff = 96. / 5. * eta * vP[5] * values[OMEGA] * values[OMEGA];
>     REAL8 sinKappa1 = sin(params->kappa1);
>     REAL8 cosKappa1 = cos(params->kappa1);
>     // Calculating the derivatives
> 
>     dvalues[PHI] = 0;
>     if (params->kappa1 != 0 ) {
>         switch (params->pnphase) {
>         case (PNDEF): //default value -1 contains all corrections
>         case (PN20):
>             dvalues[PHI] += +3. / 2. / LAL_G_SI / params->totalmass / sinKappa1 * params->chi1 * params->chi1 * LAL_C_SI
>                     * LAL_C_SI * LAL_C_SI * epsP3 * sqrt(params->eps)
>                     * ((1. - 2. * params->xi * sqrt(params->eps)) * sinKappa1 * cosKappa1
>                             + params->beta1 * cosKappa1 * cosKappa1);
>             /* no break */
>         case (PN15):
>             dvalues[PHI] += params->chi1 * LAL_C_SI * LAL_C_SI * LAL_C_SI * epsP3 / 2. / LAL_G_SI / params->totalmass
>                     * (-4. * cosKappa1 * params->beta1 + 5 * sqrt(params->eps) * params->xi - 4.);
>             /* no break */
>         case (PN10):
>             /* no break */
>         case (PN05):
>             /* no break */
>         case (PN00):
>             break;
>         }
>     }
936,953c1453,1478
< dvalues[1]=0;
< switch (params->pnphase) {
< 	case 4:
< 	dvalues[1]+=phasecoeff*v*v*v*v*(34103./18144.+13661./2016.*params->nu/(1.+ params->nu)/(1.+ params->nu)+59./18.*params->nu/(1.+ params->nu)/(1.+ params->nu)*params->nu/(1.+ params->nu)/(1.+ params->nu));
< 	// QM and Self-Spin components taken together
< 	dvalues[1]+=phasecoeff*v*v*v*v*(5./2.*params->chi1*params->chi1/(1.+ params->nu)/(1.+ params->nu)*(3.*cos(params->kappa1)*cos(params->kappa1)-1.)+1./96.*params->chi1*params->chi1/(1.+ params->nu)/(1.+ params->nu)*(6.+sin(params->kappa1)*sin(params->kappa1)));
< 	case 3:
< 	dvalues[1]+=phasecoeff*v*v*v*(4.*LAL_PI);
< 	// SO component
< 	dvalues[1]+=phasecoeff*v*v*v*(-1/12.*cos(params->kappa1)*params->chi1*(113./(1.+ params->nu)/(1.+ params->nu)+75.*params->nu/(1.+ params->nu)/(1.+ params->nu)));
< 	case 2:
< 	dvalues[1]+=-phasecoeff*v*v*(743./336.+11./4.*params->nu/(1.+ params->nu)/(1.+ params->nu));
< 	case 1:
< 	case 0:
< 	dvalues[1]+=phasecoeff*(1.);
< 	break;
< }
< dvalues[2]=values[1];
---
>     dvalues[OMEGA] = 0;
>     switch (params->pnphase) {
>     case (PNDEF): //default value -1 contains all corrections
>     case (PN20):
>         dvalues[OMEGA] += phasecoeff * vP[PN20] * (34103. / 18144. + 13661. / 2016. * eta + 59. / 18. * eta * eta);
>         // QM and Self-Spin components taken together
>         dvalues[OMEGA] += phasecoeff * vP[PN20]
>                 * (5. / 2. * params->chi1 * params->chi1 * eta / params->nu * (3. * cosKappa1 * cosKappa1 - 1.)
>                         + 1. / 96. * params->chi1 * params->chi1 * eta / params->nu * (6. + sinKappa1 * sinKappa1));
>         /* no break */
>     case (PN15):
>         dvalues[OMEGA] += phasecoeff * vP[PN15] * (4. * LAL_PI);
>         // SO component
>         dvalues[OMEGA] += phasecoeff * vP[PN15]
>                 * (-1 / 12. * cosKappa1 * params->chi1 * (113. * eta / params->nu + 75. * eta));
>         /* no break */
>     case (PN10):
>         dvalues[OMEGA] += -phasecoeff * vP[PN10] * (743. / 336. + 11. / 4. * eta);
>         /* no break */
>     case (PN05):
>         /* no break */
>     case (PN00):
>         dvalues[OMEGA] += phasecoeff * 1.;
>         break;
>     }
>     dvalues[PSI] = values[OMEGA];
955c1480
< return GSL_SUCCESS;
---
>     return GSL_SUCCESS;
958,1002c1483,1555
< 
< /*
< * Stopping test for the Spin-Dominated waveforms. Using MECO, or the desired ending frequency. The maximum value of the PN parameter is set to 0.8.
< */
< static INT4 XLALSpinDominatedWaveformStoppingTest(UNUSED REAL8 t, const REAL8 values[], REAL8 dvalues[], UNUSED void *mparams) {
< LALSDWaveformParams *params = (LALSDWaveformParams *) mparams;
< REAL8 v=cbrt(LAL_G_SI*params->totalmass*values[1]/LAL_C_SI/LAL_C_SI/LAL_C_SI);
< REAL8 eta = params->nu/(1.+ params->nu)/(1.+ params->nu);
< REAL8 omega  =  values[1];
< REAL8 domega =  dvalues[1];
< REAL8 d2omega = dvalues[1]-params->prevdomega;
< params->prevdomega = dvalues[1];
< REAL8 mecotest;
< mecotest=0.;
< 
< switch (params->pnphase) {
< 	case 4:
< 	mecotest+=6.*v*v*v*v*(1./8.*(-27.+19.*eta-eta*eta/3.)-(3.*cos(params->kappa1)*cos(params->kappa1)-1)/2.*params->chi1*params->chi1*eta/params->nu);
< 	case 3:
< 	mecotest+=5.*v*v*v*(8./3.*eta/params->nu+2.*eta)*cos(params->kappa1)*params->chi1;
< 	case 2:
< 	mecotest+=-4.* v * v * (3. + eta/3.)/4.;
< 	case 1:
< 	case 0:
< 	mecotest+=2.;
< 	break;
< }
< 
< if (mecotest<0) {
< 	XLALPrintWarning("** LALSimInspiralSDW WARNING **: MECO reached\n");
< 	return -1;
< } else if (isnan(omega)) {
< 	XLALPrintWarning("** LALSimInspiralSDW WARNING **: omega is NAN\n");
< 	return -1;
< } else if (v >= 1.) {
< 	XLALPrintWarning("** LALSimInspiralSDW WARNING **: PN parameter is too large\n");
< 	return -1;
< } else if (domega < 0.0) {
< 	XLALPrintWarning("** LALSimInspiralSDW WARNING **: domega < 0\n");
< 	return -1;
< } else if (d2omega <= 0.){
< 	XLALPrintWarning("** LALSimInspiralSDW WARNING **: d2omega < 0\n");
< 	return -1;
< } else
< 	return GSL_SUCCESS;
---
> /**
>  * Stopping test for the Spin-Dominated waveforms. Using MECO, or the desired ending frequency. The maximum value of the PN parameter is set to 0.8.
>  */
> static INT4 XLALSpinDominatedWaveformStoppingTest(UNUSED REAL8 t, const REAL8 values[], REAL8 dvalues[],
> UNUSED void *mparams) {
>     LALSDWaveformParams *params = (LALSDWaveformParams *) mparams;
>     REAL8 vP[OMEGA_POWER_DIM];
>     vP[0] = 1.;
>     vP[1] = cbrt(G_CP2 * params->totalmass * values[OMEGA] / LAL_C_SI);
>     for (int i = 2; i < OMEGA_POWER_DIM; ++i) {
>         vP[i] = vP[1] * vP[i - 1];
>     }
>     REAL8 cosKappa1 = cos(params->kappa1);
>     REAL8 eta = params->nu / (1. + params->nu) / (1. + params->nu);
>     REAL8 omega = values[OMEGA];
>     REAL8 domega = dvalues[OMEGA];
>     REAL8 d2omega = dvalues[OMEGA] - params->prevdomega;
>     params->prevdomega = dvalues[OMEGA];
>     REAL8 mecotest;
>     mecotest = 0.;
> 
>     switch (params->pnphase) {
>     case (PNDEF): //default value -1 contains all corrections
>     case (PN20):
>         mecotest += +6. * vP[PN20]
>                 * (1. / 8. * (-27. + 19. * eta - eta * eta / 3.)
>                         - (3. * cosKappa1 * cosKappa1 - 1) / 2. * params->chi1 * params->chi1 * eta / params->nu);
>         /* no break */
>     case (PN15):
>         mecotest += +5. * vP[PN15] * (8. / 3. * eta / params->nu + 2. * eta) * cosKappa1 * params->chi1;
>         /* no break */
>     case (PN10):
>         /* no break */
>         mecotest += -4. * vP[PN10] * (3. + eta / 3.) / 4.;
>         /* no break */
>     case (PN05):
>         /* no break */
>     case (PN00):
>         mecotest += +2.;
>         break;
>     }
> 
>     /* Check value of SEOBNRv2 stopping frequency */
> 
>     REAL8 mcheck1 = params->totalmass / (1. + params->nu);
>     REAL8 mcheck2 = params->totalmass - mcheck1;
>     REAL8 spincheckz1 = params->chi1 * cos(params->kappa1);
>     REAL8 spincheckz2 = 0.0;
>     REAL8 seobnr_stop_freq = XLALSimIMRSpinAlignedEOBPeakFrequency(mcheck1, mcheck2, spincheckz1, spincheckz2, 2);
> 
> 
>     if (mecotest < 0) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: MECO reached\n");
>         return -1;
> 
>     } else if (omega > seobnr_stop_freq*LAL_PI) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: SEOBNR stopping frequency reached\n");
>         return -1;
> 
>     } else if (isnan(omega)) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: omega is NAN\n");
>         return -1;
>     } else if (vP[1] >= 1.) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: PN parameter is too large\n");
>         return -1;
>     } else if (domega < 0.0) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: domega < 0\n");
>         return -1;
>     } else if (d2omega <= 0.) {
>         XLALPrintWarning("** LALSimInspiralSDW WARNING **: d2omega < 0\n");
>         return -1;
>     }
>     return GSL_SUCCESS;
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinDominatedWaveform.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinDominatedWaveform.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralSpinTaylor.c ./LALSimInspiralSpinTaylor.c
2c2
<  * Copyright (C) 2011 E. Ochsner, 2014 A. Klein
---
>  * Copyright (C) 2011 E. Ochsner, 2014 A. Klein, 2015 R. Sturani
40,48d39
< //#define UNUSED(expr) do { (void)(expr); } while (0)
< /*
< #ifdef __GNUC__
< #define UNUSED __attribute__ ((unused))
< #else
< #define UNUSED
< #endif
< */
< 
83,168d73
< /**
<  * Struct containing all of the non-dynamical coefficients needed
<  * to evolve a TaylorTx spinning, precessing binary and produce a waveform.
<  * This struct is passed to the static Derivatives and StoppingTest functions.
<  */
< typedef struct tagXLALSimInspiralSpinTaylorTxCoeffs
< {
< 	REAL8 M; ///< total mass in seconds
< 	REAL8 Mchirp; ///< chirp mass in seconds
< 	REAL8 eta; ///< symmetric mass ratio
< 	REAL8 m1M; ///< m1 / M
< 	REAL8 m2M; ///< m2 / M
< 	REAL8 wdotnewt; ///< leading order coefficient of wdot = \f$\dot{\omega}\f$
< 	REAL8 wdotcoeff[LAL_MAX_PN_ORDER]; ///< coeffs. of PN corrections to wdot
< 	REAL8 wdotlogcoeff; ///< coefficient of log term in wdot
< 	REAL8 Ecoeff[LAL_MAX_PN_ORDER]; ///< coeffs. of PN corrections to energy
< 	REAL8 wdotSO15s1, wdotSO15s2; ///< non-dynamical 1.5PN SO corrections
<         REAL8 wdotSS2, wdotSSO2; ///< non-dynamical 2PN SS corrections
< 	REAL8 wdotQM2S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
< 	REAL8 wdotQM2S1L; ///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
< 	REAL8 wdotQM2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
< 	REAL8 wdotQM2S2L; ///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
< 	REAL8 wdotSSselfS1; ///< non-dynamical S1^2 2PN self-spin correction
< 	REAL8 wdotSSselfS1L; ///< non-dynamical (S1.L)^2 self-spin correction
< 	REAL8 wdotSSselfS2; ///< non-dynamical S2^2 2PN self-spin correction
< 	REAL8 wdotSSselfS2L; ///< non-dynamical (S2.L)^2 self-spin correction
< 	REAL8 wdotSO25s1, wdotSO25s2; ///< non-dynamical 2.5PN SO corrections
< 	REAL8 wdotSO3s1, wdotSO3s2; ///< non-dynamical 3PN SO corrections
< 	REAL8 wdotSO35s1, wdotSO35s2; ///< non-dynamical 3.5PN SO corrections
< 	REAL8 ESO15s1, ESO15s2; ///< non-dynamical 1.5PN SO corrections
<         REAL8 ESS2,ESSO2; ///< non-dynamical 2PN SS correction
< 	REAL8 EQM2S1; ///< non-dynamical S1^2 2PN quadrupole-monopole correction
< 	REAL8 EQM2S1L;///< non-dynamical (S1.L)^2 2PN quadrupole-monopole correction
< 	REAL8 EQM2S2; ///< non-dynamical S2^2 2PN quadrupole-monopole correction
< 	REAL8 EQM2S2L;///< non-dynamical (S2.L)^2 2PN quadrupole-monopole correction
< 	REAL8 ESO25s1, ESO25s2; ///< non-dynamical 2.5PN SO corrections 
< 	REAL8 ESO35s1, ESO35s2; ///< non-dynamical 3.5PN SO corrections 
< 	REAL8 LNhatSO15s1, LNhatSO15s2; ///< non-dynamical 1.5PN SO corrections
< 	REAL8 LNhatSS2; ///< non-dynamical 2PN SS correction 
< 	REAL8 wdottidal5pn;	///< leading order tidal correction 
< 	REAL8 wdottidal6pn;	///< next to leading order tidal correction
< 	REAL8 Etidal5pn; ///< leading order tidal correction to energy
< 	REAL8 Etidal6pn; ///< next to leading order tidal correction to energy
< 	REAL8 fStart; ///< starting GW frequency of integration
< 	REAL8 fEnd; ///< ending GW frequency of integration
< 	LALSimInspiralSpinOrder spinO; ///< Twice PN order of included spin effects
< 	LALSimInspiralTidalOrder tideO;///< Twice PN order of included tidal effects
< 	REAL8 prev_domega; ///< Previous value of domega/dt used in stopping test
< 	REAL8 dEdvcoeff[LAL_MAX_PN_ORDER]; ///<dE/dv coeff>
< 	REAL8 Fcoeff[LAL_MAX_PN_ORDER];///FluxCoeff
<         REAL8 dEdvnewt; // newtonian term of dE by dv
<         REAL8 Fnewt; // newtonian term in Flux
< 	REAL8 Flogcoeff; //log coeff in flux
< 	REAL8 FSO35s1;
< 	REAL8 FSO35s2;
< 	REAL8 dEdvSO35s1;
< 	REAL8 dEdvSO35s2;
< 	REAL8 FSO3s1;
< 	REAL8 FSO3s2;
< 	REAL8 FSO25s1;
< 	REAL8 FSO25s2;
< 	REAL8 dEdvSO25s1;
< 	REAL8 dEdvSO25s2;
< 	REAL8 FSS2;
< 	REAL8 dEdvSS2;
< 	REAL8 FQM2S1;
< 	REAL8 FQM2S2;
< 	REAL8 FQM2S1L;
< 	REAL8 FQM2S2L;
< 	REAL8 FSSselfS1;
<         REAL8 FSSselfS2;
<         REAL8 FSSselfS1L;
<         REAL8 FSSselfS2L;
< 	REAL8 dEdvQM2S1;
<         REAL8 dEdvQM2S2;
<         REAL8 dEdvQM2S1L;
<         REAL8 dEdvQM2S2L;
< 	REAL8 FSO15s1;
< 	REAL8 FSO15s2;
< 	REAL8 dEdvSO15s1;
< 	REAL8 dEdvSO15s2;
< 	REAL8 dEdvSSO2;
< 	REAL8 FSSO2;
< 	REAL8 Ftidal5pn;     ///< leading order tidal correction
<         REAL8 Ftidal6pn;
< } XLALSimInspiralSpinTaylorTxCoeffs;
169a75,81
> static int XLALSimInspiralVectorCrossProduct(REAL8 **vout, REAL8 v1x, REAL8 v1y, REAL8 v1z, REAL8 v2x, REAL8 v2y, REAL8 v2z){
>     (*vout) = (double *) LALMalloc(sizeof(double) * 3);
>     (*vout)[0]=v1y*v2z-v1z*v2y;
>     (*vout)[1]=v1z*v2x-v1x*v2z;
>     (*vout)[2]=v1x*v2y-v1y*v2x;
>     return XLAL_SUCCESS;
> }
174,175d85
< static int XLALSimInspiralSpinTaylorT4Derivatives(double t, 
< 	const double values[], double dvalues[], void *mparams);
178,186d87
< static int XLALSimInspiralSpinTaylorT4Setup(
<     XLALSimInspiralSpinTaylorTxCoeffs *params, REAL8 m1, REAL8 m2,
<     REAL8 fStart, REAL8 fEnd, REAL8 lambda1, REAL8 lambda2,
<     REAL8 quadparam1, REAL8 quadparam2, LALSimInspiralSpinOrder spinO,
<     LALSimInspiralTidalOrder tideO, INT4 phaseO);
< static int XLALSimInspiralSpinTaylorT1Setup(
<     XLALSimInspiralSpinTaylorTxCoeffs *params, REAL8 m1, REAL8 m2,
<     REAL8 fStart, REAL8 fEnd, REAL8 lambda1, REAL8 lambda2,REAL8 quadparam1, REAL8 quadparam2,
<     LALSimInspiralSpinOrder spinO, LALSimInspiralTidalOrder tideO, INT4 phaseO);
188a90,91
> static int XLALSimInspiralSpinTaylorT1Setup(XLALSimInspiralSpinTaylorTxCoeffs *params, REAL8 m1, REAL8 m2, REAL8 fStart, REAL8 fEnd, REAL8 lambda1, REAL8 lambda2,REAL8 quadparam1, REAL8 quadparam2,
>     LALSimInspiralSpinOrder spinO, LALSimInspiralTidalOrder tideO, INT4 phaseO);
220d122
< 
353a256,268
> INT4 XLALSimSpinTaylorEnergySpinDerivativeSetup(
>     XLALSimInspiralSpinTaylorTxCoeffs *params, /**< UNDOCUMENTED */
>     const REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
>     const REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
>     const REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
>     const REAL8 quadparam2               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */)
> {
>   REAL8 m1M=params->m1M;
>   REAL8 m2M=params->m2M;
>   REAL8 eta=m1M*m2M;
>   /* Compute the non-dynamical coefficients of spin corrections
>    * to the evolution equations for L, S1 and S2
>    */
355c270,676
< static int XLALSimInspiralSpinTaylorT2Setup(
---
>   switch( params->phaseO ) {
>     case -1: /* highest available PN order */
>     case 8:
>       /* case LAL_PNORDER_THREE_POINT_FIVE: */
>     case 7:
>       params->Ecoeff[7] = 0.;
>       /* case LAL_PNORDER_THREE: */
>     case 6:
>       params->Ecoeff[6] = XLALSimInspiralPNEnergy_6PNCoeff(eta);
>       /* case LAL_PNORDER_TWO_POINT_FIVE: */
>     case 5:
>       params->Ecoeff[5] = 0.;
>       /* case LAL_PNORDER_TWO: */
>     case 4:
>       params->Ecoeff[4] = XLALSimInspiralPNEnergy_4PNCoeff(eta);
>       /*case LAL_PNORDER_ONE_POINT_FIVE:*/
>     case 3:
>       params->Ecoeff[3] = 0.;
>       /*case LAL_PNORDER_ONE:*/
>     case 2:
>       params->Ecoeff[2] = XLALSimInspiralPNEnergy_2PNCoeff(eta);
>       /*case LAL_PNORDER_HALF:*/
>     case 1:
>       params->Ecoeff[1] = 0.;
>       /*case LAL_PNORDER_NEWTONIAN:*/
>     case 0:
>       params->Ecoeff[0] = 1.;
>       break;
>     default:
>       XLALPrintError("XLAL Error - %s: Invalid phase. PN order %d\n",
> 		     __func__, params->phaseO );
>       XLAL_ERROR(XLAL_EINVAL);
>       break;
>   }
> 
>   switch( params->spinO )
>     {
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
>       // Enegy coefficients
>       params->E7S1O  = XLALSimInspiralPNEnergy_7PNSOCoeff(m1M); // Coefficient of S1.LN
>       params->E7S2O  = XLALSimInspiralPNEnergy_7PNSOCoeff(m1M); // Coefficient of S2.LN
>       // Ldot coefficients
>       params->Ldot7S1     = XLALSimInspiralLDot_7PNSOCoeff(m1M); // Coefficient of S1 x LN
>       params->Ldot7S2     = XLALSimInspiralLDot_7PNSOCoeff(m2M); // Coefficient of S2 x LN
>       // Sdot coefficients
>       params->S1dot7S2    = XLALSimInspiralSpinDot_7PNCoeff(m1M); // Coefficient of S2 x S1
>       params->S2dot7S1    = XLALSimInspiralSpinDot_7PNCoeff(m2M); // Coefficient of S1 x S2
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_3PN:
>       // Energy coefficients
>       params->E6S1S2      = XLALSimInspiralPNEnergy_6PNS1S2Coeff(eta);    // Coefficient of S1.S2
>       params->E6S1OS2O    = XLALSimInspiralPNEnergy_6PNS1S2OCoeff(eta);   // Coefficient of S1.LN S2.LN
>       params->E6S1S1      = XLALSimInspiralPNEnergy_6PNSelf2SCoeff(m1M);  // Coefficient of S1.S1
>       params->E6S2S2      = XLALSimInspiralPNEnergy_6PNSelf2SCoeff(m2M);  // Coefficient of S2.S2
>       params->E6S1OS1O    = XLALSimInspiralPNEnergy_6PNSelf2SOCoeff(m1M); // Coefficient of (S1.LN)^2
>       params->E6S2OS2O    = XLALSimInspiralPNEnergy_6PNSelf2SOCoeff(m2M); // Coefficient of (S2.LN)^2
>       params->E6QMS1S1    = quadparam1 * XLALSimInspiralPNEnergy_6PNQM2SCoeff(m1M);  // Coefficient of quadrupole-monopole S1.S1
>       params->E6QMS2S2    = quadparam2 * XLALSimInspiralPNEnergy_6PNQM2SCoeff(m2M);  // Coefficient of quadrupole-monopole S2.S2
>       params->E6QMS1OS1O  = quadparam1 * XLALSimInspiralPNEnergy_6PNQM2SOCoeff(m1M); // Coefficient of quadrupole-monopole (S1.LN)^2
>       params->E6QMS2OS2O  = quadparam2 * XLALSimInspiralPNEnergy_6PNQM2SOCoeff(m2M); // Coefficient of quadrupole-monopole (S2.LN)^2
>       // Ldot coefficients
>       params->Ldot6S2OS1    = XLALSimInspiralLDot_6PNS1S2Coeff(m1M); // Coefficient of (S2.LN) S1 x L
>       params->Ldot6S1OS2    = XLALSimInspiralLDot_6PNS1S2Coeff(m2M); // Coefficient of (S1.LN) S2 x L
>       params->Ldot6S1OS1    = XLALSimInspiralLDot_6PNS1S1Coeff(m1M); // Coefficient of (S1.LN) S1 x L
>       params->Ldot6S2OS2    = XLALSimInspiralLDot_6PNS1S1Coeff(m2M); // Coefficient of (S2.LN) S2 x L
>       params->Ldot6QMS1O    = quadparam1 * XLALSimInspiralLDot_6PNQMSSCoeff(m1M); // Coefficient of quad-monop (S1.LN) S1 x L
>       params->Ldot6QMS2O    = quadparam2 * XLALSimInspiralLDot_6PNQMSSCoeff(m2M); // Coefficient of quad-monop (S2.LN) S2 x L
>       // Sdot coefficients
>       params->S1dot6S1O     = XLALSimInspiralSpinDot_6PNS1OCoeff(m1M); // Coefficient of (S1.LN) LN x S1
>       params->S1dot6S2O     = XLALSimInspiralSpinDot_6PNS2OCoeff(m1M); // Coefficient of (S2.LN) LN x S1
>       params->S1dot6S2      = XLALSimInspiralSpinDot_6PNS1S2Coeff(m1M);// Coefficient of S2 x S1
>       params->S1dot6QMS1O   = quadparam1 * XLALSimInspiralSpinDot_6PNQMSOCoeff(m1M); // Coefficient of quad-monop (S1.LN) LN x S1
>       params->S2dot6S1O     = XLALSimInspiralSpinDot_6PNS1OCoeff(m2M); // Coefficient of (S1.LN) LN x S2
>       params->S2dot6S2O     = XLALSimInspiralSpinDot_6PNS2OCoeff(m2M); // Coefficient of (S2.LN) LN x S2
>       params->S2dot6S1      = XLALSimInspiralSpinDot_6PNS1S2Coeff(m2M);// Coefficient of S1 x S2
>       params->S2dot6QMS2O   = quadparam2 * XLALSimInspiralSpinDot_6PNQMSOCoeff(m2M); // Coefficient of quad-monop (S2.LN) LN x S2
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_25PN:
>       // Energy coefficients
>       params->E5S1O    = XLALSimInspiralPNEnergy_5PNSOCoeff(m1M); // Coefficient of S1.LN
>       params->E5S2O    = XLALSimInspiralPNEnergy_5PNSOCoeff(m2M); // Coefficient of S2.LN
>       // Ldot coefficients
>       params->Ldot5S1O      = XLALSimInspiralLDot_5PNSOCoeff(m1M); // Coefficient of S1xL
>       params->Ldot5S2O      = XLALSimInspiralLDot_5PNSOCoeff(m2M); // Coefficient of S2xL
>       // Sdot coefficients
>       params->S1dot5S2      = XLALSimInspiralSpinDot_5PNCoeff(m1M); // Coefficient of LNxS1
>       params->S2dot5S1      = XLALSimInspiralSpinDot_5PNCoeff(m2M); // Coefficient of LNxS2
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
>       // 2PN spin-spin terms
>       params->E4S1S2       = XLALSimInspiralPNEnergy_4PNS1S2Coeff(eta);  // Coefficient of S1.S2
>       params->E4S1OS2O     = XLALSimInspiralPNEnergy_4PNS1S2OCoeff(eta); // Coefficient of S1.LN S2.LN
>       // 2PN quadrupole-monopole self spin terms
>       params->E4QMS1S1     = quadparam1 * XLALSimInspiralPNEnergy_4PNQM2SCoeff(m1M);  // Coefficient of quad-monop term S1.S1
>       params->E4QMS1OS1O   = quadparam1 * XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m1M); // Coefficient of quad-monop term (S1.LN)^2
>       params->E4QMS2S2 	   = quadparam2 * XLALSimInspiralPNEnergy_4PNQM2SCoeff(m2M);  // Coefficient of quad-monop term S2.S2
>       params->E4QMS2OS2O   = quadparam2 * XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m2M); // Coefficient of quad-monop term (S2.LN)^2
>       params->Ldot4S1S2    = XLALSimInspiralLDot_4PNS1S2Coeff(eta);  // Coefficient of (S2.LN) S1xL and (S1.LN) S2xL
>       params->Ldot4QMS1    = quadparam1 * XLALSimInspiralLDot_4PNQMSSCoeff(m1M);// Coefficient of quad-monop. term (S1.LN) S1xL
>       params->Ldot4QMS2    = quadparam2 * XLALSimInspiralLDot_4PNQMSSCoeff(m2M);// Coefficient of quad-monop. term (S2.LN) S2xL
>       params->Sdot4S2      = XLALSimInspiralSpinDot_4PNS2Coeff; // Coefficient of S2xS1 in S1dot and S1xS2 in S2dot
>       params->Sdot4S2O     = XLALSimInspiralSpinDot_4PNS2OCoeff; // Coefficient of (LN.S1) S2xS1 in S1dot and (LN.S2) S1xS2 in S2dot
>       params->S1dot4QMS1O  = quadparam1 * XLALSimInspiralSpinDot_4PNQMSOCoeff(m1M); // Coefficient of quad-monop. term (S1.LN) LNxS1
>       params->S2dot4QMS2O  = quadparam2 * XLALSimInspiralSpinDot_4PNQMSOCoeff(m2M); // Coefficient of quad-monop. term (S2.LN) LNxS2
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_15PN:
>       params->E3S1O        = XLALSimInspiralPNEnergy_3PNSOCoeff(m1M); // Coefficient of S1.LN
>       params->E3S2O        = XLALSimInspiralPNEnergy_3PNSOCoeff(m2M); // Coefficient of S2.LN
>       params->Ldot3S1O     = XLALSimInspiralLDot_3PNSOCoeff(m1M); // Coefficient of S1xL
>       params->Ldot3S2O     = XLALSimInspiralLDot_3PNSOCoeff(m2M); // Coefficient of S2xL
>       params->S1dot3       = XLALSimInspiralSpinDot_3PNCoeff(m1M);  // Coefficient of LNxS1
>       params->S2dot3       = XLALSimInspiralSpinDot_3PNCoeff(m2M);  // Coefficient of LNxS2
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_1PN:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_05PN:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_0PN:
>       break;
>     default:
>       XLALPrintError("XLAL Error - %s: Invalid spin PN order %d\n",
> 		     __func__, params->spinO );
>       XLAL_ERROR(XLAL_EINVAL);
>       break;
>     }
> 
>     switch( params->tideO )
>     {
>         case LAL_SIM_INSPIRAL_TIDAL_ORDER_ALL:
>         case LAL_SIM_INSPIRAL_TIDAL_ORDER_6PN:
>             params->Etidal12 = lambda1 * XLALSimInspiralPNEnergy_12PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNEnergy_12PNTidalCoeff(m2M);
>         case LAL_SIM_INSPIRAL_TIDAL_ORDER_5PN:
> 	    params->Etidal10 = lambda1 * XLALSimInspiralPNEnergy_10PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNEnergy_10PNTidalCoeff(m2M);
>         case LAL_SIM_INSPIRAL_TIDAL_ORDER_0PN:
>             break;
>         default:
>             XLALPrintError("XLAL Error - %s: Invalid tidal PN order %d\n",
>                     __func__, params->tideO );
>             XLAL_ERROR(XLAL_EINVAL);
>             break;
>     }
> 
>   return XLAL_SUCCESS;
> }
> 
> /**
>  * Function called by all functions computing derivatives, as
>  * angular momentum/spin derivative are common for SpinTaylors.
>  */
> INT4 XLALSimInspiralSpinDerivatives(REAL8 *dLNhx,
> 				    REAL8 *dLNhy,
> 				    REAL8 *dLNhz,
> 				    REAL8 *dE1x,
> 				    REAL8 *dE1y,
> 				    REAL8 *dE1z,
> 				    REAL8 *dS1x,
> 				    REAL8 *dS1y,
> 				    REAL8 *dS1z,
> 				    REAL8 *dS2x,
> 				    REAL8 *dS2y,
> 				    REAL8 *dS2z,
> 				    REAL8 *dphiExtra,
> 				    const REAL8 v,
> 				    const REAL8 LNhx,
> 				    const REAL8 LNhy,
> 				    const REAL8 LNhz,
> 				    const REAL8 E1x,
> 				    const REAL8 E1y,
> 				    const REAL8 E1z,
> 				    const REAL8 S1x,
> 				    const REAL8 S1y,
> 				    const REAL8 S1z,
> 				    const REAL8 S2x,
> 				    const REAL8 S2y,
> 				    const REAL8 S2z,
> 				    const REAL8 LNhdotS1,
> 				    const REAL8 LNhdotS2,
> 				    XLALSimInspiralSpinTaylorTxCoeffs *params)
> {
> 
>   REAL8 v2=v*v;
>   REAL8 omega=v2*v;
>   REAL8 v4=omega*v;
>   REAL8 v5=omega*v2;
>   REAL8 omega2=omega*omega;
>   REAL8 v7=omega2*v;
>   REAL8 v8=omega2*v2;
>   REAL8 omega3=omega2*omega;
>   REAL8 v10=omega3*v;
> 
>   /* Phasing is given in terms of LNhat, however we know the
>    * evolution equation for L, which is not parallel to LN, because
>    * of S terms at 1.5PN order wrt to leading order.
>    * Thus we have  $dL/dt = \Omega \times L = d L_LN/dt + dL_S/dt
>    * where we have separated L = L_LN + L_S in its contributions
>    * (in)dependent on spins. Note the L_S has in general components along
>    * L_LN and orthogonal to it.
>    * Since L_S depends on LN as well as on the spins, we have to compute
>    * dS AND dL_LN in order to have dL_S which we will eventually subtract from
>    * dL to obtain dLN, from which we will derive dLNhat.
>    */
> 
>    /*
>    * dLN at leading order
>    * \f$d LN/d \hat{t} = M * dLN / dt = \Omega_LN x LN\f$
>    * This is Eq. (10) of gr-qc/0405090 ( times M b/c we use \f$\hat{t}\f$)
>    * and A.2 of 1501.01529.
>    * Up to the 1PN level L is parallel to LN.
>    */
> 
>   /* Compute \Omega_L vector, here is the leading term divided by omega2*/
>   REAL8 OmegaLNx = params->Ldot3S1O * S1x + params->Ldot3S2O * S2x;
>   REAL8 OmegaLNy = params->Ldot3S1O * S1y + params->Ldot3S2O * S2y;
>   REAL8 OmegaLNz = params->Ldot3S1O * S1z + params->Ldot3S2O * S2z;
> 
>   /* Here we use the above \Omega_LN/omega2 at leading order to compute the
>    * extra terms in dphi given by eq. (7) of arXiv:1507.00406.
>    * Actually what is coded here is the time average of this equation,
>    * which involves subtracting the projection of \Omega_LN over LN.
>    */
>   REAL8 tmp=OmegaLNx*LNhx+OmegaLNy*LNhy+OmegaLNz*LNhz;
>   // This is a 3.5PN term in the phasing
>   *dphiExtra=-(OmegaLNx*OmegaLNx+OmegaLNy*OmegaLNy+OmegaLNz*OmegaLNz-tmp*tmp)*omega2/4.;
> 
>   /* Now we multiply by the appropriate v factor*/
>   OmegaLNx*=omega2;
>   OmegaLNy*=omega2;
>   OmegaLNz*=omega2;
> 
>   /* and add higher order terms*/
>   OmegaLNx+=v7 * ( params->Ldot4S1S2 * (LNhdotS2 * S1x + LNhdotS1 * S2x) + params->Ldot4QMS1*LNhdotS1*S1x + params->Ldot4QMS2*LNhdotS2*S2x );
>   OmegaLNy+=v7 * ( params->Ldot4S1S2 * (LNhdotS2 * S1y + LNhdotS1 * S2y) + params->Ldot4QMS1*LNhdotS1*S1y + params->Ldot4QMS2*LNhdotS2*S2y );
>   OmegaLNz+=v7 * ( params->Ldot4S1S2 * (LNhdotS2 * S1z + LNhdotS1 * S2z) + params->Ldot4QMS1*LNhdotS1*S1z + params->Ldot4QMS2*LNhdotS2*S2z );
> 
>   /* This is dLNhat only up to NLO.
>    * Up to this order LNhat = Lhat.
>    */
>   REAL8 *dLNhat=NULL;
>   XLALSimInspiralVectorCrossProduct(&dLNhat,OmegaLNx,OmegaLNy,OmegaLNz,LNhx,LNhy,LNhz);
> 
>   /*
>    * Since the Spins are 1.5PN contribution
>    * to L, it is enough to have dS at v5 and v6 order (i.e. up to NLO)
>    * to estimate their contribution to dL.
>    */
> 
>   /*
>    * dS1
>    * d S_1 / d \hat{t} = M * d S_1 / dt = \Omega_{S1,S2,LN,v} x S_1
>    * However, that paper uses spin variables which are M^2 times our spins
>    */
> 
>   /* dS1 leading terms: eq. (8) of gr-qc/0405090.
>    */
>   REAL8 *LNcS1=NULL;
>   XLALSimInspiralVectorCrossProduct(&LNcS1,LNhx,LNhy,LNhz,S1x,S1y,S1z);
> 
>   *dS1x = params->S1dot3 * v5 * LNcS1[0];
>   *dS1y = params->S1dot3 * v5 * LNcS1[1];
>   *dS1z = params->S1dot3 * v5 * LNcS1[2];
> 
>   /* dS1 next-to-leading term */
>   REAL8 *S1cS2=NULL;
>   XLALSimInspiralVectorCrossProduct(&S1cS2,S1x,S1y,S1z,S2x,S2y,S2z);
> 
>   /* S1S2 contribution
>    * see. eq. 2.23 of arXiv:0812.4413
>    */
>   *dS1x += omega2 * (-params->Sdot4S2*S1cS2[0] + params->Sdot4S2O * LNhdotS2 * LNcS1[0]);
>   *dS1y += omega2 * (-params->Sdot4S2*S1cS2[1] + params->Sdot4S2O * LNhdotS2 * LNcS1[1]);
>   *dS1z += omega2 * (-params->Sdot4S2*S1cS2[2] + params->Sdot4S2O * LNhdotS2 * LNcS1[2]);
>   /* S1S1 contribution
>    */
>   *dS1x += omega2 * params->S1dot4QMS1O * LNhdotS1 * LNcS1[0];
>   *dS1y += omega2 * params->S1dot4QMS1O * LNhdotS1 * LNcS1[1];
>   *dS1z += omega2 * params->S1dot4QMS1O * LNhdotS1 * LNcS1[2];;
> 
>   /* dS2, 1.5PN */
>   REAL8 *LNcS2=NULL;
>   XLALSimInspiralVectorCrossProduct(&LNcS2,LNhx,LNhy,LNhz,S2x,S2y,S2z);
> 
>   *dS2x = params->S2dot3 * v5 * LNcS2[0];
>   *dS2y = params->S2dot3 * v5 * LNcS2[1];
>   *dS2z = params->S2dot3 * v5 * LNcS2[2];
> 
>   /* dS2, 2PN */
>   *dS2x += omega2 * (params->Sdot4S2*S1cS2[0] + params->Sdot4S2O * LNhdotS1 * LNcS2[0]);
>   *dS2y += omega2 * (params->Sdot4S2*S1cS2[1] + params->Sdot4S2O * LNhdotS1 * LNcS2[1]);
>   *dS2z += omega2 * (params->Sdot4S2*S1cS2[2] + params->Sdot4S2O * LNhdotS1 * LNcS2[2]);
>   // S2S2 contribution
>   *dS2x += omega2 * params->S2dot4QMS2O * LNhdotS2 * LNcS2[0];
>   *dS2y += omega2 * params->S2dot4QMS2O * LNhdotS2 * LNcS2[1];
>   *dS2z += omega2 * params->S2dot4QMS2O * LNhdotS2 * LNcS2[2];
> 
>   /* We have now all the ingredients to compute dL at omega^2 order with
>    * respect to LO.
>    * cSi are the coefficients multiplying the S.LNhat contribution to L,
>    * see eqs. (2.9) of arXiv:gr-qc/9506022.
>    * Again orbital average here is taken.
>    */
>   REAL8 cS1=-0.5*XLALSimInspiralL_3PNScoeff(params->m1M);
>   REAL8 cS2=-0.5*XLALSimInspiralL_3PNScoeff(params->m2M);
>   REAL8 dLNhdotS1=(*dS1x)*LNhx+(*dS1y)*LNhy+(*dS1z)*LNhz + S1x*dLNhat[0]+S1y*dLNhat[1]+S1z*dLNhat[2];
>   REAL8 dLNhdotS2=(*dS2x)*LNhx+(*dS2y)*LNhy+(*dS2z)*LNhz + S2x*dLNhat[0]+S2y*dLNhat[1]+S2z*dLNhat[2];
>   REAL8 dL_Sx=omega*( cS1*((*dS1x) + dLNhdotS1*LNhx + LNhdotS1*dLNhat[0])
> 		      + cS2*((*dS2x) + dLNhdotS2*LNhx + LNhdotS2*dLNhat[0]) );
>   REAL8 dL_Sy=omega*( cS1*((*dS1y) + dLNhdotS1*LNhy + LNhdotS1*dLNhat[1])
> 		      + cS2*((*dS2y) + dLNhdotS2*LNhy + LNhdotS2*dLNhat[1]) );
>   REAL8 dL_Sz=omega*( cS1*((*dS1z) + dLNhdotS1*LNhz + LNhdotS1*dLNhat[2])
> 		      + cS2*((*dS2z) + dLNhdotS2*LNhz + LNhdotS2*dLNhat[2]) );
> 
>   /*
>    * Now we compute L in order to compute its derivative \Omega_L x L.
>    * We start by computing its spin-dependent part, then we add the part
>    * proportional to LN.
>    */
> 
>   REAL8 L_Sx=omega*(cS1*(S1x+LNhdotS1*LNhx) + cS2*(S2x+LNhdotS2*LNhx));
>   REAL8 L_Sy=omega*(cS1*(S1y+LNhdotS1*LNhy) + cS2*(S2y+LNhdotS2*LNhy));
>   REAL8 L_Sz=omega*(cS1*(S1z+LNhdotS1*LNhz) + cS2*(S2z+LNhdotS2*LNhz));
> 
>   REAL8 Lx=(1.+v2*XLALSimInspiralL_2PN(params->eta)+v4*XLALSimInspiralL_4PN(params->eta))*LNhx+L_Sx;
>   REAL8 Ly=(1.+v2*XLALSimInspiralL_2PN(params->eta)+v4*XLALSimInspiralL_4PN(params->eta))*LNhy+L_Sy;
>   REAL8 Lz=(1.+v2*XLALSimInspiralL_2PN(params->eta)+v4*XLALSimInspiralL_4PN(params->eta))*LNhz+L_Sz;
> 
>   /*
>    * Now we can add v8, v9 and v10 effects in \Omega_L
>    */
>   REAL8 OmegaLx = OmegaLNx +
>     v8 * ( params->Ldot5S1O * S1x + params->Ldot5S2O * S2x ) +
>     omega3 * ( (params->Ldot6S1OS2*LNhdotS1+(params->Ldot6QMS2O+params->Ldot6S2OS2)*LNhdotS2)*S2x + (params->Ldot6S2OS1*LNhdotS2+(params->Ldot6S1OS1+params->Ldot6QMS1O)*LNhdotS1)*S1x) +
>     v10 * ( params->Ldot7S1 * S1x + params->Ldot7S2 * S2x);
>   REAL8 OmegaLy = OmegaLNy +
>     v8 * ( params->Ldot5S1O * S1y + params->Ldot5S2O * S2y ) +
>     omega3 * ( (params->Ldot6S1OS2*LNhdotS1+(params->Ldot6QMS2O+params->Ldot6S2OS2)*LNhdotS2)*S2x + (params->Ldot6S2OS1*LNhdotS2+(params->Ldot6S1OS1+params->Ldot6QMS1O)*LNhdotS1)*S1y) +
>     v10 * ( params->Ldot7S1 * S1y + params->Ldot7S2 * S2y);
>   REAL8 OmegaLz = OmegaLNz +
>     v8 * ( params->Ldot5S1O * S1z + params->Ldot5S2O * S2z ) +
>     omega3 * ( (params->Ldot6S1OS2*LNhdotS1+(params->Ldot6QMS2O+params->Ldot6S2OS2)*LNhdotS2)*S2z + (params->Ldot6S2OS1*LNhdotS2+(params->Ldot6S1OS1+params->Ldot6QMS1O)*LNhdotS1)*S1z) +
>     v10 * ( params->Ldot7S1 * S1z + params->Ldot7S2 * S2z);
> 
>   /*dL is the derivative of the total angular momentum*/
>   REAL8 *dL=NULL;
>   XLALSimInspiralVectorCrossProduct(&dL,OmegaLx,OmegaLy,OmegaLz,Lx,Ly,Lz);
>   REAL8 L_LNmag=sqrt(Lx*Lx+Ly*Ly+Lz*Lz-(L_Sx*L_Sx+L_Sy*L_Sy+L_Sz*L_Sz));
> 
>   /* We now obtain the derivative of the spin-independent part of the
>    * total angular momentum, which is parallel to the Newtonian angular
>    * momentum Newtonian.
>    */
>   *dLNhx=(dL[0]-dL_Sx-dLNhdotS1*LNhx-LNhdotS1*dLNhat[0])/L_LNmag;
>   *dLNhy=(dL[1]-dL_Sy-dLNhdotS1*LNhy-LNhdotS1*dLNhat[1])/L_LNmag;
>   *dLNhz=(dL[2]-dL_Sz-dLNhdotS1*LNhz-LNhdotS1*dLNhat[2])/L_LNmag;
> 
>   /* We now define the \Omega_LN precession vector as the cross product of
>    * dLN and LN, hence $\Omega_{LN} = LN \cross LNdot
>    *
>    */
>   REAL8 *OmegaLN=NULL;
>   XLALSimInspiralVectorCrossProduct(&OmegaLN,LNhx,LNhy,LNhz,*dLNhx,*dLNhy,*dLNhz);
> 
>   /*
>    * dE1
>    *
>    * d E_1 / d \hat{t} = M * d E_1 / dt
>    * Computed from \Omega_L and \hat{L_N} with Eq. (15)-(16) of gr-qc/0310034
>    */
> 
>   /* Take cross product of \Omega_E with E_1 */
>   *dE1x = (-OmegaLN[2]*E1y + OmegaLN[1]*E1z);
>   *dE1y = (-OmegaLN[0]*E1z + OmegaLN[2]*E1x);
>   *dE1z = (-OmegaLN[1]*E1x + OmegaLN[0]*E1y);
> 
>   /* dS1, 2.5PN
>    * eq. 7.8 of Blanchet et al. gr-qc/0605140
>    */
>   *dS1x -= params->S1dot5S2 * v7 * S1cS2[0];
>   *dS1y -= params->S1dot5S2 * v7 * S1cS2[1];
>   *dS1z -= params->S1dot5S2 * v7 * S1cS2[2];
> 
>   *dS1x += v8 * ((params->S1dot6S2O*LNhdotS2+(params->S1dot6S1O+params->S1dot6QMS1O)*LNhdotS1)*LNcS1[0] - params->S1dot6S2*S1cS2[0]);
>   *dS1x += v8 * ((params->S1dot6S2O*LNhdotS2+(params->S1dot6S1O+params->S1dot6QMS1O)*LNhdotS1)*LNcS1[1] - params->S1dot6S2*S1cS2[1]);
>   *dS1x += v8 * ((params->S1dot6S2O*LNhdotS2+(params->S1dot6S1O+params->S1dot6QMS1O)*LNhdotS1)*LNcS1[2] - params->S1dot6S2*S1cS2[2]);
> 
>   *dS1x -= params->S1dot7S2 * omega3 * S1cS2[0];
>   *dS1y -= params->S1dot7S2 * omega3 * S1cS2[1];
>   *dS1z -= params->S1dot7S2 * omega3 * S1cS2[2];
> 
>   // dS2, 2.5PN, eq. 7.8 of Blanchet et al. gr-qc/0605140
>   *dS2x += params->S2dot5S1 * v7 * S1cS2[0];
>   *dS2y += params->S2dot5S1 * v7 * S1cS2[1];
>   *dS2z += params->S2dot5S1 * v7 * S1cS2[2];
> 
>   *dS2x += v8 * ((params->S2dot6S1O*LNhdotS1+(params->S2dot6S2O+params->S2dot6QMS2O)*LNhdotS2)*LNcS2[0] + params->S2dot6S1*S1cS2[0]);
>   *dS2x += v8 * ((params->S2dot6S1O*LNhdotS1+(params->S2dot6S2O+params->S2dot6QMS2O)*LNhdotS2)*LNcS2[1] + params->S2dot6S1*S1cS2[1]);
>   *dS2x += v8 * ((params->S2dot6S1O*LNhdotS1+(params->S2dot6S2O+params->S2dot6QMS2O)*LNhdotS2)*LNcS2[2] + params->S2dot6S1*S1cS2[2]);
> 
>   *dS2x += params->S2dot7S1 * omega3 * S1cS2[0];
>   *dS2y += params->S2dot7S1 * omega3 * S1cS2[1];
>   *dS2z += params->S2dot7S1 * omega3 * S1cS2[2];
> 
>   XLALFree(dLNhat);
>   XLALFree(LNcS1);
>   XLALFree(LNcS2);
>   XLALFree(S1cS2);
>   XLALFree(dL);
>   XLALFree(OmegaLN);
> 
>   return XLAL_SUCCESS;
> 
> }
> 
> static int XLALSimSpinTaylorSetCommonCoeffs(
357,367c678,719
<     REAL8 m1,                       /**< mass of body 1 (kg) */
<     REAL8 m2,                       /**< mass of body 2 (kg) */
<     REAL8 fStart,                   /**< Starting GW freq. (Hz) */
<     REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
< 	REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
< 	REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
<     REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
<     REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
< 	LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
< 	LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
< 	INT4 phaseO                     /**< twice post-Newtonian order */
---
>     const REAL8 m1_SI,                   /**< mass of body 1 (kg) */
>     const REAL8 m2_SI,                   /**< mass of body 2 (kg) */
>     const REAL8 fStart,                  /**< Starting GW freq. (Hz) */
>     const REAL8 fEnd,                    /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
>     const LALSimInspiralSpinOrder  spinO, /**< twice PN order of spin effects */
>     const LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
>     const INT4 phaseO                     /**< twice PN order of spin effects */)
> {
>   memset(params, 0, sizeof(XLALSimInspiralSpinTaylorTxCoeffs));
> 
>   REAL8 m1=m1_SI/LAL_MSUN_SI;
>   REAL8 m2=m2_SI/LAL_MSUN_SI;
>   REAL8 M=m1+m2;
>   REAL8 eta=m1/M*m2/M;
>   params->wdotnewt = XLALSimInspiralTaylorT4wdot_0PNCoeff(eta);
>   params->M = M;
>   params->Mchirp = M*pow(eta,0.6);
>   params->m1M = m1/M;
>   params->m2M = m2/M;
>   params->eta = eta;
>   params->fStart = fStart;
>   params->fEnd = fEnd;
>   params->phaseO = phaseO;
>   params->spinO  = spinO;
>   params->tideO  = tideO;
> 
>   return XLAL_SUCCESS;
> }
> 
> INT4 XLALSimInspiralSpinTaylorT4Setup(
>     XLALSimInspiralSpinTaylorTxCoeffs *params, /**< UNDOCUMENTED */
>     const REAL8 m1_SI,                    /**< mass of body 1 (kg) */
>     const REAL8 m2_SI,                    /**< mass of body 2 (kg) */
>     const REAL8 fStart,                   /**< Starting GW freq. (Hz) */
>     const REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
>     const REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
>     const REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
>     const REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
>     const REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
>     const LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
>     const LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
>     const INT4 phaseO                     /**< twice post-Newtonian order */
370,394c722,725
<     REAL8 M, eta, Mchirp, dm, m1m2, m2m1, m1M, m2M;
<     /* Zero the coefficients */
<     memset(params, 0, sizeof(XLALSimInspiralSpinTaylorTxCoeffs));
< 
<     /* Define mass variables and other coefficients */
<     m1m2 = m1 / m2;
<     m2m1 = m2 / m1;
<     m1 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m1 from kg to seconds */
<     m2 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m2 from kg to seconds */
<     M = m1 + m2;
<     dm = (m1 - m2)/M;
<     m1M = m1 / M;
<     m2M = m2 / M;
<     eta = m1 * m2 / M / M;
<     Mchirp = M * pow(eta, 3./5.);
<     params->wdotnewt = (96.0/5.0) * eta;
<     params->M = M;
<     params->Mchirp = Mchirp;
<     params->m1M = m1M;
<     params->m2M = m2M;
<     params->eta = eta;
<     params->fStart = fStart;
<     params->fEnd = fEnd;
<     params->spinO = spinO;
<     params->tideO = tideO;
---
>     XLALSimSpinTaylorSetCommonCoeffs(params,m1_SI,m2_SI,fStart,fEnd,spinO,tideO,phaseO);
>     REAL8 eta=params->eta;
>     REAL8 m1M=params->m1M;
>     REAL8 m2M=params->m2M;
396,397c727
<     /* Set coefficients up to PN order phaseO.
<      * epnorb is the binary energy and
---
>     /* Set omegadot coefficients up to PN order phaseO.
418,420c748
<             params->wdotcoeff[7] = (LAL_PI/1016064.)
<                     * (-15419335. - 12718104.*eta + 4975824.*eta*eta);
<             params->Ecoeff[7] = 0.;
---
>             params->wdotcoeff[7] = XLALSimInspiralTaylorT4wdot_7PNCoeff(eta);
423,432c751,752
<             params->wdotcoeff[6] = 22.065 + 165.416*eta
<                     - 2.20067*eta*eta + 4.93152*eta*eta*eta;
<             /*params->wdotcoeff[6] = -10817850546611./93884313600.
<                     + 1712.*LAL_GAMMA/105. + 32.*LAL_PI*LAL_PI/3.
<                     + (3147553127./12192768. - 451.*LAL_PI*LAL_PI/48.)*eta
<                     - 15211.*eta*eta/6912. + 25565.*eta*eta*eta/5184.;*/
<             params->wdotlogcoeff = 1712./315.;
<             params->Ecoeff[6] = - 675./64. + ( 34445./576.
<                     - 205./96. * LAL_PI * LAL_PI ) * eta
<                     - (155./96.) *eta * eta - 35./5184. * eta * eta * eta;
---
>             params->wdotcoeff[6] = XLALSimInspiralTaylorT4wdot_6PNCoeff(eta);
>             params->wdotlogcoeff = XLALSimInspiralTaylorT4wdot_6PNLogCoeff(eta);
435,436c755
<             params->wdotcoeff[5] = (1./672.) * LAL_PI * (-7729. + 1092.*eta);
<             params->Ecoeff[5] = 0.;
---
>             params->wdotcoeff[5] = XLALSimInspiralTaylorT4wdot_5PNCoeff(eta);
439,441c758
<             params->wdotcoeff[4] = (3058673. + 5472432.*eta
<                     + 4353552.*eta*eta)/1016064.;
<             params->Ecoeff[4] = (-81. + 57.*eta - eta*eta)/24.;
---
>             params->wdotcoeff[4] = XLALSimInspiralTaylorT4wdot_4PNCoeff(eta);
444,445c761
<             params->wdotcoeff[3] = -4. * LAL_PI;
<             params->Ecoeff[3] = 0.;
---
>             params->wdotcoeff[3] = XLALSimInspiralTaylorT4wdot_3PNCoeff(eta);
448,449c764
<             params->wdotcoeff[2] = (1./336.) * (743. + 924.*eta);
<             params->Ecoeff[2] = -(1.0/12.0) * (9.0 + eta);
---
>             params->wdotcoeff[2] = XLALSimInspiralTaylorT4wdot_2PNCoeff(eta);
453d767
<             params->Ecoeff[1] = 0.;
457d770
<             params->Ecoeff[0] = 1.;
470,471c783,784
<     {   // case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
< 
---
>     {
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
473,482c786,787
<             params->wdotSO35s1 = 1796084999./3048192. - 1317319.*eta/3024.
<                     + 61.*eta*eta/144. + (dm/m1M) * (-34195607./193536.
<                     + 575285.*eta/2688. + 947.*eta*eta/576.);
<             params->wdotSO35s2 = 1796084999./3048192. - 1317319.*eta/3024.
<                     + 61.*eta*eta/144. - (dm/m2M) * (-34195607./193536.
<                     + 575285.*eta/2688. + 947.*eta*eta/576.);
<             params->ESO35s1 = 135./4. - 367.*eta/4. + 29.*eta*eta/12.
<                     + (dm/m1M) * (-27./4. + 39.*eta - 5.*eta*eta/4.);
<             params->ESO35s2 = 135./4. - 367.*eta/4. + 29.*eta*eta/12.
<                     - (dm/m2M) * (-27./4. + 39.*eta - 5.*eta*eta/4.);
---
> 	    params->wdot7S1O = XLALSimInspiralTaylorT4wdot_7PNSOCoeff(m1M);
>             params->wdot7S2O = XLALSimInspiralTaylorT4wdot_7PNSOCoeff(m2M);
484,486c789,798
<             params->wdotSO3s1 = LAL_PI*(-188./3. + (dm/m1M)*149./6.);
<             params->wdotSO3s2 = LAL_PI*(-188./3. - (dm/m2M)*149./6.);
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
---
>             params->wdot6S1O      = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(m1M);
>             params->wdot6S2O      = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(m2M);
>             params->wdot6S1S1     = XLALSimInspiralTaylorT4wdot_6PNSelf2SCoeff(m1M);
>             params->wdot6S1OS1O   = XLALSimInspiralTaylorT4wdot_6PNSelf2SOCoeff(m1M);
>             params->wdot6S2S2     = XLALSimInspiralTaylorT4wdot_6PNSelf2SCoeff(m2M);
>             params->wdot6S2OS2O   = XLALSimInspiralTaylorT4wdot_6PNSelf2SOCoeff(m2M);
>             params->wdot6QMS1S1   = quadparam1 * XLALSimInspiralTaylorT4wdot_6PNQM2SCoeff(m1M);
>             params->wdot6QMS1OS1O = quadparam1 * XLALSimInspiralTaylorT4wdot_6PNQM2SOCoeff(m1M);
>             params->wdot6QMS2S2   = quadparam2 * XLALSimInspiralTaylorT4wdot_6PNQM2SCoeff(m2M);
>             params->wdot6QMS2OS2O = quadparam2 * XLALSimInspiralTaylorT4wdot_6PNQM2SOCoeff(m2M);
488,491c800,801
<             params->wdotSO25s1 = 110869./1008. + 11.*eta/4. + (dm/m1M) * (-8349./224. + 3.*eta/4.);
<             params->wdotSO25s2 = 110869./1008. + 11.*eta/4. + (dm/m2M) * (8349./224. - 3.*eta/4.);
<             params->ESO25s1 = 11. - 61.*eta/9. + (dm/m1M) * (-3. + 10.*eta/3.);
<             params->ESO25s2 = 11. - 61.*eta/9. + (dm/m2M) * (3. - 10.*eta/3.);
---
>             params->wdot5S1O = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(m1M);
>             params->wdot5S2O = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(m2M);
494,505c804,805
<             params->LNhatSS2 	= -1.5 / eta;
<             params->wdotSS2 	= 1. / 48. / eta;
<             params->ESS2 		= 1. / eta;
<             // 2PN quadrupole-monopole terms
<             params->wdotQM2S1        = quadparam1 * 5./2./m1M/m1M;
<             params->wdotQM2S1L       = -quadparam1 * 15./2./m1M/m1M;
<             params->wdotQM2S2        = quadparam2 * 5./2./m2M/m2M;
<             params->wdotQM2S2L       = -quadparam2 * 15./2./m2M/m2M;
<             params->EQM2S1           = quadparam1/2./m1M/m1M;
<             params->EQM2S1L          = -quadparam1*3./2./m1M/m1M;
<             params->EQM2S2           = quadparam2/2./m2M/m2M;
<             params->EQM2S2L          = -quadparam2*3./2./m2M/m2M;
---
>             params->wdot4S1S2     = XLALSimInspiralTaylorT4wdot_4PNS1S2Coeff(eta);
>             params->wdot4S1OS2O   = XLALSimInspiralTaylorT4wdot_4PNS1S2OCoeff(eta);
507,510c807,815
<             params->wdotSSselfS1     = -7./96./m1M/m1M;
<             params->wdotSSselfS1L    = 1./96./m1M/m1M;
<             params->wdotSSselfS2     = -7./96./m2M/m2M;
<             params->wdotSSselfS2L    = 1./96./m2M/m2M;
---
>             params->wdot4S1S1     = XLALSimInspiralTaylorT4wdot_4PNSelf2SCoeff(m1M);
>             params->wdot4S1OS1O   = XLALSimInspiralTaylorT4wdot_4PNSelf2SOCoeff(m1M);
>             params->wdot4S2S2     = XLALSimInspiralTaylorT4wdot_4PNSelf2SCoeff(m2M);
>             params->wdot4S2OS2O   = XLALSimInspiralTaylorT4wdot_4PNSelf2SOCoeff(m2M);
>             // 2PN quadrupole-monopole terms
>             params->wdot4QMS1S1   = quadparam1 * XLALSimInspiralTaylorT4wdot_4PNQM2SCoeff(m1M);
>             params->wdot4QMS1OS1O = quadparam1 * XLALSimInspiralTaylorT4wdot_4PNQM2SOCoeff(m1M);
>             params->wdot4QMS2S2   = quadparam2 * XLALSimInspiralTaylorT4wdot_4PNQM2SCoeff(m2M);
>             params->wdot4QMS2OS2O = quadparam2 * XLALSimInspiralTaylorT4wdot_4PNQM2SOCoeff(m2M);
512,519c817,818
<             // Note: LNHat do not have their signs reversed relative to T4
<             // They are precession rather than orbital quantities
<             params->LNhatSO15s1 	= 2. + 3./2. * m2m1;
<             params->LNhatSO15s2	= 2. + 3./2. * m1m2;
<             params->wdotSO15s1 	= ( 113. + 75. * m2m1 ) / 12.;
<             params->wdotSO15s2 	= ( 113. + 75. * m1m2 ) / 12.;
<             params->ESO15s1 		= 8./3. + 2. * m2m1;
<             params->ESO15s2 		= 8./3. + 2. * m1m2;
---
> 	    params->wdot3S1O 	= XLALSimInspiralTaylorT4wdot_3PNSOCoeff(m1M);
>             params->wdot3S2O 	= XLALSimInspiralTaylorT4wdot_3PNSOCoeff(m2M);
531,532c830
<     /*
<      * Compute the coefficients of tidal corrections
---
>     /* Compute the coefficients of tidal corrections
535c833,834
<      * Vines, Flanagan, Hinderer, PRD 83, 084051 (2011).
---
>      * Vines, Flanagan, Hinderer, PRD 83, 084051 (2011)
>      * and eq. 2 and 3 of PhysRevD.89.103012.
541,547c840
<             params->wdottidal6pn = lambda1 * (4421./28. - 12263./28. * m1M
<                     + 1893./2. * m1M * m1M - 661 * m1M * m1M * m1M) / (2 * m1M)
<                     + lambda2 * (4421./28. - 12263./28. * m2M + 1893./2. * m2M * m2M
<                     - 661 * m2M * m2M * m2M) / (2 * m2M);
<             params->Etidal6pn = - 11./2. * m2m1
<                     * (3. + 2. * m1M + 3. * m1M * m1M) * lambda1
<                     - 11./2. * m1m2 * (3. + 2. * m2M + 3. * m2M * m2M) * lambda2;
---
>             params->wdottidal12 = lambda1 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(m2M);
549,551c842
<             params->wdottidal5pn = lambda1 * 6. * (1. + 11. * m2M) / m1M
<                     + lambda2 * 6. * (1. + 11. * m1M) / m2M;
<             params->Etidal5pn = - 9. * m2m1 * lambda1 - 9. * m1m2 * lambda2;
---
> 	    params->wdottidal10 = lambda1 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(m2M);
560a852,853
>     XLALSimSpinTaylorEnergySpinDerivativeSetup(params,lambda1,lambda2,quadparam1,quadparam2);
> 
564c857
< static int XLALSimInspiralSpinTaylorT4Setup(
---
> static int XLALSimInspiralSpinTaylorT1Setup(
566,576c859,869
<     REAL8 m1,                       /**< mass of body 1 (kg) */
<     REAL8 m2,                       /**< mass of body 2 (kg) */
<     REAL8 fStart,                   /**< Starting GW freq. (Hz) */
<     REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
< 	REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
< 	REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
<     REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
<     REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
< 	LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
< 	LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
< 	INT4 phaseO                     /**< twice post-Newtonian order */
---
>     const REAL8 m1_SI,                       /**< mass of body 1 (kg) */
>     const REAL8 m2_SI,                       /**< mass of body 2 (kg) */
>     const REAL8 fStart,                   /**< Starting GW freq. (Hz) */
>     const REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
>     const REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
>     const REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
>     const REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
>     const REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
>     const LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
>     const LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
>     const INT4 phaseO                     /**< twice post-Newtonian order */
579,602d871
<     REAL8 M, eta, Mchirp, m1m2, m2m1, m1M, m2M;
<     /* Zero the coefficients */
<     memset(params, 0, sizeof(XLALSimInspiralSpinTaylorTxCoeffs));
< 
<     /* Define mass variables and other coefficients */
<     m1m2 = m1 / m2;
<     m2m1 = m2 / m1;
<     m1 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m1 from kg to seconds */
<     m2 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m2 from kg to seconds */
<     M = m1 + m2;
<     m1M = m1 / M;
<     m2M = m2 / M;
<     eta = m1 * m2 / M / M;
<     Mchirp = M * pow(eta, 3./5.);
<     params->wdotnewt = (96.0/5.0) * eta;
<     params->M = M;
<     params->Mchirp = Mchirp;
<     params->m1M = m1M;
<     params->m2M = m2M;
<     params->eta = eta;
<     params->fStart = fStart;
<     params->fEnd = fEnd;
<     params->spinO = spinO;
<     params->tideO = tideO;
604,606c873,880
<     /* Set coefficients up to PN order phaseO.
<      * epnorb is the binary energy and
<      * wdotorb is the derivative of the orbital frequency \f$\dot{\omega}\f$.
---
>     XLALSimSpinTaylorSetCommonCoeffs(params,m1_SI,m2_SI,fStart,fEnd,spinO,tideO,phaseO);
>     REAL8 eta=params->eta;
>     REAL8 m1M=params->m1M;
>     REAL8 m2M=params->m2M;
>     params->Fnewt=XLALSimInspiralPNFlux_0PNCoeff(eta);
>     params->dEdvnewt=2.*XLALSimInspiralPNEnergy_0PNCoeff(eta);
> 
>     /* Set the flux coefficients up to PN order phaseO.
617c891
<      * so the PN corrections are the same 
---
>      * so the PN corrections are the same
619a894
> 
626,627c901
<             params->wdotcoeff[7] = XLALSimInspiralTaylorT4wdot_7PNCoeff(eta);
<             params->Ecoeff[7] = 0.;
---
>             params->Fcoeff[7] = XLALSimInspiralPNFlux_7PNCoeff(eta);
630,632c904,905
<             params->wdotcoeff[6] = XLALSimInspiralTaylorT4wdot_6PNCoeff(eta);
<             params->wdotlogcoeff = XLALSimInspiralTaylorT4wdot_6PNLogCoeff(eta);
<             params->Ecoeff[6] = XLALSimInspiralPNEnergy_6PNCoeff(eta);
---
>             params->Fcoeff[6] = XLALSimInspiralPNFlux_6PNCoeff(eta);
> 	    params->Flogcoeff = XLALSimInspiralPNFlux_6PNLogCoeff(eta);
635,636c908
<             params->wdotcoeff[5] = XLALSimInspiralTaylorT4wdot_5PNCoeff(eta);
<             params->Ecoeff[5] = 0.;
---
> 	    params->Fcoeff[5] = XLALSimInspiralPNFlux_5PNCoeff(eta);
639,640c911
<             params->wdotcoeff[4] = XLALSimInspiralTaylorT4wdot_4PNCoeff(eta);
<             params->Ecoeff[4] = XLALSimInspiralPNEnergy_4PNCoeff(eta);
---
>             params->Fcoeff[4] = XLALSimInspiralPNFlux_4PNCoeff(eta);
643,644c914
<             params->wdotcoeff[3] = XLALSimInspiralTaylorT4wdot_3PNCoeff(eta);
<             params->Ecoeff[3] = 0.;
---
>             params->Fcoeff[3] = XLALSimInspiralPNFlux_3PNCoeff(eta);
647,648c917
<             params->wdotcoeff[2] = XLALSimInspiralTaylorT4wdot_2PNCoeff(eta);
<             params->Ecoeff[2] = XLALSimInspiralPNEnergy_2PNCoeff(eta);
---
> 	    params->Fcoeff[2] = XLALSimInspiralPNFlux_2PNCoeff(eta);
651,652c920
<             params->wdotcoeff[1] = 0.;
<             params->Ecoeff[1] = 0.;
---
> 	    params->Fcoeff[1] = 0.;
655,656c923
<             params->wdotcoeff[0] = 1.;
<             params->Ecoeff[0] = 1.;
---
> 	    params->Fcoeff[0] = 1.;
658c925
<         default: 
---
>         default:
665,667d931
<     /* Compute the non-dynamical coefficients of spin corrections
<      * to the evolution equations for omega, L, S1 and S2 and binary energy E.
<      */
671,675c935,937
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
< 	    params->wdotSO35s1 = XLALSimInspiralTaylorT4wdot_7PNSOCoeff(m1M);
<             params->wdotSO35s2 = XLALSimInspiralTaylorT4wdot_7PNSOCoeff(m2M);
<             params->ESO35s1 = XLALSimInspiralPNEnergy_7PNSOCoeff(m1M);
<             params->ESO35s2 = XLALSimInspiralPNEnergy_7PNSOCoeff(m2M);
---
> 	case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
> 	    params->F7S1O=XLALSimInspiralPNFlux_7PNSOCoeff(m1M);
> 	    params->F7S2O=XLALSimInspiralPNFlux_7PNSOCoeff(m2M);
677,678c939,950
<             params->wdotSO3s1 = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(m1M);
<             params->wdotSO3s2 = XLALSimInspiralTaylorT4wdot_6PNSOCoeff(m2M);
---
> 	    params->F6S1O = XLALSimInspiralPNFlux_6PNSOCoeff(m1M);
> 	    params->F6S2O = XLALSimInspiralPNFlux_6PNSOCoeff(m2M);
> 	    params->F6S1S2   = XLALSimInspiralPNFlux_6PNS1S2Coeff(m1M);
> 	    params->F6S1OS2O = XLALSimInspiralPNFlux_6PNS1S2OCoeff(m2M);
>             params->F6S1S1   = XLALSimInspiralPNFlux_6PNSelf2SCoeff(m1M);
>             params->F6S1OS1O = XLALSimInspiralPNFlux_6PNSelf2SOCoeff(m1M);
>             params->F6S2S2   = XLALSimInspiralPNFlux_6PNSelf2SCoeff(m2M);
>             params->F6S2OS2O = XLALSimInspiralPNFlux_6PNSelf2SOCoeff(m2M);
> 	    params->F4QMS1S1   = quadparam1*XLALSimInspiralPNFlux_6PNQM2SCoeff(m1M);
>             params->F6QMS1OS1O = quadparam1*XLALSimInspiralPNFlux_6PNQM2SOCoeff(m1M);
>             params->F6QMS2S2   = quadparam2*XLALSimInspiralPNFlux_6PNQM2SCoeff(m2M);
>             params->F6QMS2OS2O = quadparam2*XLALSimInspiralPNFlux_6PNQM2SOCoeff(m2M);
680,684c952,954
<             params->wdotSO25s1 = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(m1M);
<             params->wdotSO25s2 = XLALSimInspiralTaylorT4wdot_5PNSOCoeff(m2M);
<             params->ESO25s1 = XLALSimInspiralPNEnergy_5PNSOCoeff(m1M);
<             params->ESO25s2 = XLALSimInspiralPNEnergy_5PNSOCoeff(m2M);
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
---
> 	    params->F5S1O =XLALSimInspiralPNFlux_5PNSOCoeff(m1M);
> 	    params->F5S2O =XLALSimInspiralPNFlux_5PNSOCoeff(m2M);
> 	case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
686,699c956,957
<             params->LNhatSS2 	= -1.5 / eta;
<             params->wdotSS2     = XLALSimInspiralTaylorT4wdot_4PNS1S2Coeff(eta);
<             params->wdotSSO2    = XLALSimInspiralTaylorT4wdot_4PNS1S2OCoeff(eta);
<             params->ESS2 	= XLALSimInspiralPNEnergy_4PNS1S2Coeff(eta);
<             params->ESSO2       = XLALSimInspiralPNEnergy_4PNS1S2OCoeff(eta);
<             // 2PN quadrupole-monopole terms
<             params->wdotQM2S1 	= quadparam1 * XLALSimInspiralTaylorT4wdot_4PNQMCoeff(m1M);
<             params->wdotQM2S1L 	= quadparam1 * XLALSimInspiralTaylorT4wdot_4PNQMSOCoeff(m1M);
<             params->wdotQM2S2 	= quadparam2 *  XLALSimInspiralTaylorT4wdot_4PNQMCoeff(m2M);
<             params->wdotQM2S2L 	= quadparam2 *  XLALSimInspiralTaylorT4wdot_4PNQMSOCoeff(m2M);
<             params->EQM2S1      = XLALSimInspiralPNEnergy_4PNQM2SCoeff(m1M);
<             params->EQM2S1L 	= XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m1M);
<             params->EQM2S2 	= XLALSimInspiralPNEnergy_4PNQM2SCoeff(m2M);
<             params->EQM2S2L 	= XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m2M);
---
> 	    params->F4S1S2      = XLALSimInspiralPNFlux_4PNS1S2Coeff(eta);
> 	    params->F4S1OS2O    = XLALSimInspiralPNFlux_4PNS1S2OCoeff(eta);
701,711c959,970
<             params->wdotSSselfS1     = XLALSimInspiralTaylorT4wdot_4PNSelfSSCoeff(m1M);
<             params->wdotSSselfS1L    = XLALSimInspiralTaylorT4wdot_4PNSelfSSOCoeff(m1M);
<             params->wdotSSselfS2     = XLALSimInspiralTaylorT4wdot_4PNSelfSSCoeff(m2M);
<             params->wdotSSselfS2L    = XLALSimInspiralTaylorT4wdot_4PNSelfSSOCoeff(m2M);
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_15PN:
<             params->LNhatSO15s1 = 2. + 3./2. * m2m1;
<             params->LNhatSO15s2	= 2. + 3./2. * m1m2;
< 	    params->wdotSO15s1 	= XLALSimInspiralTaylorT4wdot_3PNSOCoeff(m1M);
<             params->wdotSO15s2 	= XLALSimInspiralTaylorT4wdot_3PNSOCoeff(m2M);
<             params->ESO15s1 	= XLALSimInspiralPNEnergy_3PNSOCoeff(m1M);
<             params->ESO15s2 	= XLALSimInspiralPNEnergy_3PNSOCoeff(m2M);
---
>             params->F4S1S1      = XLALSimInspiralPNFlux_4PNSelf2SCoeff(m1M);
>             params->F4S1OS1O    = XLALSimInspiralPNFlux_4PNSelf2SOCoeff(m1M);
>             params->F4S2S2      = XLALSimInspiralPNFlux_4PNSelf2SCoeff(m2M);
>             params->F4S2OS2O    = XLALSimInspiralPNFlux_4PNSelf2SOCoeff(m2M);
> 	    // 2PN quadrupole-monopole terms
> 	    params->F4QMS1S1    = quadparam1*XLALSimInspiralPNFlux_4PNQM2SCoeff(m1M);
>             params->F4QMS1OS1O  = quadparam1*XLALSimInspiralPNFlux_4PNQM2SOCoeff(m1M);
>             params->F4QMS2S2    = quadparam2*XLALSimInspiralPNFlux_4PNQM2SCoeff(m2M);
>             params->F4QMS2OS2O  = quadparam2*XLALSimInspiralPNFlux_4PNQM2SOCoeff(m2M);
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_15PN:
> 	    params->F3S1O      = XLALSimInspiralPNFlux_3PNSOCoeff(m1M);
>             params->F3S2O      = XLALSimInspiralPNFlux_3PNSOCoeff(m2M);
722c981
< 	
---
> 
725c984
<      * Coefficients found from Eqs. 2.11 and 3.10 of 
---
>      * Coefficients found from Eqs. 2.11 and 3.10 of
732,733c991
<             params->wdottidal6pn = lambda1 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralTaylorT4wdot_12PNTidalCoeff(m2M);
<             params->Etidal6pn =  lambda1*XLALSimInspiralPNEnergy_12PNTidalCoeff(m1M) + lambda2*XLALSimInspiralPNEnergy_12PNTidalCoeff(m2M);
---
>             params->Ftidal12 = lambda1 * XLALSimInspiralPNFlux_12PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNFlux_12PNTidalCoeff(m2M);
735,736c993
< 	    params->wdottidal5pn = lambda1 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralTaylorT4wdot_10PNTidalCoeff(m2M);
< 	    params->Etidal5pn = lambda1*XLALSimInspiralPNEnergy_10PNTidalCoeff(m1M) + lambda2*XLALSimInspiralPNEnergy_10PNTidalCoeff(m2M);
---
> 	    params->Ftidal10 = lambda1 * XLALSimInspiralPNFlux_10PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNFlux_10PNTidalCoeff(m2M);
745a1003,1004
>     XLALSimSpinTaylorEnergySpinDerivativeSetup(params,lambda1,lambda2,quadparam1,quadparam2);
> 
749,750c1008
< 
< static int XLALSimInspiralSpinTaylorT1Setup(
---
> static int XLALSimInspiralSpinTaylorT2Setup(
752,762c1010,1020
<     REAL8 m1,                       /**< mass of body 1 (kg) */
<     REAL8 m2,                       /**< mass of body 2 (kg) */
<     REAL8 fStart,                   /**< Starting GW freq. (Hz) */
<     REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
<     REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
<     REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
<     REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
<     REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
<     LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
<     LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
<     INT4 phaseO                     /**< twice post-Newtonian order */
---
>     const REAL8 m1_SI,                    /**< mass of body 1 (kg) */
>     const REAL8 m2_SI,                    /**< mass of body 2 (kg) */
>     const REAL8 fStart,                   /**< Starting GW freq. (Hz) */
>     const REAL8 fEnd,                     /**< Ending GW freq. (Hz), 0 means integrate forwards as far as possible */
>     const REAL8 lambda1,                  /**< (tidal deformability of mass 1) / (mass of body 1)^5 (dimensionless) */
>     const REAL8 lambda2,                  /**< (tidal deformability of mass 2) / (mass of body 2)^5 (dimensionless) */
>     const REAL8 quadparam1,               /**< phenom. parameter describing induced quad. moment of body 1 (=1 for BHs, ~2-12 for NSs) */
>     const REAL8 quadparam2,               /**< phenom. parameter describing induced quad. moment of body 2 (=1 for BHs, ~2-12 for NSs) */
>     const LALSimInspiralSpinOrder spinO,  /**< twice PN order of spin effects */
>     const LALSimInspiralTidalOrder tideO, /**< twice PN order of tidal effects */
>     const INT4 phaseO                     /**< twice post-Newtonian order */
765,790d1022
<     REAL8 M, eta, Mchirp, m1m2, m2m1, m1M, m2M;
<     /* Zero the coefficients */
<     memset(params, 0, sizeof(XLALSimInspiralSpinTaylorTxCoeffs));
< 
<     /* Define mass variables and other coefficients */
<     m1m2 = m1 / m2;
<     m2m1 = m2 / m1;
<     m1 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m1 from kg to seconds */
<     m2 *= LAL_G_SI / pow(LAL_C_SI, 3.0); /* convert m2 from kg to seconds */
<     M = m1 + m2;
<     m1M = m1 / M;
<     m2M = m2 / M;
<     eta = m1 * m2 / M / M;
<     Mchirp = M * pow(eta, 3./5.);
<     params->wdotnewt = (96.0/5.0) * eta;
<     params->dEdvnewt = - 0.5 *eta;
<     params->Fnewt = (32./5.)*eta*eta;
<     params->M = M;
<     params->Mchirp = Mchirp;
<     params->m1M = m1M;
<     params->m2M = m2M;
<     params->eta = eta;
<     params->fStart = fStart;
<     params->fEnd = fEnd;
<     params->spinO = spinO;
<     params->tideO = tideO;
792,794c1024,1030
<     /* Set coefficients up to PN order phaseO.
<      * epnorb is the binary energy and
<      * wdotorb is the derivative of the orbital frequency \f$\dot{\omega}\f$.
---
>     XLALSimSpinTaylorSetCommonCoeffs(params,m1_SI,m2_SI,fStart,fEnd,spinO,tideO,phaseO);
>     REAL8 eta=params->eta;
>     REAL8 m1M=params->m1M;
>     REAL8 m2M=params->m2M;
> 
>     /* Set wdot coefficients up to PN order phaseO.
>      * wdot is the derivative of the orbital frequency \f$\dot{\omega}\f$.
808,810c1044
< 
< 
< switch( phaseO )
---
>     switch( phaseO )
816,817c1050
<             params->Fcoeff[7] = XLALSimInspiralPNFlux_7PNCoeff(eta);
<             params->Ecoeff[7] = 0.;
---
> 	    params->wdotcoeff[7] = XLALSimInspiralTaylorT2dtdv_7PNCoeff(eta);
820,821c1053,1055
<             params->Fcoeff[6] = XLALSimInspiralPNFlux_6PNCoeff(eta);
< 	    params->Flogcoeff = XLALSimInspiralPNFlux_6PNLogCoeff(eta);
---
>             params->wdotcoeff[6] = XLALSimInspiralTaylorT2dtdv_6PNCoeff(eta);
>             params->wdotlogcoeff = XLALSimInspiralTaylorT2dtdv_6PNLogCoeff(eta);
>             params->Ecoeff[7] = 0.;
825c1059
< 	    params->Fcoeff[5] = XLALSimInspiralPNFlux_5PNCoeff(eta);
---
>             params->wdotcoeff[5] = XLALSimInspiralTaylorT2dtdv_5PNCoeff(eta);
829,830c1063,1064
<             params->Fcoeff[4] = XLALSimInspiralPNFlux_4PNCoeff(eta);
< 	    params->Ecoeff[4] = XLALSimInspiralPNEnergy_4PNCoeff(eta);
---
>             params->wdotcoeff[4] = XLALSimInspiralTaylorT2dtdv_4PNCoeff(eta);
>             params->Ecoeff[4] = XLALSimInspiralPNEnergy_4PNCoeff(eta);
833,834c1067,1068
<             params->Fcoeff[3] = XLALSimInspiralPNFlux_3PNCoeff(eta);
< 	    params->Ecoeff[3] = 0.;
---
>             params->wdotcoeff[3] = XLALSimInspiralTaylorT2dtdv_3PNCoeff(eta);
>             params->Ecoeff[3] = 0.;
837c1071
< 	    params->Fcoeff[2] = XLALSimInspiralPNFlux_2PNCoeff(eta);
---
>             params->wdotcoeff[2] = XLALSimInspiralTaylorT2dtdv_2PNCoeff(eta);
841c1075
< 	    params->Fcoeff[1] = 0.;
---
>             params->wdotcoeff[1] = 0.;
845c1079
< 	    params->Fcoeff[0] = 1.;
---
>             params->wdotcoeff[0] = 1.;
854a1089,1091
>     /* Compute the non-dynamical coefficients of spin corrections
>      * to the evolution equations for omega, L, S1 and S2 and binary energy E.
>      */
856,864c1093,1096
<     {
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
< 	case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
<             params->ESO35s1 = XLALSimInspiralPNEnergy_7PNSOCoeff(m1M);
<             params->dEdvSO35s1 = 9.* XLALSimInspiralPNEnergy_7PNSOCoeff(m1M);
< 	    params->ESO35s2 = XLALSimInspiralPNEnergy_7PNSOCoeff(m2M);
< 	    params->dEdvSO35s2 =9.* XLALSimInspiralPNEnergy_7PNSOCoeff(m2M);
< 	    params->FSO35s1=XLALSimInspiralPNFlux_7PNSOCoeff(m1M);
< 	    params->FSO35s2=XLALSimInspiralPNFlux_7PNSOCoeff(m2M);
---
>     {   // case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
>             params->wdot7S1O = XLALSimInspiralTaylorT2dtdv_7PNSOCoeff(m1M);
>             params->wdot7S2O = XLALSimInspiralTaylorT2dtdv_7PNSOCoeff(m2M);
866,867c1098,1110
< 	    params->FSO3s1 = XLALSimInspiralPNFlux_6PNSOCoeff(m1M);
< 	    params->FSO3s2 = XLALSimInspiralPNFlux_6PNSOCoeff(m2M);
---
>             params->wdot6S1O    = XLALSimInspiralTaylorT2dtdv_6PNSOCoeff(m1M);
>             params->wdot6S2O    = XLALSimInspiralTaylorT2dtdv_6PNSOCoeff(m2M);
>             params->wdot6S1S2   = XLALSimInspiralTaylorT2dtdv_6PNS1S2Coeff(eta);
>             params->wdot6S1OS2O = XLALSimInspiralTaylorT2dtdv_6PNS1S2OCoeff(eta);
>             params->wdot6S1S1   = XLALSimInspiralTaylorT2dtdv_6PNSelf2SCoeff(m1M);
>             params->wdot6S2S2   = XLALSimInspiralTaylorT2dtdv_6PNSelf2SCoeff(m2M);
>             params->wdot6S1OS1O = XLALSimInspiralTaylorT2dtdv_6PNSelf2SOCoeff(m1M);
>             params->wdot6S2OS2O = XLALSimInspiralTaylorT2dtdv_6PNSelf2SOCoeff(m2M);
>             params->wdot6QMS1S1 = XLALSimInspiralTaylorT2dtdv_6PNQM2SCoeff(m1M);
>             params->wdot6QMS2S2 = XLALSimInspiralTaylorT2dtdv_6PNQM2SCoeff(m2M);
>             params->wdot6QMS1OS1O  = XLALSimInspiralTaylorT2dtdv_6PNQM2SOCoeff(m1M);
>             params->wdot6QMS2OS2O  = XLALSimInspiralTaylorT2dtdv_6PNQM2SOCoeff(m2M);
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
869,902c1112,1127
<             params->ESO25s1 = XLALSimInspiralPNEnergy_5PNSOCoeff(m1M);
< 	    params->dEdvSO25s1 =7.* XLALSimInspiralPNEnergy_5PNSOCoeff(m1M);
<             params->ESO25s2 = XLALSimInspiralPNEnergy_5PNSOCoeff(m2M);
< 	    params->dEdvSO25s2 =7.* XLALSimInspiralPNEnergy_5PNSOCoeff(m2M);
< 	    params->FSO25s1 =XLALSimInspiralPNFlux_5PNSOCoeff(m1M);
< 	    params->FSO25s2 =XLALSimInspiralPNFlux_5PNSOCoeff(m2M);
< 
< 	case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
<             // 2PN spin-spin terms
<             params->LNhatSS2 	= -1.5 / eta;
<             params->ESS2 	= XLALSimInspiralPNEnergy_4PNS1S2Coeff(eta);
<             params->ESSO2       = XLALSimInspiralPNEnergy_4PNS1S2OCoeff(eta);
<             params->dEdvSS2    = 6.* XLALSimInspiralPNEnergy_4PNS1S2Coeff(eta);
<             params->dEdvSSO2    = 6.* XLALSimInspiralPNEnergy_4PNS1S2OCoeff(eta);
< 	    params->FSS2        = XLALSimInspiralPNFlux_4PNS1S2Coeff(eta);
< 	    params->FSSO2       = XLALSimInspiralPNFlux_4PNS1S2OCoeff(eta);
< 	 // 2PN quadrupole-monopole terms
<             params->EQM2S1      = XLALSimInspiralPNEnergy_4PNQM2SCoeff(m1M);
<             params->EQM2S1L 	= XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m1M);
<             params->EQM2S2 	= XLALSimInspiralPNEnergy_4PNQM2SCoeff(m2M);
<             params->EQM2S2L 	= XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m2M);
<             params->dEdvQM2S1   = 6.* XLALSimInspiralPNEnergy_4PNQM2SCoeff(m1M);
<             params->dEdvQM2S1L  = 6.*  XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m1M);
<             params->dEdvQM2S2   = 6.* XLALSimInspiralPNEnergy_4PNQM2SCoeff(m2M);
<             params->dEdvQM2S2L  = 6.* XLALSimInspiralPNEnergy_4PNQM2SOCoeff(m2M);
< 	    params->FQM2S1      = quadparam1*XLALSimInspiralPNFlux_4PNQM2SCoeff(m1M);
<             params->FQM2S1L     = quadparam1*XLALSimInspiralPNFlux_4PNQM2SOCoeff(m1M);
<             params->FQM2S2      = quadparam2*XLALSimInspiralPNFlux_4PNQM2SCoeff(m2M);
<             params->FQM2S2L     = quadparam2*XLALSimInspiralPNFlux_4PNQM2SOCoeff(m2M);
<            // 2PN self-spin terms
<             params->FSSselfS1     = XLALSimInspiralPNFlux_4PNSelf2SCoeff(m1M);
<             params->FSSselfS1L    = XLALSimInspiralPNFlux_4PNSelf2SOCoeff(m1M);
<             params->FSSselfS2     = XLALSimInspiralPNFlux_4PNSelf2SCoeff(m2M);
<             params->FSSselfS2L    = XLALSimInspiralPNFlux_4PNSelf2SOCoeff(m2M);
---
>             params->wdot5S1O = XLALSimInspiralTaylorT2dtdv_5PNSOCoeff(m1M);
>             params->wdot5S2O = XLALSimInspiralTaylorT2dtdv_5PNSOCoeff(m2M);
>         case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
>             // 2PN spin1-spin2 terms
>             params->wdot4S1S2 	= XLALSimInspiralTaylorT2dtdv_4PNS1S2Coeff(eta);
>             params->wdot4S1OS2O = XLALSimInspiralTaylorT2dtdv_4PNS1S2OCoeff(eta);
>             // 2PN spin-self^2 terms
>             params->wdot4S1S1   = XLALSimInspiralTaylorT2dtdv_4PNSelf2SCoeff(m1M);
>             params->wdot4S1OS1O = XLALSimInspiralTaylorT2dtdv_4PNSelf2SOCoeff(m1M);
>             params->wdot4S2S2   = XLALSimInspiralTaylorT2dtdv_4PNSelf2SCoeff(m2M);
>             params->wdot4S2OS2O = XLALSimInspiralTaylorT2dtdv_4PNSelf2SOCoeff(m2M);
>             // 2PN quadrupole-monopole self spin terms
>             params->wdot4QMS1S1   = quadparam1 * XLALSimInspiralTaylorT2dtdv_4PNQM2SCoeff(m1M);
>             params->wdot4QMS1OS1O = quadparam1 * XLALSimInspiralTaylorT2dtdv_4PNQM2SOCoeff(m1M);
>             params->wdot4QMS2S2   = quadparam2 * XLALSimInspiralTaylorT2dtdv_4PNQM2SCoeff(m2M);
>             params->wdot4QMS2OS2O = quadparam2 * XLALSimInspiralTaylorT2dtdv_4PNQM2SOCoeff(m2M);
904,911c1129,1132
<             params->LNhatSO15s1 = 2. + 3./2. * m2m1;
<             params->LNhatSO15s2	= 2. + 3./2. * m1m2;
<             params->ESO15s1 	= XLALSimInspiralPNEnergy_3PNSOCoeff(m1M);
<             params->ESO15s2 	= XLALSimInspiralPNEnergy_3PNSOCoeff(m2M);
< 	    params->dEdvSO15s1  = 5.* XLALSimInspiralPNEnergy_3PNSOCoeff(m1M);
<             params->dEdvSO15s2  = 5.* XLALSimInspiralPNEnergy_3PNSOCoeff(m2M);
< 	    params->FSO15s1     = XLALSimInspiralPNFlux_3PNSOCoeff(m1M);
<             params->FSO15s2     = XLALSimInspiralPNFlux_3PNSOCoeff(m2M);
---
>             // Note: LNHat do not have their signs reversed relative to T4
>             // They are precession rather than orbital quantities
> 	    params->wdot3S1O 	= XLALSimInspiralTaylorT2dtdv_3PNSOCoeff(m1M);
>             params->wdot3S2O 	= XLALSimInspiralTaylorT2dtdv_3PNSOCoeff(m2M);
923c1144,1145
<     /* Compute the coefficients of tidal corrections
---
>     /*
>      * Compute the coefficients of tidal corrections
932,933c1154,1155
<             params->Ftidal6pn = lambda1 * XLALSimInspiralPNFlux_12PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNFlux_12PNTidalCoeff(m2M);
<             params->Etidal6pn =  lambda1*XLALSimInspiralPNEnergy_12PNTidalCoeff(m1M) + lambda2*XLALSimInspiralPNEnergy_12PNTidalCoeff(m2M);
---
> 	    params->wdottidal12 = lambda1 * XLALSimInspiralTaylorT2dtdv_12PNTidalCoeff(m1M)
> 	                         + lambda2 * XLALSimInspiralTaylorT2dtdv_12PNTidalCoeff(m2M);
935,936c1157,1158
< 	    params->Ftidal5pn = lambda1 * XLALSimInspiralPNFlux_10PNTidalCoeff(m1M) + lambda2 * XLALSimInspiralPNFlux_10PNTidalCoeff(m2M);
< 	    params->Etidal5pn = lambda1*XLALSimInspiralPNEnergy_10PNTidalCoeff(m1M) + lambda2*XLALSimInspiralPNEnergy_10PNTidalCoeff(m2M);
---
> 	    params->wdottidal10 = lambda1 * XLALSimInspiralTaylorT2dtdv_10PNTidalCoeff(m1M)
> 	                         + lambda2 * XLALSimInspiralTaylorT2dtdv_10PNTidalCoeff(m2M);
945a1168,1169
>     XLALSimSpinTaylorEnergySpinDerivativeSetup(params,lambda1,lambda2,quadparam1,quadparam2);
> 
949d1172
< 
1868a2092,2154
> INT4 XLALSimInspiralSetEnergyPNTerms(REAL8 *Espin3,
> 				     REAL8 *Espin4,
> 				     REAL8 *Espin5,
> 				     REAL8 *Espin6,
> 				     REAL8 *Espin7,
> 				     XLALSimInspiralSpinTaylorTxCoeffs *params,
> 				     const REAL8 LNhdotS1,
> 				     const REAL8 LNhdotS2,
> 				     const REAL8 S1sq,
> 				     const REAL8 S2sq,
> 				     const REAL8 S1dotS2)
> {
>   *Espin3=0.;
>   *Espin4=0.;
>   *Espin5=0.;
>   *Espin6=0.;
>   *Espin7=0.;
>   switch( params->spinO ) {
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
>       // Compute 3.5PN SO correction to energy
>       // See Eq. 3.15 of arXiv:1303.7412
>       // Note that S_l/M^2 = (m1/M)^2 chi1 + (m2/M)^2 chi2
>       // and Sigma_l/M^2 = (m2/M) chi2 - (m1/M) chi1
>       *Espin7 += params->E7S1O * LNhdotS1 + params->E7S2O * LNhdotS2;
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_3PN:
>       *Espin6 = params->E6S1S2*S1dotS2 + params->E6S1OS2O*LNhdotS1*LNhdotS2
> 	+ (params->E6S1S1 + params->E6QMS1S1)*S1sq
> 	+ (params->E6S2S2 + params->E6QMS2S2)*S2sq
> 	+ params->E6QMS1OS1O * LNhdotS1 * LNhdotS1
> 	+ params->E6QMS2OS2O * LNhdotS2 * LNhdotS2;
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_25PN:
>       // Compute 2.5PN SO correction to energy
>       // See Eq. 7.9 of gr-qc/0605140v4
>       // Note that S_l/M^2 = (m1/M)^2 chi1 + (m2/M)^2 chi2
>       // and Sigma_l/M^2 = (m2/M) chi2 - (m1/M) chi1
>       *Espin5 += params->E5S1O * LNhdotS1 + params->E5S2O * LNhdotS2;
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
>       // Compute S1-S2 spin-spin term
>       *Espin4 += params->E4S1S2  * S1dotS2 + params->E4S1OS2O * LNhdotS1 * LNhdotS2;
>       // Compute 2PN quadrupole-monopole correction to energy
>       // See last line of Eq. 6 of astro-ph/0504538
>       // or 2nd and 3rd lines of Eq. (C4) in arXiv:0810.5336v3
>       *Espin4 += params->E4QMS1S1 * S1sq
> 	+ params->E4QMS2S2 * S2sq
> 	+ params->E4QMS1OS1O * LNhdotS1 * LNhdotS1
> 	+ params->E4QMS2OS2O * LNhdotS2 * LNhdotS2;
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_15PN:
>       // Compute 1.5PN SO correction to energy
>       *Espin3 += params->E3S1O * LNhdotS1 + params->E3S2O * LNhdotS2;
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_1PN:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_05PN:
>     case LAL_SIM_INSPIRAL_SPIN_ORDER_0PN:
>       break;
>     default:
>       XLALPrintError("XLAL Error - %s: Invalid spin PN order %d\n",
> 		     __func__, params->spinO );
>       XLAL_ERROR(XLAL_EINVAL);
>       break;
>     }
>     return XLAL_SUCCESS;
> }
> 
1882c2168
< 	double dvalues[], 
---
> 	double dvalues[],
1885c2171
< {//   fprintf(stdout,"Enter %s\n","StopingTest");
---
> {
1888c2174,2179
<     REAL8 LNdotS1, LNdotS2, S1dotS2, S1sq, S2sq;
---
>     REAL8 LNhdotS1, LNhdotS2, S1dotS2, S1sq, S2sq;
>     REAL8 Espin7=0.;
>     REAL8 Espin6=0.;
>     REAL8 Espin5=0.;
>     REAL8 Espin4=0.;
>     REAL8 Espin3=0.;
1892d2182
<     REAL8 Espin15 = 0., Espin2 = 0., Espin25 = 0., Espin35 = 0.;
1895c2185
<     v = pow(omega,1./3.);
---
>     v = cbrt(omega);
1899,1900c2189,2193
<     LNdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
<     LNdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
---
>     LNhdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
>     LNhdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
>     S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
>     S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
>     S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
1903,1905c2196,2198
<      * Note params->M is really G M /c^3 (i.e. M is in seconds) */
<     omegaStart = LAL_PI * params->M * params->fStart;
<     omegaEnd = LAL_PI * params->M * params->fEnd;
---
>      * Note params->M is in solar mass units */
>     omegaStart = LAL_PI * params->M*LAL_MTSUN_SI * params->fStart;
>     omegaEnd = LAL_PI * params->M*LAL_MTSUN_SI * params->fEnd;
1907,1952c2200
<     //  fprintf(stderr,"omegaStart %f\n",omegaStart);
<     //  fprintf(stderr,"omegaend %f\n",omegaEnd);
< 
< 
<     switch( params->spinO )
<     {
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_ALL:
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_35PN:
<             // Compute 3.5PN SO correction to energy
<             // See Eq. 3.15 of arXiv:1303.7412
<             // Note that S_l/M^2 = (m1/M)^2 chi1 + (m2/M)^2 chi2
<             // and Sigma_l/M^2 = (m2/M) chi2 - (m1/M) chi1
<             Espin35 += params->ESO35s1 * LNdotS1 + params->ESO35s2 * LNdotS2;
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_3PN:
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_25PN:
<             // Compute 2.5PN SO correction to energy
<             // See Eq. 7.9 of gr-qc/0605140v4
<             // Note that S_l/M^2 = (m1/M)^2 chi1 + (m2/M)^2 chi2
<             // and Sigma_l/M^2 = (m2/M) chi2 - (m1/M) chi1
<             Espin25 += params->ESO25s1 * LNdotS1 + params->ESO25s2 * LNdotS2;
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_2PN:
<             // Compute S1-S2 spin-spin term
<             S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
<             Espin2 += params->ESS2  * S1dotS2 + params->ESSO2 * LNdotS1 * LNdotS2;
<             // Compute 2PN quadrupole-monopole correction to energy
<             // See last line of Eq. 6 of astro-ph/0504538
<             // or 2nd and 3rd lines of Eq. (C4) in arXiv:0810.5336v3
<             S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
<             S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
<             Espin2 += params->EQM2S1 * S1sq
<                     + params->EQM2S2 * S2sq
<                     + params->EQM2S1L * LNdotS1 * LNdotS1
<                     + params->EQM2S2L * LNdotS2 * LNdotS2;
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_15PN:
<             // Compute 1.5PN SO correction to energy
<             Espin15 += params->ESO15s1 * LNdotS1 + params->ESO15s2 * LNdotS2;
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_1PN:
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_05PN:
<         case LAL_SIM_INSPIRAL_SPIN_ORDER_0PN:
<             break;
<         default:
<             XLALPrintError("XLAL Error - %s: Invalid spin PN order %d\n",
<                     __func__, params->spinO );
<             XLAL_ERROR(XLAL_EINVAL);
<             break;
<     }
---
>     XLALSimInspiralSetEnergyPNTerms(&Espin3,&Espin4,&Espin5,&Espin6,&Espin7,params,LNhdotS1,LNhdotS2,S1sq,S2sq,S1dotS2);
1962,1970c2210,2216
<             + v * ( 5. * (params->Ecoeff[3] + Espin15) 
<             + v * ( 6. * (params->Ecoeff[4] + Espin2)
<             + v * ( 7. * (params->Ecoeff[5] + Espin25)
<             + v * ( 8. *  params->Ecoeff[6]
<             + v * ( 9. * (params->Ecoeff[7] + Espin35)
< 			+ v * v * v * ( 12. * params->Etidal5pn
< 			+ v * v * ( 14. * params->Etidal6pn ) ) ) ) ) ) ) );
<   //  fprintf(stderr,"TestValue %f\n",test);
<  //fprintf(stderr,"test",test)
---
>             + v * ( 5. * (params->Ecoeff[3] + Espin3)
>             + v * ( 6. * (params->Ecoeff[4] + Espin4)
>             + v * ( 7. * (params->Ecoeff[5] + Espin5)
> 	    + v * ( 8. * (params->Ecoeff[6] + Espin6)
>             + v * ( 9. * (params->Ecoeff[7] + Espin7)
> 			+ v * v * v * ( 12. * params->Etidal10
> 			+ v * v * ( 14. * params->Etidal12 ) ) ) ) ) ) ) );
1982d2227
<         //fprintf(stderr,"one %s\n");
1986d2230
<         //fprintf(stderr,"two %s\n");
1989d2232
<         //fprintf(stderr,"three %s\n");
1992d2234
<         //fprintf(stderr,"four %s\n");
1995d2236
<         //fprintf(stderr,"five %s\n");
1998d2238
<         //fprintf(stderr,"six %s\n");
2001d2240
<         //fprintf(stderr,"SUCCESS %s\n");
2016,2019c2255,2258
< static int XLALSimInspiralSpinTaylorT4Derivatives(
< 	double UNUSED t,
< 	const double values[],
< 	double dvalues[], 
---
> INT4 XLALSimInspiralSpinTaylorT4Derivatives(
> 	REAL8 UNUSED t,
> 	const REAL8 values[],
> 	REAL8 dvalues[],
2021c2260
< 	) 
---
> 	)
2025c2264
<     REAL8 omega, ds, domega, dLNhx, dLNhy, dLNhz;
---
>     REAL8 omega, domega, dLNhx, dLNhy, dLNhz;
2026a2266
>     REAL8 dphiExtra=0.;
2029,2034c2269,2271
<     REAL8 v, v2, v3, v4, v5, v7, v11, omega2, omega2by2;
<     REAL8 LNdotS1, LNdotS2, threeLNdotS1, threeLNdotS2, S1dotS2, S1sq, S2sq;
<     REAL8 v5etaLNhatSO15s1, v5etaLNhatSO15s2;
<     REAL8 OmegaLx, OmegaLy, OmegaLz, OmegaLdotLN;
<     REAL8 OmegaEx, OmegaEy, OmegaEz, OmegaSx, OmegaSy, OmegaSz;
<     REAL8 wspin15 = 0., wspin2 = 0., wspin25 = 0., wspin3 = 0., wspin35 = 0.;
---
>     REAL8 v, v2, v11;
>     REAL8 LNhdotS1, LNhdotS2, S1dotS2, S1sq, S2sq;
>     REAL8 wspin3 = 0., wspin4 = 0., wspin5 = 0., wspin6 = 0., wspin7 = 0.;
2053,2054c2290,2291
<     v2  = v * v; v3 = v2 * v; v4 = v3 * v; 
<     v5 = v * v4; v7 = v4 * v3; v11 = v7 * v4;
---
>     v2  = v * v;
>     v11= omega*omega*omega*v2;
2056,2057c2293,2294
<     LNdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
<     LNdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
---
>     LNhdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
>     LNhdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
2058a2296,2297
>     S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
>     S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
2083c2322
<             wspin35 = params->wdotSO35s1*LNdotS1 + params->wdotSO35s2*LNdotS2;
---
>             wspin7 = params->wdot7S1O*LNhdotS1 + params->wdot7S2O*LNhdotS2;
2089c2328,2332
<             wspin3 = params->wdotSO3s1 * LNdotS1 + params->wdotSO3s2 * LNdotS2;
---
>             wspin6 = params->wdot6S1O * LNhdotS1 + params->wdot6S2O * LNhdotS2
> 	      + params->wdot6S1OS2O*LNhdotS1*LNhdotS2 + params->wdot6S1S2*S1dotS2
> 	      + (params->wdot6S1S1+params->wdot6QMS1S1)*S1sq + (params->wdot6S2S2+params->wdot6QMS2S2)*S2sq
> 	      + (params->wdot6S1OS1O+params->wdot6QMS1OS1O)*LNhdotS1*LNhdotS1
> 	      + (params->wdot6S2OS2O+params->wdot6QMS2OS2O)*LNhdotS2*LNhdotS2;
2095c2338
<             wspin25 = params->wdotSO25s1*LNdotS1 + params->wdotSO25s2*LNdotS2;
---
>             wspin5 = params->wdot5S1O*LNhdotS1 + params->wdot5S2O*LNhdotS2;
2098,2099c2341
<             S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
<             wspin2 = params->wdotSS2 *S1dotS2 + params->wdotSSO2 * LNdotS1 * LNdotS2;
---
>             wspin4 = params->wdot4S1S2 *S1dotS2 + params->wdot4S1OS2O * LNhdotS1 * LNhdotS2;
2102,2111c2344,2351
<             S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
<             S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
<             wspin2 += params->wdotQM2S1 * S1sq
<                     + params->wdotQM2S2 * S2sq
<                     + params->wdotQM2S1L * LNdotS1 * LNdotS1
<                     + params->wdotQM2S2L * LNdotS2 * LNdotS2
<                     + params->wdotSSselfS1 * S1sq
<                     + params->wdotSSselfS2 * S2sq
<                     + params->wdotSSselfS1L * LNdotS1 * LNdotS1
<                     + params->wdotSSselfS2L * LNdotS2 * LNdotS2;
---
>             wspin4 += params->wdot4QMS1S1 * S1sq
>                     + params->wdot4QMS2S2 * S2sq
>                     + params->wdot4QMS1OS1O * LNhdotS1 * LNhdotS1
>                     + params->wdot4QMS2OS2O * LNhdotS2 * LNhdotS2
>                     + params->wdot4S1S1 * S1sq
>                     + params->wdot4S2S2 * S2sq
>                     + params->wdot4S1OS1O * LNhdotS1 * LNhdotS1
>                     + params->wdot4S2OS2O * LNhdotS2 * LNhdotS2;
2114c2354
<             wspin15 = params->wdotSO15s1*LNdotS1 + params->wdotSO15s2*LNdotS2;
---
>             wspin3 = params->wdot3S1O*LNhdotS1 + params->wdot3S2O*LNhdotS2;
2129,2132c2369,2372
<             + v * ( params->wdotcoeff[3] + wspin15
<             + v * ( params->wdotcoeff[4] + wspin2
<             + v * ( params->wdotcoeff[5] + wspin25
<             + v * ( params->wdotcoeff[6] + wspin3
---
>             + v * ( params->wdotcoeff[3] + wspin3
>             + v * ( params->wdotcoeff[4] + wspin4
>             + v * ( params->wdotcoeff[5] + wspin5
>             + v * ( params->wdotcoeff[6] + wspin6
2134,2156c2374,2376
<             + v * ( params->wdotcoeff[7] + wspin35
<             + v3 * ( params->wdottidal5pn
<             + v2 * ( params->wdottidal6pn ) ) ) ) ) ) ) ) ) );
<      // fprintf(stdout,"domega\n%f",domega);
<     /*
<      * dLN
<      * 
<      * \f$d \hat{L_N}/d \hat{t} = M * d\hat{L_N} / dt = \Omega_L x \hat{L_N}\f$
<      * This is Eq. (10) of gr-qc/0405090 ( times M b/c we use \f$\hat{t}\f$)
<      */
<     omega2 = omega * omega;
<     /* \Omega_L vector */
<     OmegaLx = omega2 * (params->LNhatSO15s1 * S1x + params->LNhatSO15s2 * S2x)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1x + LNdotS1 * S2x);
<     OmegaLy = omega2 * (params->LNhatSO15s1 * S1y + params->LNhatSO15s2 * S2y)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1y + LNdotS1 * S2y);
<     OmegaLz = omega2 * (params->LNhatSO15s1 * S1z + params->LNhatSO15s2 * S2z)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1z + LNdotS1 * S2z);
< 
<     /* Take cross product of \Omega_L with \hat{L_N} */
<     dLNhx = (-OmegaLz*LNhy + OmegaLy*LNhz);
<     dLNhy = (-OmegaLx*LNhz + OmegaLz*LNhx);
<     dLNhz = (-OmegaLy*LNhx + OmegaLx*LNhy);
---
>             + v * ( params->wdotcoeff[7] + wspin7
>             + omega * ( params->wdottidal10
>             + v2 * ( params->wdottidal12 ) ) ) ) ) ) ) ) ) );
2158,2218c2378
<     /*
<      * dE1
<      * 
<      * d E_1 / d \hat{t} = M * d E_1 / dt
<      * Computed from \Omega_L and \hat{L_N} with Eq. (15)-(16) of gr-qc/0310034
<      */
<     OmegaLdotLN = OmegaLx * LNhx + OmegaLy * LNhy + OmegaLz * LNhz;
<     /* \Omega_E vector */
<     OmegaEx = OmegaLx - OmegaLdotLN * LNhx;
<     OmegaEy = OmegaLy - OmegaLdotLN * LNhy;
<     OmegaEz = OmegaLz - OmegaLdotLN * LNhz;
< 
<     /* Take cross product of \Omega_E with E_1 */
<     dE1x = (-OmegaEz*E1y + OmegaEy*E1z);
<     dE1y = (-OmegaEx*E1z + OmegaEz*E1x);
<     dE1z = (-OmegaEy*E1x + OmegaEx*E1y);
< 
<     /*
<      * dS1
<      * 
<      * d S_1 / d \hat{t} = M * d S_1 / dt = \Omega_{S1} x S_1
<      * This is Eq. (8) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S1} vector */
<     omega2by2 = omega2 * 0.5;
<     threeLNdotS2 = 3. * LNdotS2;
<     v5etaLNhatSO15s1 = v5 * params->eta * params->LNhatSO15s1;
<     OmegaSx = v5etaLNhatSO15s1 * LNhx
<             + omega2by2 * (S2x - threeLNdotS2 * LNhx);
<     OmegaSy = v5etaLNhatSO15s1 * LNhy
<             + omega2by2 * (S2y - threeLNdotS2 * LNhy);
<     OmegaSz = v5etaLNhatSO15s1 * LNhz
<             + omega2by2 * (S2z - threeLNdotS2 * LNhz);
< 
<     /* Take cross product of \Omega_{S1} with S_1 */
<     dS1x = (-OmegaSz*S1y + OmegaSy*S1z);
<     dS1y = (-OmegaSx*S1z + OmegaSz*S1x);
<     dS1z = (-OmegaSy*S1x + OmegaSx*S1y);
< 
<     /*
<      * dS2
<      * 
<      * d S_2 / d \hat{t} = M * d S_2 / dt = \Omega_{S2} x S_2
<      * This is Eq. (9) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S2} vector */
<     threeLNdotS1 = 3. * LNdotS1;
<     v5etaLNhatSO15s2 = v5 * params->eta * params->LNhatSO15s2;
<     OmegaSx = v5etaLNhatSO15s2 * LNhx
<             + omega2by2 * (S1x - threeLNdotS1 * LNhx);
<     OmegaSy = v5etaLNhatSO15s2 * LNhy
<             + omega2by2 * (S1y - threeLNdotS1 * LNhy);
<     OmegaSz = v5etaLNhatSO15s2 * LNhz
<             + omega2by2 * (S1z - threeLNdotS1 * LNhz);
< 
<     /* Take cross product of \Omega_{S2} with S_2 */
<     dS2x = (-OmegaSz*S2y + OmegaSy*S2z);
<     dS2y = (-OmegaSx*S2z + OmegaSz*S2x);
<     dS2z = (-OmegaSy*S2x + OmegaSx*S2y);
---
>     XLALSimInspiralSpinDerivatives(&dLNhx,&dLNhy,&dLNhz,&dE1x,&dE1y,&dE1z,&dS1x,&dS1y,&dS1z,&dS2x,&dS2y,&dS2z,&dphiExtra,v,LNhx,LNhy,LNhz,E1x,E1y,E1z,S1x,S1y,S1z,S2x,S2y,S2z,LNhdotS1,LNhdotS2,params);
2221,2223c2381
<     ds = omega;
< 
<     dvalues[0]    = ds   ; dvalues[1]     = domega;
---
>     dvalues[0]    = omega+dphiExtra; dvalues[1]     = domega;
2241c2399
<     REAL8 omega, ds, domega, dLNhx, dLNhy, dLNhz;
---
>     REAL8 omega, domega, dLNhx, dLNhy, dLNhz;
2245,2249c2403,2404
<     REAL8 v, v2, v3, v4, v5, v7, v11, omega2, omega2by2;
<     REAL8 LNdotS1, LNdotS2, threeLNdotS1, threeLNdotS2, S1dotS2, S1sq, S2sq;
<     REAL8 v5etaLNhatSO15s1, v5etaLNhatSO15s2;
<     REAL8 OmegaLx, OmegaLy, OmegaLz, OmegaLdotLN;
<     REAL8 OmegaEx, OmegaEy, OmegaEz, OmegaSx, OmegaSy, OmegaSz;
---
>     REAL8 v, v2, v3, v4, v7, v11;
>     REAL8 LNhdotS1, LNhdotS2, S1dotS2, S1sq, S2sq;
2251,2252c2406,2408
<     REAL8 Fspin15 = 0., Fspin2 = 0., Fspin25 = 0., Fspin3 = 0., Fspin35 = 0.;
<     REAL8 Espin15 = 0., Espin2 = 0., Espin25 = 0., Espin35 = 0.;
---
>     REAL8 Fspin3 = 0., Fspin4 = 0., Fspin5 = 0., Fspin6 = 0., Fspin7 = 0.;
>     REAL8 Espin3 = 0., Espin4 = 0., Espin5 = 0., Espin6 = 0., Espin7 = 0.;
>     REAL8 dphiExtra=0.;
2257,2258d2412
<      //UNUSED(t);
< 
2260d2413
<     // UNUSED!!: s    = values[0] ;
2274c2427
<     v5 = v * v4; v7 = v4 * v3; v11 = v7 * v4;
---
>     v7 = v4 * v3; v11 = v7 * v4;
2276,2277c2429,2430
<     LNdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
<     LNdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
---
>     LNhdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
>     LNhdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
2278a2432,2434
>     S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
>     S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
>     S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
2303,2304c2459
<            Fspin35 += params->FSO35s1*LNdotS1 + params->FSO35s2*LNdotS2;
< 	   Espin35 += params->ESO35s1 * LNdotS1 + params->ESO35s2 * LNdotS2;
---
>            Fspin7 += params->F7S1O*LNhdotS1 + params->F7S1O*LNhdotS2;
2310c2465,2470
<             Fspin3 += params->FSO3s1* LNdotS1 + params->FSO3s2* LNdotS2;
---
>             Fspin6 += params->F6S1O* LNhdotS1 + params->F6S2O* LNhdotS2
> 	      + params->F6S1S2*S1dotS2 + params->F6S1OS2O*LNhdotS1*LNhdotS2
> 	      + (params->F6S1S1 + params->F6QMS1S1)*S1sq
> 	      + (params->F6S2S2 + params->F6QMS2S2)*S2sq
> 	      + (params->F6S1OS1O + params->F6QMS1OS1O) * LNhdotS1*LNhdotS1
> 	      + (params->F6S2OS2O + params->F6QMS2OS2O) * LNhdotS2*LNhdotS2;
2316,2317c2476
<             Fspin25 += params->FSO25s1*LNdotS1+ params->FSO25s2*LNdotS2;
< 	    Espin25 += params->ESO25s1 * LNdotS1 + params->ESO25s2 * LNdotS2;
---
>             Fspin5 += params->F5S1O*LNhdotS1 + params->F5S2O*LNhdotS2;
2320,2321c2479
<             S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
<             Fspin2 += params->FSS2 * (247.*S1dotS2 - 721.*LNdotS1 * LNdotS2);
---
>             Fspin4 += params->F4S1S2*S1dotS2 + params->F4S1OS2O*LNhdotS1 * LNhdotS2;
2324,2348c2482,2485
<             S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
<             Espin2 += params->ESS2  * S1dotS2 + params->ESSO2 * LNdotS1 * LNdotS2;
< 	    S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
<             S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
<             Espin2 += params->EQM2S1 * S1sq
<                     + params->EQM2S2 * S2sq
<                     + params->EQM2S1L * LNdotS1 * LNdotS1
<                     + params->EQM2S2L * LNdotS2 * LNdotS2;
< 	    Fspin2 += params->FQM2S1 * S1sq
<                     + params->FQM2S2 * S2sq
<                     + params->FQM2S1L * LNdotS1 * LNdotS1
<                     + params->FQM2S2L * LNdotS2 * LNdotS2
<                     + params-> FSSselfS1 * S1sq
<                     + params->FSSselfS2 * S2sq
<                     + params->FSSselfS1L * LNdotS1 * LNdotS1
<                     + params->FSSselfS2L * LNdotS2 * LNdotS2;
< 
<            // dEdvspin2 += params->dEdvQM2S1 * S1sq
<              //       + params->dEdvQM2S2 * S2sq
<              //       + params->dEdvQM2S1L * LNdotS1 * LNdotS1
<             //        + params->dEdvQM2S2L * LNdotS2 * LNdotS2;
<                    // + params->dEdvSSselfS1 * S1sq
<                    // + params->dEdvSSselfS2 * S2sq
<                    // + params->dEdvSSselfS1L * LNdotS1 * LNdotS1
<                    // + params->dEdvSSselfS2L * LNdotS2 * LNdotS2;
---
>             Fspin4 += (params->F4S1S1 + params->F4QMS1S1) * S1sq
> 	      + (params->F4S2S2 + params->F4QMS2S2) * S2sq
> 	      + (params->F4S1OS1O + params->F4QMS1OS1O)* LNhdotS1 * LNhdotS1
> 	      + (params->F4S2OS2O + params->F4QMS2OS2O)* LNhdotS2 * LNhdotS2;
2351,2353c2488
<             Fspin15 = params->FSO15s1*LNdotS1 + params->FSO15s2*LNdotS2;
< 	   // dEdvspin15 = params->dEdvSO15s1*LNdotS1 + params->dEdvSO15s2*LNdotS2;
< 	   Espin15 += params->ESO15s1 * LNdotS1 + params->ESO15s2 * LNdotS2;
---
>             Fspin3 = params->F3S1O*LNhdotS1 + params->F3S2O*LNhdotS2;
2365,2379c2500
<     domega  =-3.0* (params->Fnewt/params->dEdvnewt) * v11 *(((( 1. + v * v * (  params->Fcoeff[2]
<             + v * (  (params->Fcoeff[3]+ Fspin15 )
<             + v * (  (params->Fcoeff[4] + Fspin2 )
<             + v * (  (params->Fcoeff[5] + Fspin25)
<             + v * (  (params->Fcoeff[6] + (params->Flogcoeff*log(v)) + Fspin3 )
<             + v * (  (params->Fcoeff[7] + Fspin35)+ v * v * v * (  params->Ftidal5pn
<                         + v * v * ( params->Ftidal6pn ) )
<                          )))))))))/ ( 2. + v * v * ( 4. * params->Ecoeff[2]
<             + v * (( 5. * (params->Ecoeff[3] +  Espin15 ))
<             + v * (( 6. * (params->Ecoeff[4] +  Espin2 ))
<             + v * ((7. * (params->Ecoeff[5] +  Espin25 ))
<             + v * (( 8. * (params->Ecoeff[6] ))
<             + v * ( (9. * (params->Ecoeff[7] + Espin35 ))+ v * v * v * (( 12. * params->Etidal5pn)
<                         + v * v * ( 14. * params->Etidal6pn ) )
<                          ))))))));
---
>     XLALSimInspiralSetEnergyPNTerms(&Espin3,&Espin4,&Espin5,&Espin6,&Espin7,params,LNhdotS1,LNhdotS2,S1sq,S2sq,S1dotS2);
2380a2502,2519
>     domega  =-6.0* (params->Fnewt/params->dEdvnewt) * v11 *
>       (((( 1. + v * v * (  params->Fcoeff[2]
> 	    + v * (  (params->Fcoeff[3] + Fspin3 )
>             + v * (  (params->Fcoeff[4] + Fspin4 )
>             + v * (  (params->Fcoeff[5] + Fspin5)
>             + v * (  (params->Fcoeff[6] + (params->Flogcoeff*log(v)) + Fspin6 )
>             + v * (  (params->Fcoeff[7] + Fspin7)
>             + v * v * v * (  params->Ftidal10
>                           + v * v * ( params->Ftidal12 ) ) )))))))))/
>            ( 2. + v * v * ( 4. * params->Ecoeff[2]
>             + v * (( 5. * (params->Ecoeff[3] + Espin3 ))
>             + v * (( 6. * (params->Ecoeff[4] + Espin4 ))
>             + v * (( 7. * (params->Ecoeff[5] + Espin5 ))
>             + v * (( 8. * (params->Ecoeff[6] + Espin6 ))
>             + v * ( (9. * (params->Ecoeff[7] + Espin7 ))
>             + v * v * v * (( 12. * params->Etidal10)
>                         + v * v * ( 14. * params->Etidal12 ) )
>                   ))))))));
2382,2462c2521
<     /*
<      * dLN
<      *
<      * \f$d \hat{L_N}/d \hat{t} = M * d\hat{L_N} / dt = \Omega_L x \hat{L_N}\f$
<      * This is Eq. (10) of gr-qc/0405090 ( times M b/c we use \f$\hat{t}\f$)
<      */
<     omega2 = omega * omega;
<     /* \Omega_L vector */
<     OmegaLx = omega2 * (params->LNhatSO15s1 * S1x + params->LNhatSO15s2 * S2x)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1x + LNdotS1 * S2x);
<     OmegaLy = omega2 * (params->LNhatSO15s1 * S1y + params->LNhatSO15s2 * S2y)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1y + LNdotS1 * S2y);
<     OmegaLz = omega2 * (params->LNhatSO15s1 * S1z + params->LNhatSO15s2 * S2z)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1z + LNdotS1 * S2z);
< 
<     /* Take cross product of \Omega_L with \hat{L_N} */
<     dLNhx = (-OmegaLz*LNhy + OmegaLy*LNhz);
<     dLNhy = (-OmegaLx*LNhz + OmegaLz*LNhx);
<     dLNhz = (-OmegaLy*LNhx + OmegaLx*LNhy);
< 
<     /*
<      * dE1
<      *
<      * d E_1 / d \hat{t} = M * d E_1 / dt
<      * Computed from \Omega_L and \hat{L_N} with Eq. (15)-(16) of gr-qc/0310034
<      */
<     OmegaLdotLN = OmegaLx * LNhx + OmegaLy * LNhy + OmegaLz * LNhz;
<     /* \Omega_E vector */
<     OmegaEx = OmegaLx - OmegaLdotLN * LNhx;
<     OmegaEy = OmegaLy - OmegaLdotLN * LNhy;
<     OmegaEz = OmegaLz - OmegaLdotLN * LNhz;
< 
<     /* Take cross product of \Omega_E with E_1 */
<     dE1x = (-OmegaEz*E1y + OmegaEy*E1z);
<     dE1y = (-OmegaEx*E1z + OmegaEz*E1x);
<     dE1z = (-OmegaEy*E1x + OmegaEx*E1y);
< 
<     /*
<      * dS1
<      *
<      * d S_1 / d \hat{t} = M * d S_1 / dt = \Omega_{S1} x S_1
<      * This is Eq. (8) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S1} vector */
<     omega2by2 = omega2 * 0.5;
<     threeLNdotS2 = 3. * LNdotS2;
<     v5etaLNhatSO15s1 = v5 * params->eta * params->LNhatSO15s1;
<     OmegaSx = v5etaLNhatSO15s1 * LNhx
<             + omega2by2 * (S2x - threeLNdotS2 * LNhx);
<     OmegaSy = v5etaLNhatSO15s1 * LNhy
<             + omega2by2 * (S2y - threeLNdotS2 * LNhy);
<     OmegaSz = v5etaLNhatSO15s1 * LNhz
<             + omega2by2 * (S2z - threeLNdotS2 * LNhz);
< 
<     /* Take cross product of \Omega_{S1} with S_1 */
<     dS1x = (-OmegaSz*S1y + OmegaSy*S1z);
<     dS1y = (-OmegaSx*S1z + OmegaSz*S1x);
<     dS1z = (-OmegaSy*S1x + OmegaSx*S1y);
< 
<     /*
<      * dS2
<      *
<      * d S_2 / d \hat{t} = M * d S_2 / dt = \Omega_{S2} x S_2
<      * This is Eq. (9) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S2} vector */
<     threeLNdotS1 = 3. * LNdotS1;
<     v5etaLNhatSO15s2 = v5 * params->eta * params->LNhatSO15s2;
<     OmegaSx = v5etaLNhatSO15s2 * LNhx
<             + omega2by2 * (S1x - threeLNdotS1 * LNhx);
<     OmegaSy = v5etaLNhatSO15s2 * LNhy
<             + omega2by2 * (S1y - threeLNdotS1 * LNhy);
<     OmegaSz = v5etaLNhatSO15s2 * LNhz
<             + omega2by2 * (S1z - threeLNdotS1 * LNhz);
< 
<     /* Take cross product of \Omega_{S2} with S_2 */
<     dS2x = (-OmegaSz*S2y + OmegaSy*S2z);
<     dS2y = (-OmegaSx*S2z + OmegaSz*S2x);
<     dS2z = (-OmegaSy*S2x + OmegaSx*S2y);
---
>     XLALSimInspiralSpinDerivatives(&dLNhx,&dLNhy,&dLNhz,&dE1x,&dE1y,&dE1z,&dS1x,&dS1y,&dS1z,&dS2x,&dS2y,&dS2z,&dphiExtra,v,LNhx,LNhy,LNhz,E1x,E1y,E1z,S1x,S1y,S1z,S2x,S2y,S2z,LNhdotS1,LNhdotS2,params);
2465d2523
<     ds = omega;
2467c2525
<     dvalues[0]    = ds   ; dvalues[1]     = domega;
---
>     dvalues[0]    = omega+dphiExtra;    dvalues[1]     = domega;
2497c2555
<     REAL8 omega, ds, domega, dLNhx, dLNhy, dLNhz;
---
>     REAL8 omega, domega, dLNhx, dLNhy, dLNhz;
2498a2557
>     REAL8 dphiExtra;
2501,2506c2560,2562
<     REAL8 v, v2, v3, v4, v5, v7, v11, omega2, omega2by2;
<     REAL8 LNdotS1, LNdotS2, threeLNdotS1, threeLNdotS2, S1dotS2, S1sq, S2sq;
<     REAL8 v5etaLNhatSO15s1, v5etaLNhatSO15s2;
<     REAL8 OmegaLx, OmegaLy, OmegaLz, OmegaLdotLN;
<     REAL8 OmegaEx, OmegaEy, OmegaEz, OmegaSx, OmegaSy, OmegaSz;
<     REAL8 wspin15 = 0., wspin2 = 0., wspin25 = 0., wspin3 = 0., wspin35 = 0.;
---
>     REAL8 v,v11;
>     REAL8 LNhdotS1, LNhdotS2, S1dotS2, S1sq, S2sq;
>     REAL8 wspin3 = 0., wspin4 = 0., wspin5 = 0., wspin6 = 0., wspin7 = 0.;
2512d2567
<     // UNUSED!!: s    = values[0] ;
2525,2526c2580
<     v2  = v * v; v3 = v2 * v; v4 = v3 * v;
<     v5 = v * v4; v7 = v4 * v3; v11 = v7 * v4;
---
>     v11=omega*omega*omega*v*v;
2528,2529c2582,2583
<     LNdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
<     LNdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
---
>     LNhdotS1 = (LNhx*S1x + LNhy*S1y + LNhz*S1z);
>     LNhdotS2 = (LNhx*S2x + LNhy*S2y + LNhz*S2z);
2530a2585,2586
>     S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
>     S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
2555c2611
<             wspin35 = params->wdotSO35s1*LNdotS1 + params->wdotSO35s2*LNdotS2;
---
>             wspin7 = params->wdot7S1O*LNhdotS1 + params->wdot7S2O*LNhdotS2;
2561c2617,2622
<             wspin3 = params->wdotSO3s1 * LNdotS1 + params->wdotSO3s2 * LNdotS2;
---
>             wspin6 = params->wdot6S1O * LNhdotS1 + params->wdot6S2O * LNhdotS2
>                     + params->wdot6S1OS2O*LNhdotS1*LNhdotS2 + params->wdot6S1S2*S1dotS2
>                     + (params->wdot6S1S1+params->wdot6QMS1S1)*S1sq
> 	            + (params->wdot6S2S2+params->wdot6QMS2S2)*S2sq
>                     + (params->wdot6S1OS1O+params->wdot6QMS1OS1O)*LNhdotS1*LNhdotS1
>                     + (params->wdot6S2OS2O+params->wdot6QMS2OS2O)*LNhdotS2*LNhdotS2;
2567c2628
<             wspin25 = params->wdotSO25s1*LNdotS1 + params->wdotSO25s2*LNdotS2;
---
>             wspin5 = params->wdot5S1O*LNhdotS1 + params->wdot5S2O*LNhdotS2;
2570,2571c2631
<             S1dotS2 = (S1x*S2x + S1y*S2y + S1z*S2z);
<             wspin2 = params->wdotSS2 * (247.*S1dotS2 - 721.*LNdotS1 * LNdotS2);
---
>             wspin4 = params->wdot4S1S2 *S1dotS2 + params->wdot4S1OS2O *LNhdotS1 * LNhdotS2;
2575,2584c2635,2638
<             S1sq = (S1x*S1x + S1y*S1y + S1z*S1z);
<             S2sq = (S2x*S2x + S2y*S2y + S2z*S2z);
<             wspin2 += params->wdotQM2S1 * S1sq
<                     + params->wdotQM2S2 * S2sq
<                     + params->wdotQM2S1L * LNdotS1 * LNdotS1
<                     + params->wdotQM2S2L * LNdotS2 * LNdotS2
<                     + params->wdotSSselfS1 * S1sq
<                     + params->wdotSSselfS2 * S2sq
<                     + params->wdotSSselfS1L * LNdotS1 * LNdotS1
<                     + params->wdotSSselfS2L * LNdotS2 * LNdotS2;
---
>             wspin4 += (params->wdot4S1S1 + params->wdot4QMS1S1) * S1sq
> 	      + (params->wdot4S2S2 + params->wdot4QMS2S2) * S2sq
> 	      + (params->wdot4S1S1 + params->wdot4QMS1OS1O) * LNhdotS1 * LNhdotS1
> 	      + (params->wdot4S2S2 + params->wdot4QMS2OS2O) * LNhdotS2 * LNhdotS2;
2587c2641
<             wspin15 = params->wdotSO15s1*LNdotS1 + params->wdotSO15s2*LNdotS2;
---
>             wspin3 = params->wdot3S1O*LNhdotS1 + params->wdot3S2O*LNhdotS2;
2602,2669c2656,2663
<             + v * ( params->wdotcoeff[3] + wspin15
<             + v * ( params->wdotcoeff[4] + wspin2
<             + v * ( params->wdotcoeff[5] + wspin25
<             + v * ( params->wdotcoeff[6] + wspin3
<                     + params->wdotlogcoeff * log(omega)
<             + v * ( params->wdotcoeff[7] + wspin35
<             + v3 * ( params->wdottidal5pn
<             + v2 * ( params->wdottidal6pn ) ) ) ) ) ) ) ) ) );
< 
<     /*
<      * dLN
<      *
<      * \f$d \hat{L_N}/d \hat{t} = M * d\hat{L_N} / dt = \Omega_L x \hat{L_N}\f$
<      * This is Eq. (10) of gr-qc/0405090 ( times M b/c we use \f$\hat{t}\f$)
<      */
<     omega2 = omega * omega;
<     /* \Omega_L vector */
<     OmegaLx = omega2 * (params->LNhatSO15s1 * S1x + params->LNhatSO15s2 * S2x)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1x + LNdotS1 * S2x);
<     OmegaLy = omega2 * (params->LNhatSO15s1 * S1y + params->LNhatSO15s2 * S2y)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1y + LNdotS1 * S2y);
<     OmegaLz = omega2 * (params->LNhatSO15s1 * S1z + params->LNhatSO15s2 * S2z)
<             + v7 * params->LNhatSS2 * (LNdotS2 * S1z + LNdotS1 * S2z);
< 
<     /* Take cross product of \Omega_L with \hat{L_N} */
<     dLNhx = (-OmegaLz*LNhy + OmegaLy*LNhz);
<     dLNhy = (-OmegaLx*LNhz + OmegaLz*LNhx);
<     dLNhz = (-OmegaLy*LNhx + OmegaLx*LNhy);
< 
<     /*
<      * dE1
<      *
<      * d E_1 / d \hat{t} = M * d E_1 / dt
<      * Computed from \Omega_L and \hat{L_N} with Eq. (15)-(16) of gr-qc/0310034
<      */
<     OmegaLdotLN = OmegaLx * LNhx + OmegaLy * LNhy + OmegaLz * LNhz;
<     /* \Omega_E vector */
<     OmegaEx = OmegaLx - OmegaLdotLN * LNhx;
<     OmegaEy = OmegaLy - OmegaLdotLN * LNhy;
<     OmegaEz = OmegaLz - OmegaLdotLN * LNhz;
< 
<     /* Take cross product of \Omega_E with E_1 */
<     dE1x = (-OmegaEz*E1y + OmegaEy*E1z);
<     dE1y = (-OmegaEx*E1z + OmegaEz*E1x);
<     dE1z = (-OmegaEy*E1x + OmegaEx*E1y);
< 
<     /*
<      * dS1
<      *
<      * d S_1 / d \hat{t} = M * d S_1 / dt = \Omega_{S1} x S_1
<      * This is Eq. (8) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S1} vector */
<     omega2by2 = omega2 * 0.5;
<     threeLNdotS2 = 3. * LNdotS2;
<     v5etaLNhatSO15s1 = v5 * params->eta * params->LNhatSO15s1;
<     OmegaSx = v5etaLNhatSO15s1 * LNhx
<             + omega2by2 * (S2x - threeLNdotS2 * LNhx);
<     OmegaSy = v5etaLNhatSO15s1 * LNhy
<             + omega2by2 * (S2y - threeLNdotS2 * LNhy);
<     OmegaSz = v5etaLNhatSO15s1 * LNhz
<             + omega2by2 * (S2z - threeLNdotS2 * LNhz);
< 
<     /* Take cross product of \Omega_{S1} with S_1 */
<     dS1x = (-OmegaSz*S1y + OmegaSy*S1z);
<     dS1y = (-OmegaSx*S1z + OmegaSz*S1x);
<     dS1z = (-OmegaSy*S1x + OmegaSx*S1y);
---
>             + v * ( params->wdotcoeff[3] + wspin3
>             + v * ( params->wdotcoeff[4] + wspin4
>             + v * ( params->wdotcoeff[5] + wspin5
>             + v * ( params->wdotcoeff[6] + wspin6
>                     + params->wdotlogcoeff * log(v)
>             + v * ( params->wdotcoeff[7] + wspin7
>             + omega * ( params->wdottidal10
>             + v*v * ( params->wdottidal12 ) ) ) ) ) ) ) ) ) );
2671,2691c2665
<     /*
<      * dS2
<      *
<      * d S_2 / d \hat{t} = M * d S_2 / dt = \Omega_{S2} x S_2
<      * This is Eq. (9) of gr-qc/0405090.
<      * However, that paper uses spin variables which are M^2 times our spins
<      */
<     /* \Omega_{S2} vector */
<     threeLNdotS1 = 3. * LNdotS1;
<     v5etaLNhatSO15s2 = v5 * params->eta * params->LNhatSO15s2;
<     OmegaSx = v5etaLNhatSO15s2 * LNhx
<             + omega2by2 * (S1x - threeLNdotS1 * LNhx);
<     OmegaSy = v5etaLNhatSO15s2 * LNhy
<             + omega2by2 * (S1y - threeLNdotS1 * LNhy);
<     OmegaSz = v5etaLNhatSO15s2 * LNhz
<             + omega2by2 * (S1z - threeLNdotS1 * LNhz);
< 
<     /* Take cross product of \Omega_{S2} with S_2 */
<     dS2x = (-OmegaSz*S2y + OmegaSy*S2z);
<     dS2y = (-OmegaSx*S2z + OmegaSz*S2x);
<     dS2z = (-OmegaSy*S2x + OmegaSx*S2y);
---
>     XLALSimInspiralSpinDerivatives(&dLNhx,&dLNhy,&dLNhz,&dE1x,&dE1y,&dE1z,&dS1x,&dS1y,&dS1z,&dS2x,&dS2y,&dS2z,&dphiExtra,v,LNhx,LNhy,LNhz,E1x,E1y,E1z,S1x,S1y,S1z,S2x,S2y,S2z,LNhdotS1,LNhdotS2,params);
2694,2696c2668
<     ds = omega;
< 
<     dvalues[0]    = ds   ; dvalues[1]     = domega;
---
>     dvalues[0]    = omega+dphiExtra; dvalues[1]     = domega;
2724c2696
< /*
---
> /**
2725a2698
>  * REVIEWED completed on git hash ...
2733,2734c2706,2707
< 	REAL8 m1,                       /**< mass of companion 1 (kg) */
< 	REAL8 m2,                       /**< mass of companion 2 (kg) */
---
> 	REAL8 m1_SI,                    /**< mass of companion 1 (kg) */
> 	REAL8 m2_SI,                    /**< mass of companion 2 (kg) */
2767c2740
<     REAL8 fISCO = pow(LAL_C_SI,3) / (pow(6.,3./2.)*LAL_PI*(m1+m2)*LAL_G_SI);
---
>     REAL8 fISCO = 1./(pow(6.,3./2.)*LAL_PI*(m1_SI+m2_SI)/LAL_MSUN_SI*LAL_MTSUN_SI);
2796,2798c2769,2771
<                 &S1x, &S1y, &S1z, &S2x, &S2y, &S2z, 
<                 &LNhatx, &LNhaty, &LNhatz, &E1x, &E1y, &E1z, 
<                 deltaT, m1, m2, fS, fE, s1x, s1y, s1z, s2x, s2y, s2z, 
---
>                 &S1x, &S1y, &S1z, &S2x, &S2y, &S2z,
>                 &LNhatx, &LNhaty, &LNhatz, &E1x, &E1y, &E1z,
>                 deltaT, m1_SI, m2_SI, fS, fE, s1x, s1y, s1z, s2x, s2y, s2z,
2818,2820c2791,2793
<                 &S1x, &S1y, &S1z, &S2x, &S2y, &S2z, 
<                 &LNhatx, &LNhaty, &LNhatz, &E1x, &E1y, &E1z, 
<                 deltaT, m1, m2, fS, fE, s1x, s1y, s1z, s2x, s2y, s2z, 
---
>                 &S1x, &S1y, &S1z, &S2x, &S2y, &S2z,
>                 &LNhatx, &LNhaty, &LNhatz, &E1x, &E1y, &E1z,
>                 deltaT, m1_SI, m2_SI, fS, fE, s1x, s1y, s1z, s2x, s2y, s2z,
2844c2817
<                 &S1x1, &S1y1, &S1z1, &S2x1, &S2y1, &S2z1, 
---
>                 &S1x1, &S1y1, &S1z1, &S2x1, &S2y1, &S2z1,
2846c2819
<                 deltaT, m1, m2, fS, fE, s1x, s1y, s1z, s2x, s2y,
---
>                 deltaT, m1_SI, m2_SI, fS, fE, s1x, s1y, s1z, s2x, s2y,
2849c2822
<         
---
> 
2861c2834
<                 &S1x2, &S1y2, &S1z2, &S2x2, &S2y2, &S2z2, 
---
>                 &S1x2, &S1y2, &S1z2, &S2x2, &S2y2, &S2z2,
2863c2836
<                 deltaT, m1, m2, fS, fE, s1x, s1y, s1z, s2x, s2y,
---
>                 deltaT, m1_SI, m2_SI, fS, fE, s1x, s1y, s1z, s2x, s2y,
2866c2839
<         
---
> 
2891d2863
< 
2894,2895c2866,2867
<             V, Phi, S1x, S1y, S1z, S2x, S2y, S2z, LNhatx, LNhaty, LNhatz, 
<             E1x, E1y, E1z, m1, m2, r, v0, amplitudeO);
---
>             V, Phi, S1x, S1y, S1z, S2x, S2y, S2z, LNhatx, LNhaty, LNhatz,
>             E1x, E1y, E1z, m1_SI, m2_SI, r, v0, amplitudeO);
2918c2890
< /*
---
> /**
2939a2912,2913
>  *
>  * REVIEW completed on git hash ...
2976d2949
< //     int sgn, offset;
2978d2950
< //     LIGOTimeGPS tStart = LIGOTIMEGPSZERO;
2994,2999d2965
< //     /* Set sign of time step according to direction of integration */
< //     if( fEnd < fStart && fEnd != 0. )
< //         sgn = -1;
< //     else
< //         sgn = 1;
< 
3035,3037d3000
<         //XLALPrintError("XLAL Error - %s: SpinTaylorT1 not implemented yet!\n",
<         //        __func__);
<         //XLAL_ERROR(XLAL_EINVAL);
3046,3047c3009,3010
<     m1sec = m1 * LAL_G_SI / pow(LAL_C_SI, 3.0);
<     m2sec = m2 * LAL_G_SI / pow(LAL_C_SI, 3.0);
---
>     m1sec = m1 /LAL_MSUN_SI*LAL_MTSUN_SI;
>     m2sec = m2 /LAL_MSUN_SI*LAL_MTSUN_SI;
3099,3101d3061
<         //XLALPrintError("XLAL Error - %s: SpinTaylorT1 not implemented yet!\n",
<           //      __func__);
<         //XLAL_ERROR(XLAL_EINVAL);
3120d3079
<     //len = XLALAdaptiveRungeKutta4Hermite(integrator, (void *) &params, yinit,
3138,3139c3097,3098
<         __func__, intreturn, m1 * pow(LAL_C_SI, 3.0) / LAL_G_SI / LAL_MSUN_SI,
<         m2 * pow(LAL_C_SI, 3.0) / LAL_G_SI / LAL_MSUN_SI, s1x, s1y, s1z, s2x,
---
>         __func__, intreturn, m1 / LAL_MSUN_SI * LAL_MTSUN_SI,
>         m2 / LAL_MSUN_SI * LAL_MTSUN_SI, s1x, s1y, s1z, s2x,
3161d3119
< 
3181d3138
<  * x, y, z components of E1 (unit vector in the initial orbital plane)
3200a3158,3159
>  *
>  * !!!UNREVIEWED!!!
3202c3161
< int XLALSimInspiralTransformPrecessingInitialConditions(
---
> int XLALSimInspiralTransformPrecessingObsoleteInitialConditions(
3341a3301
> 
3361d3320
<  * x, y, z components of E1 (unit vector in the initial orbital plane)
3367,3368c3326,3328
<  * J = L_N + S1 + S2
<  * where L_N is the Newtonian orbital angular momentum. In fact, there are
---
>  * J = L_N(1+l1PN) + S1 + S2
>  * where L_N is the Newtonian orbital angular momentum and l1PN its
>  * relative 1PN corrections. In fact, there are
3370,3372c3330,3333
<  * in this function. This is done so the function does not need to know about
<  * the PN order of the system and to avoid subtleties with spin-orbit
<  * contributions to L. Also, it is believed that the difference in Jhat
---
>  * in this function. This is done so to avoid complications with spin-orbit
>  * contributions to L, which would require the full knowledge fo the orbital motion,
>  * not just the evolution of L (see e.g.  eq.2.9c of arXiv:gr-qc/9506022).
>  * Also, it is believed that the difference in Jhat
3376a3338,3339
>  *
>  * Reviewed completed on git hash ...
3405,3407c3368,3370
< 	REAL8 m1, m2, v0, theta0, phi0, Jnorm, tmp1, tmp2;
< 	REAL8 Jhatx, Jhaty, Jhatz, LNhx, LNhy, LNhz, Jx, Jy, Jz, LNmag;
< 	REAL8 s1hatx, s1haty, s1hatz, s2hatx, s2haty, s2hatz;
---
> 	REAL8 m1, m2, eta, v0, theta0, phi0, Jnorm, tmp1, tmp2;
> 	REAL8 Jhatx, Jhaty, Jhatz, LNhx, LNhy, LNhz, Jx, Jy, Jz, Lmag;
> 	REAL8 s1hatx,s1haty,s1hatz,s2hatx,s2haty,s2hatz;
3417a3381,3383
> 	/* Spins are given wrt to L, but still we cannot fill the spin as we do not know
> 	 * what will be the relative orientation of L and N.
> 	 */
3427a3394
> 	eta=m1*m2/(m1+m2)/(m1+m2);
3429c3396
< 	v0 = pow( (m1+m2) * LAL_MTSUN_SI *LAL_PI * fRef, 1./3.);
---
> 	v0 = cbrt( (m1+m2) * LAL_MTSUN_SI *LAL_PI * fRef );
3432c3399
< 	LNmag = m1 * m2 / v0;
---
> 	Lmag = XLALSimInspiralLN(m1+m2,eta,v0)*(1+v0*v0*XLALSimInspiralL_2PN(eta));
3441c3408
< 	Jz = LNmag * LNhz + s1z + s2z;
---
> 	Jz = Lmag * LNhz + s1z + s2z;
3455d3421
< 	ROTATEZ(-phi0, Jhatx, Jhaty, Jhatz);
3461,3463c3427,3428
< 	ROTATEY(-theta0, s1hatx, s1haty, s1hatz);
< 	ROTATEY(-theta0, s2hatx, s2haty, s2hatz);
< 	ROTATEY(-theta0, Jhatx, Jhaty, Jhatz);
---
> 	ROTATEZ(-theta0, s1hatx, s1haty, s1hatz);
> 	ROTATEZ(-theta0, s2hatx, s2haty, s2hatz);
3472d3436
< 	ROTATEZ(phiJL - LAL_PI, Jhatx, Jhaty, Jhatz);
3488c3452
< 	REAL8 phiLJ   = atan2(LNhy, LNhx);
---
> 	REAL8 phiL    = atan2(LNhy, LNhx);
3490,3496c3454,3456
< 	/* As a check, one can rotateL too and verify
<            the incl angle obtained above.
< 	  */
< 	ROTATEZ(-phiLJ, Nx, Ny, Nz);
< 	ROTATEZ(-phiLJ, s1hatx, s1haty, s1hatz);
< 	ROTATEZ(-phiLJ, s2hatx, s2haty, s2hatz);
< 	ROTATEZ(-phiLJ, LNhx, LNhy, LNhz);
---
> 	ROTATEZ(-phiL, Nx, Ny, Nz);
> 	ROTATEZ(-phiL, s1hatx, s1haty, s1hatz);
> 	ROTATEZ(-phiL, s2hatx, s2haty, s2hatz);
3500d3459
< 	ROTATEY(-thetaLJ, LNhx, LNhy, LNhz);
3508,3509d3466
< 	ROTATEZ(-phiN, LNhx, LNhy, LNhz);
< 	ROTATEZ(-phiN, Nx, Ny, LNz);
3511c3468,3476
< 	//One can make the following checks:
---
> 	/* Set pointers to rotated spin vectors */
> 	*S1x = s1hatx*chi1;
> 	*S1y = s1haty*chi1;
> 	*S1z = s1hatz*chi1;
> 	*S2x = s2hatx*chi2;
> 	*S2y = s2haty*chi2;
> 	*S2z = s2hatz*chi2;
> 
> 	//Uncomment the following lines for a check of the rotation
3512a3478,3486
> 	ROTATEZ(-phiL,    LNhx, LNhy, LNhz);
> 	ROTATEY(-thetaLJ, LNhx, LNhy, LNhz);
> 	ROTATEZ(-phiN,    LNhx, LNhy, LNhz);
> 	ROTATEZ(-phiN,    Nx, Ny, LNz);
> 	ROTATEZ(-phi0, Jhatx, Jhaty, Jhatz);
> 	ROTATEY(-theta0, Jhatx, Jhaty, Jhatz);
> 	ROTATEZ(phiJL - LAL_PI, Jhatx, Jhaty, Jhatz);
> 	ROTATEZ(-phiL, Jhatx, Jhaty, Jhatz);
> 	ROTATEY(-thetaLJ, Jhatx, Jhaty, Jhatz);
3513a3488
> 	printf("       %12.4e  %12.4e  %12.4e\n",0.,0.,1.);
3515,3534c3490,3494
< 	printf("cos LN = %12.4e vs. %12.4e\n",cos(*incl),LNhx*Nx+LNhy*Ny+LNhz*Nz);
< 	printf("S1L  %12.4e %12.4e\n",cos(theta1),s1hatz);
< 	printf("S2L  %12.4e %12.4e\n",cos(theta2),s2hatz);
< 	printf("S1S2 %12.4e %12.4e\n",sin(theta1)*sin(theta2)*cos(phi12)+cos(theta1)*cos(theta2),s1hatx*s2hatx+s1haty*s2haty+s1hatz*s2hatz);*/
< 
< 	/* Multiply spin unit vectors by chi magnitude (but NOT m_i^2) */
< 	s1hatx *= chi1;
< 	s1haty *= chi1;
< 	s1hatz *= chi1;
< 	s2hatx *= chi2;
< 	s2haty *= chi2;
< 	s2hatz *= chi2;
< 
< 	/* Set pointers to rotated spin vectors */
< 	*S1x = s1hatx;
< 	*S1y = s1haty;
< 	*S1z = s1hatz;
< 	*S2x = s2hatx;
< 	*S2y = s2haty;
< 	*S2z = s2hatz;
---
> 	printf("       %12.4e  %12.4e  %12.4e\n",-sin(*incl),0.,cos(*incl));
> 	printf("J.Lhat  i: %12.4e f: %12.4e\n",Jz,Jnorm*Jhatz);
> 	printf("S1.L    i: %12.4e f: %12.4e\n",chi1*cos(theta1),*S1z);
> 	printf("S2.L    i: %12.4e f: %12.4e\n",chi2*cos(theta2),*S2z);
> 	printf("S1.S2   i: %12.4e f: %12.4e\n",chi1*chi2*(sin(theta1)*sin(theta2)*cos(phi12)+cos(theta1)*cos(theta2)),(*S1x)*(*S2x)+(*S1y)*(*S2y)+(*S1z)*(*S2z));*/
3545,3547c3505,3507
<  * * reference L for axisChoice    = LAL_SIM_INSPIRAL_FRAME_AXIS_TOTAL_J
<  * * total J for axisChoice         = LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L
<  * * view direction for axisChoice = LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW (default)
---
>  * * total J for axisChoice        = LAL_SIM_INSPIRAL_FRAME_AXIS_TOTAL_J
>  * * reference L for axisChoice    = LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L (default)
>  * * view direction for axisChoice = LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW
3550,3551c3510,3511
<  * * L and N (Lx \f$\propto sin(inc)\f$, Ly=0) for axisChoice = LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L
<  *                                                              LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW (default)
---
>  * * L and N (Nx \f$\propto sin(inc)\f$, Ly=0) for axisChoice = LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L (default)
>  * * L and N (Lx \f$\propto sin(inc)\f$, Ly=0) for axisChoice = LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW
3557a3518
>  * as required by precessing waveforms routines.
3560,3563c3521,3525
<  * J = L_N + S1 + S2
<  * where L_N is the Newtonian orbital angular momentum. In fact, there are
<  * PN corrections to L which contribute to J that are NOT ACCOUNTED FOR
<  * in this function.
---
>  * J = L_N(1+L_1PN) + S1 + S2
>  * where L_N(1+L_1PN) is the 1PN-corrected orbital angular momentum,
>  * which is parallel to Newtonian angular momentum.
>  * PN corrections to L from 1.5PN order on (wrt to Newtonian value)
>  * are NOT ACCOUNTED FOR in this function.
3583c3545
< 		LALSimInspiralFrameAxis axisChoice  /**< Flag to identify axis wrt which spin components are given. Pass in NULL (or None in python) for default (view) */)
---
> 		LALSimInspiralFrameAxis axisChoice  /**< Flag to identify axis wrt which spin components are given. Pass in NULL (or None in python) for default (OrbitalL) */)
3585,3586c3547,3550
<   REAL8 LNmag=0.;
<   REAL8 LNx,LNy,LNxy2,LNz;
---
>   REAL8 Lmag=0.;
>   REAL8 Lx,Ly,Lxy2,Lz;
>   REAL8 LNhx,LNhy,LNhz,phiLN;
>   REAL8 v0,mass1,mass2,eta;
3587a3552,3557
>   *S1x=S1xIn;
>   *S1y=S1yIn;
>   *S1z=S1zIn;
>   *S2x=S2xIn;
>   *S2y=S2yIn;
>   *S2z=S2zIn;
3589c3559
<   /* FRAME_AXIS_TOTAL_J is used by PhenSpin approximant only,
---
>   /* FRAME_AXIS_TOTAL_J
3591c3561
<    * N=(0,0,1) Jhat=(sin(inclIn),0,cos(inclIn)))
---
>    * J=(0,0,1) N=(-sin(inclIn),0,cos(inclIn)))
3594,3604c3564,3578
<     LNmag= m1/LAL_MSUN_SI*m2/LAL_MSUN_SI / cbrt(LAL_PI*fRef*(m1+m2)/LAL_MSUN_SI*LAL_MTSUN_SI);
<     LNx  = -S1xIn*pow(m1/LAL_MSUN_SI,2)-S2xIn*pow(m2/LAL_MSUN_SI,2);
<     LNy  = -S1yIn*pow(m1/LAL_MSUN_SI,2)-S2yIn*pow(m2/LAL_MSUN_SI,2);
<     LNxy2= LNx*LNx+LNy*LNy;
<     LNz=0.;
<     if (LNmag*LNmag>=LNxy2) {
<       LNz=sqrt(LNmag*LNmag-LNxy2);
<       if ( LNz<(S1zIn*pow(m1/LAL_MSUN_SI,2)+S2zIn*pow(m2/LAL_MSUN_SI,2)) ) {
< 	XLALPrintError("** LALSimIMRPSpinInspiralRD error *** for s1 (%12.4e  %12.4e  %12.4e)\n",S1xIn,S1yIn,S1zIn);
< 	XLALPrintError("                                          s2 (%12.4e  %12.4e  %12.4e)\n",S2xIn,S2yIn,S2zIn);
< 	XLALPrintError(" wrt to J for m: (%12.4e  %12.4e) and v= %12.4e\n",m1/LAL_MSUN_SI,m2/LAL_MSUN_SI,cbrt(LAL_PI*fRef*(m1+m2)/LAL_MSUN_SI*LAL_MTSUN_SI));
---
>     mass1=m1*LAL_MSUN_SI;
>     mass2=m2*LAL_MSUN_SI;
>     eta=mass1*mass2/(mass1+mass2)/(mass1+mass2);
>     v0=cbrt(LAL_PI*fRef*(m1+m2)*LAL_MTSUN_SI);
>     Lmag = XLALSimInspiralLN(mass1+mass2,eta,v0)*(1.+v0*v0*XLALSimInspiralL_2PN(eta));
>     Lx  = -S1xIn*mass1*mass1-S2xIn*mass2*mass2;
>     Ly  = -S1yIn*mass2*mass2-S2yIn*mass2*mass2;
>     Lxy2= Lx*Lx+Ly*Ly;
>     Lz=0.;
>     if (Lmag*Lmag>=Lxy2) {
>       Lz=sqrt(Lmag*Lmag-Lxy2);
>       if ( Lz<(S1zIn*mass1*mass1+S2zIn*mass2*mass2) ) {
> 	XLALPrintError("** XLALSimInspiralInitialConditionsPrecessingApproxs ERROR *** for s1 (%12.4e  %12.4e  %12.4e)\n",S1xIn,S1yIn,S1zIn);
> 	XLALPrintError("                                                                   s2 (%12.4e  %12.4e  %12.4e)\n",S2xIn,S2yIn,S2zIn);
> 	XLALPrintError(" wrt to J for m: (%12.4e  %12.4e) and v= %12.4e\n",mass1,mass2,v0);
3610,3612c3584,3586
<       XLALPrintError("** LALSimIMRPSpinInspiralRD error *** unphysical values of s1 (%12.4e  %12.4e  %12.4e)\n",S1xIn,S1yIn,S1zIn);
<       XLALPrintError("                                                           s2 (%12.4e  %12.4e  %12.4e)\n",S2xIn,S2yIn,S2zIn);
<       XLALPrintError(" wrt to J for m: (%12.4e  %12.4e) and v= %12.4e\n",m1/LAL_MSUN_SI,m2/LAL_MSUN_SI,cbrt(LAL_PI*fRef*(m1+m2)/LAL_MSUN_SI*LAL_MTSUN_SI));
---
>       XLALPrintError("** XLALSimInspiralInitialConditionsPrecessingApproxs ERROR *** unphysical values of s1 (%12.4e  %12.4e  %12.4e)\n",S1xIn,S1yIn,S1zIn);
>       XLALPrintError("                                                                                    s2 (%12.4e  %12.4e  %12.4e)\n",S2xIn,S2yIn,S2zIn);
>       XLALPrintError(" wrt to J for m: (%12.4e  %12.4e) and v= %12.4e\n",mass1,mass2,v0);
3615,3620c3589,3593
<     *S1x=S1xIn;
<     *S1y=S1yIn;
<     *S1z=S1zIn;
<     *S2x=S2xIn;
<     *S2y=S2yIn;
<     *S2z=S2zIn;
---
>     // 1PN corrections to L are collinear with LN
>     // Rotation1: send N to z
>     LNhx=Lx/Lmag;
>     LNhy=Ly/Lmag;
>     LNhz=Lz/Lmag;
3623c3596,3617
<     *inc=acos((-sin(inclIn)*LNx+cos(inclIn)*LNz)/LNmag);
---
>     ROTATEY(inclIn,LNhx,LNhy,LNhz);
>     *inc=acos(LNhz);
>     //Rotation 2: send L into the x-z plane.
>     phiLN=atan2(LNhy,LNhx);
>     ROTATEZ(-phiLN,*S1x,*S1y,*S1z);
>     ROTATEZ(-phiLN,*S2x,*S2y,*S2z);
>     //It follows that in the frame in which N=(0,0,1), LNhat=(sin(inc),0,cos(inc))
>     //For a check uncomment the following lines
>     /*printf(" Check of LAL_SIM_INSPIRAL_FRAME_AXIS_TOTAL_J\n");
>     REAL8 Nx=-sin(inclIn);
>     REAL8 Ny=0.;
>     REAL8 Nz=cos(inclIn);
>     ROTATEY(inclIn,Nx,Ny,Nz);
>     ROTATEZ(-phiLN,Nx,Ny,Nz);
>     ROTATEZ(-phiLN,LNhx,LNhy,LNhz);
>     printf("N:  %12.4e  %12.4e  %12.4e  norm: %12.4e\n",Nx,Ny,Nz,sqrt(Nx*Nx+Ny*Ny+Nz*Nz));
>     printf("     %12.4e  %12.4e  %12.4e\n",0.,0.,1.);
>     printf("LNh: %12.4e  %12.4e  %12.4e  norm: %12.4e\n",LNhx,LNhy,LNhz,sqrt(LNhx*LNhx+LNhy*LNhy+LNhz*LNhz));
>     printf("     %12.4e  %12.4e  %12.4e\n",sin(*inc),0.,cos(*inc));
>     printf("S1.L     %12.4e  %12.4e\n",(*S1x)*LNhx+(*S1y)*LNhy+(*S1z)*LNhz,S1zIn);
>     printf("S2.L     %12.4e  %12.4e\n",(*S2x)*LNhx+(*S2y)*LNhy+(*S2z)*LNhz,S2zIn);
>     printf("S1.S2    %12.4e  %12.4e\n",(*S1x)*(*S2x)+(*S1y)*(*S2y)+(*S1z)*(*S2z),S1xIn*S2xIn+S1yIn*S2yIn+S1zIn*S2zIn);*/
3624a3619
> 
3627c3622
<    * N=(0,0,1) Lhat=(sin(inclIn),0,cos(inclIn)) )
---
>    * N=(0,0,1) LNhat=(sin(inclIn),0,cos(inclIn)) )
3630,3635d3624
<     *S1x=S1xIn;
<     *S1y=S1yIn;
<     *S1z=S1zIn;
<     *S2x=S2xIn;
<     *S2y=S2yIn;
<     *S2z=S2zIn;
3644,3649c3633,3652
<     *S1x=S1xIn*cos(inclIn)+S1zIn*sin(inclIn);
<     *S1y=S1yIn;
<     *S1z=-S1xIn*sin(inclIn)+S1zIn*cos(inclIn);
<     *S2x=S2xIn*cos(inclIn)+S2zIn*sin(inclIn);
<     *S2y=S2yIn;
<     *S2z=-S2xIn*sin(inclIn)+S2zIn*cos(inclIn);
---
>     ROTATEY(inclIn,*S1x,*S1y,*S1z);
>     ROTATEY(inclIn,*S2x,*S2y,*S2z);
>     *inc=inclIn;
>     //For a check uncomment the following lines
>     /*printf(" Check of LAL_SIM_INSPIRAL_FRAME_AXIS_ORBITAL_L\n");
>     REAL8 Nnx=-sin(inclIn);
>     REAL8 Nny=0.;
>     REAL8 Nnz=cos(inclIn);
>     LNhx=0.;
>     LNhy=0.;
>     LNhz=1.;
>     ROTATEY(inclIn,Nnx,Nny,Nnz);
>     ROTATEY(inclIn,LNhx,LNhy,LNhz);
>     printf("N:   %12.4e  %12.4e  %12.4e  norm: %12.4e\n",Nnx,Nny,Nnz,sqrt(Nnx*Nnx+Nny*Nny+Nnz*Nnz));
>     printf("     %12.4e  %12.4e  %12.4e\n",0.,0.,1.);
>     printf("LNh: %12.4e  %12.4e  %12.4e  norm: %12.4e\n",LNhx,LNhy,LNhz,sqrt(LNhx*LNhx+LNhy*LNhy+LNhz*LNhz));
>     printf("     %12.4e  %12.4e  %12.4e\n",sin(*inc),0.,cos(*inc));
>     printf("S1.L     %12.4e  %12.4e\n",(*S1x)*LNhx+(*S1y)*LNhy+(*S1z)*LNhz,S1zIn);
>     printf("S2.L     %12.4e  %12.4e\n",(*S2x)*LNhx+(*S2y)*LNhy+(*S2z)*LNhz,S2zIn);
>     printf("S1.S2    %12.4e  %12.4e\n",(*S1x)*(*S2x)+(*S1y)*(*S2y)+(*S1z)*(*S2z),S1xIn*S2xIn+S1yIn*S2yIn+S1zIn*S2zIn);*/
3673,3677c3676,3683
<  * NOTE: All vectors are given in the so-called "radiation frame",
<  * where the direction of propagation is the z-axis, the principal "+"
<  * polarization axis is the x-axis, and the y-axis is given by the RH rule.
<  * You must give the initial values in this frame, and the time series of the
<  * vector components will also be returned in this frame
---
>  * NOTE: All vectors are given in the frame
>  * where the z-axis is set by the angular momentum at reference frequency,
>  * the x-axis is chosen orthogonal to it, and the y-axis is given by the RH rule.
>  * Initial values must be passed in this frame, and the time series of the
>  * vector components will also be returned in this frame.
>  *
>  * Review completed on git hash ...
>  *
3695,3696c3701,3702
< 	REAL8 m1,              	        /**< mass of companion 1 (kg) */
< 	REAL8 m2,              	        /**< mass of companion 2 (kg) */
---
> 	REAL8 m1_SI,           	        /**< mass of companion 1 (kg) */
> 	REAL8 m2_SI,           	        /**< mass of companion 2 (kg) */
3770c3776
<         XLALSimInspiralSpinTaylorT4Setup(&paramsT4, m1, m2, fStart, fEnd,
---
>         XLALSimInspiralSpinTaylorT4Setup(&paramsT4, m1_SI, m2_SI, fStart, fEnd,
3777c3783
<         XLALSimInspiralSpinTaylorT2Setup(&paramsT2, m1, m2, fStart, fEnd,
---
>         XLALSimInspiralSpinTaylorT2Setup(&paramsT2, m1_SI, m2_SI, fStart, fEnd,
3784c3790
<         XLALSimInspiralSpinTaylorT1Setup(&paramsT1, m1, m2, fStart, fEnd,
---
>         XLALSimInspiralSpinTaylorT1Setup(&paramsT1, m1_SI, m2_SI, fStart, fEnd,
3795,3796c3801,3802
<     m1sec = m1 * LAL_G_SI / pow(LAL_C_SI, 3.0);
<     m2sec = m2 * LAL_G_SI / pow(LAL_C_SI, 3.0);
---
>     m1sec = m1_SI / LAL_MSUN_SI * LAL_MTSUN_SI;
>     m2sec = m2_SI / LAL_MSUN_SI * LAL_MTSUN_SI;
3832d3837
< //fprintf(stdout,"Integrator %s\n","evoked");
3849,3852d3853
< 
<     //    XLALPrintError("XLAL Error - %s: SpinTaylorT1 is getting implemented nw!\n",
<      //           __func__);
<         //XLAL_ERROR(XLAL_EINVAL);
3871d3871
<     //len = XLALAdaptiveRungeKutta4Hermite(integrator, (void *) &params, yinit,
3877d3876
<      // fprintf(stdout,"RKintegrator %s\n","started");
3889c3888
<         XLALPrintWarning("XLAL Warning - %s: integration terminated with code %d.\n Waveform parameters were m1 = %e, m2 = %e, s1 = (%e,%e,%e), s2 = (%e,%e,%e), inc = %e.\n", __func__, intreturn, m1 * pow(LAL_C_SI, 3.0) / LAL_G_SI / LAL_MSUN_SI, m2 * pow(LAL_C_SI, 3.0) / LAL_G_SI / LAL_MSUN_SI, s1x, s1y, s1z, s2x, s2y, s2z, acos(lnhatz));
---
>         XLALPrintWarning("XLAL Warning - %s: integration terminated with code %d.\n Waveform parameters were m1 = %e, m2 = %e, s1 = (%e,%e,%e), s2 = (%e,%e,%e), inc = %e.\n", __func__, intreturn, m1_SI / LAL_MSUN_SI, m2_SI / LAL_MSUN_SI, s1x, s1y, s1z, s2x, s2y, s2z, acos(lnhatz));
4028a4028,4030
>  *
>  * REVIEW completed on git hash ...
>  *
4071a4074,4102
> /**
>  * Driver routine to compute a precessing post-Newtonian inspiral waveform
>  * with phasing computed from energy balance using the so-called \"T1\" method.
>  *
>  * This routine allows the user to specify different pN orders
>  * for the phasing and amplitude of the waveform.
>  *
>  * The reference frequency fRef is used as follows:
>  * 1) if fRef = 0: The initial values of s1, s2, lnhat and e1 will be the
>  * values at frequency fStart. The orbital phase of the last sample is set
>  * to phiRef (i.e. phiRef is the "coalescence phase", roughly speaking).
>  * THIS IS THE DEFAULT BEHAVIOR CONSISTENT WITH OTHER APPROXIMANTS
>  *
>  * 2) If fRef = fStart: The initial values of s1, s2, lnhat and e1 will be the
>  * values at frequency fStart. phiRef is used to set the orbital phase
>  * of the first sample at fStart.
>  *
>  * 3) If fRef > fStart: The initial values of s1, s2, lnhat and e1 will be the
>  * values at frequency fRef. phiRef is used to set the orbital phase at fRef.
>  * The code will integrate forwards and backwards from fRef and stitch the
>  * two together to create a complete waveform. This allows one to specify
>  * the orientation of the binary in-band (or at any arbitrary point).
>  * Otherwise, the user can only directly control the initial orientation.
>  *
>  * 4) fRef < 0 or fRef >= Schwarz. ISCO are forbidden and the code will abort.
>  *
>  * REVIEW completed on git hash ...
>  *
>  */
4138a4170,4172
>  *
>  * REVIEW completed on git hash ...
>  *
4181a4216
> 
4191a4227,4228
>  *
>  * !!!UNREVIEWED!!!
4346a4384,4385
>  *
>  * !!!UNREVIEWED!!!
4451a4491
>  * !!!UNREVIEWED!!!
4531a4572
>  * !!!UNREVIEWED!!!
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylorF2.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylorF2.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylor.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylor.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylorT5.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralSpinTaylorT5.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorEt.c ./LALSimInspiralTaylorEt.c
455,456c455,457
<  * @addtogroup LALSimInspiralTaylorEt_c
<  * @brief Routines for generating TaylorEt waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @{
>  * @name Routines for TaylorEt Waveforms
660a662
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorEt.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorEt.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorF2.c ./LALSimInspiralTaylorF2.c
43,44c43,50
<  * @addtogroup LALSimInspiralTaylorF2_c
<  * @brief Routines for generating TaylorF2 waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @{
>  *
>  * @review TaylorF2 routines reviewed by Frank Ohme, Andrew Lundgren, Alex Nitz,
>  * Alex Nielsen, Salvatore Vitale, Jocelyn Read, Sebastian Khan.
>  * The review concluded with git hash 6106138b2140ffb11bc38fc914e0a1de7082dc4d (Nov 2014)
>  *
>  * @name Routines for TaylorF2 Waveforms
51,52d56
<  * @review TaylorF2 routines reviewed on YYYY-MM-DD by XXX (hash)
<  *
463a468
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpin.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpinMetric.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpinMetric.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpin.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpinTidal.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorF2ReducedSpinTidal.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorLength.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorLength.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorT1.c ./LALSimInspiralTaylorT1.c
267,268c267,271
<  * @addtogroup LALSimInspiralTaylorT1_c
<  * @brief Routines for generating TaylorT1 waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @brief Routines to produce Taylor -T1, -T2, -T3, -T4, -F2, and -Et inspiral
>  * waveforms.
>  * @{
>  * @name Routines for TaylorT1 Waveforms
657a661
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT1.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT1.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorT2.c ./LALSimInspiralTaylorT2.c
725,726c725,727
<  * @addtogroup LALSimInspiralTaylorT2_c
<  * @brief Routines for generating TaylorT2 waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @{
>  * @name Routines for TaylorT2 Waveforms
1180a1182
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT2.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT2.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorT3.c ./LALSimInspiralTaylorT3.c
758,759c758,760
<  * @addtogroup LALSimInspiralTaylorT3_c
<  * @brief Routines for generating TaylorT3 waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @{
>  * @name Routines for TaylorT3 Waveforms
1202a1204
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT3.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT3.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralTaylorT4.c ./LALSimInspiralTaylorT4.c
424,425c424,426
<  * @addtogroup LALSimInspiralTaylorT4_c
<  * @brief Routines for generating TaylorT4 waveforms.
---
>  * @addtogroup LALSimInspiralTaylorXX_c
>  * @{
>  * @name Routines for TaylorT4 Waveforms
818a820
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT4.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTaylorT4.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTestGRParams.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralTestGRParams.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralWaveformCache.c ./LALSimInspiralWaveformCache.c
490c490
<     
---
> 
730c730
<   
---
> 
755c755
<         
---
> 
814a815,820
>     if (hplus == NULL || hcross == NULL || hplus->data == NULL || hcross->data == NULL){
>         XLALPrintError("We have null pointers for h+, hx in StoreTDHCache \n");
>         XLALPrintError("Houston-S, we've got a problem SOS, SOS, SOS, the waveform generator returns NULL!!!... m1 = %.18e, m2 = %.18e, fMin = %.18e, spin1 = {%.18e, %.18e, %.18e},   spin2 = {%.18e, %.18e, %.18e} \n", 
>                    m1, m2, (double)f_min, S1x, S1y, S1z, S2x, S2y, S2z);
>         return XLAL_ENOMEM;
>     }
882c888
<     
---
> 
941a948,954
>     /* Support variables for precessing wfs*/
>     REAL8 iTmp;
>     REAL8 spin1[3],spin2[3];
> 
>     /* Variables for IMRPhenomP and IMRPhenomPv2 */
>     REAL8 chi1_l, chi2_l, chip, thetaJ, alpha0;
> 
953c966
<     
---
> 
969c982
<     
---
> 
978c991
<     
---
> 
992c1005
<             
---
> 
1009a1023
>         /* inspiral-merger-ringdown models */
1018,1019d1031
<             if( f_ref != 0.)
<                 XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
1033,1034d1044
<             if( f_ref != 0.)
<                 XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
1048,1049d1057
<             if( f_ref != 0.)
<                 XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
1063,1064d1070
<             if( f_ref != 0.)
<                 XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
1070c1076,1088
<         /* inspiral-merger-ringdown models */
---
>         case SEOBNRv2_ROM_DoubleSpin_HI:
>             /* Waveform-specific sanity checks */
>             if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
>                 ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
>             if( !checkTransverseSpinsZero(S1x, S1y, S2x, S2y) )
>                 ABORT_NONZERO_TRANSVERSE_SPINS(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
> 
>             ret = XLALSimIMRSEOBNRv2ROMDoubleSpinHIFrequencySequence(hptilde, hctilde, frequencies,
>                     phiRef, f_ref, r, i, m1, m2, S1z, S2z, -1);
>             break;
> 
1071a1090,1128
>             spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
>             spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
>             iTmp=i;
>             XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
> 
>             /* Waveform-specific sanity checks */
>             if( !XLALSimInspiralFrameAxisIsDefault(
>                     XLALSimInspiralGetFrameAxis(waveFlags) ) ) /* Default is LAL_SIM_INSPIRAL_FRAME_AXIS_VIEW : z-axis along direction of GW propagation (line of sight). */
>                 ABORT_NONDEFAULT_FRAME_AXIS(waveFlags);
>             if( !XLALSimInspiralModesChoiceIsDefault(          /* Default is (2,2) or l=2 modes. */
>                     XLALSimInspiralGetModesChoice(waveFlags) ) )
>                 ABORT_NONDEFAULT_MODES_CHOICE(waveFlags);
>             if( !checkTidesZero(lambda1, lambda2) )
>                 ABORT_NONZERO_TIDES(waveFlags);
>             LNhatx = sin(i);
>             LNhaty = 0.;
>             LNhatz = cos(i);
>             /* Tranform to model parameters */
>             if(f_ref==0.0)
>                 f_ref = f_min; /* Default reference frequency is minimum frequency */
>             XLALSimIMRPhenomPCalculateModelParameters(
>                 &chi1_l, &chi2_l, &chip, &thetaJ, &alpha0,
>                 m1, m2, f_ref,
>                 LNhatx, LNhaty, LNhatz,
>                 S1x, S1y, S1z,
>                 S2x, S2y, S2z, IMRPhenomPv1_V);
>             /* Call the waveform driver routine */
>             ret = XLALSimIMRPhenomPFrequencySequence(hptilde, hctilde, frequencies,
>               chi1_l, chi2_l, chip, thetaJ,
>               m1, m2, r, alpha0, phiRef, f_ref, IMRPhenomPv1_V);
>             if (ret == XLAL_FAILURE) XLAL_ERROR(XLAL_EFUNC);
>             break;
> 
>         case IMRPhenomPv2:
>             spin1[0]=S1x; spin1[1]=S1y; spin1[2]=S1z;
>             spin2[0]=S2x; spin2[1]=S2y; spin2[2]=S2z;
>             iTmp=i;
>             XLALSimInspiralInitialConditionsPrecessingApproxs(&i,&S1x,&S1y,&S1z,&S2x,&S2y,&S2z,iTmp,spin1[0],spin1[1],spin1[2],spin2[0],spin2[1],spin2[2],m1,m2,f_ref,XLALSimInspiralGetFrameAxis(waveFlags));
> 
1085d1141
<             REAL8 chi_eff, chip, eta, thetaJ, alpha0;
1089c1145
<                 &chi_eff, &chip, &eta, &thetaJ, &alpha0,
---
>                 &chi1_l, &chi2_l, &chip, &thetaJ, &alpha0,
1093c1149
<                 S2x, S2y, S2z);
---
>                 S2x, S2y, S2z, IMRPhenomPv2_V);
1096,1097c1152,1153
<               chi_eff, chip, eta, thetaJ,
<               m1+m2, r, alpha0, phiRef, f_ref);
---
>               chi1_l, chi2_l, chip, thetaJ,
>               m1, m2, r, alpha0, phiRef, f_ref, IMRPhenomPv2_V);
1105c1161
<     
---
> 
1107c1163
<     
---
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformCache.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformCache.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralWaveformFlags.c ./LALSimInspiralWaveformFlags.c
19c19,21
< #include  <lal/LALSimInspiralWaveformFlags.h>
---
> #include <stdio.h>
> #include <lal/LALString.h>
> #include <lal/LALSimInspiralWaveformFlags.h>
36a39
>     char numreldata[FILENAME_MAX]; /**< Location of NR data file for NR waveforms */
292a296,330
> /**
>  * Set the numreldata string within a LALSimInspiralWaveformFlags struct
>  */
> void XLALSimInspiralSetNumrelData(
>         LALSimInspiralWaveformFlags *waveFlags, /**< Struct whose value will be set */
>         const char* numreldata /**< value to set numreldata to */
>         )
> {
>     XLALStringCopy(waveFlags->numreldata, numreldata, sizeof(waveFlags->numreldata));
>     return;
> }
> 
> /**
>  * Returns a deepcopy of the pointer of the numeraldata attribute of the
>  * waveFlags structure. If this is NULL then NULL will be returned.
>  * The returned value is independent of the waveFlags structure and will
>  * need to be LALFree-d.
>  */
> char* XLALSimInspiralGetNumrelData(
>         LALSimInspiralWaveformFlags *waveFlags
>         )
> {
>     char *ret_string;
>     if ( waveFlags )
>     {
>         ret_string = XLALMalloc(FILENAME_MAX * sizeof(char));
>         XLALStringCopy(ret_string, waveFlags->numreldata, sizeof(waveFlags->numreldata));
>         return ret_string;
>     }
>     else
>     {
>         return NULL;
>     }
> }
> 
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimInspiralWaveformFlags.h ./LALSimInspiralWaveformFlags.h
138a139,140
> void XLALSimInspiralSetNumrelData(LALSimInspiralWaveformFlags *waveFlags, const char* numreldata);
> char* XLALSimInspiralGetNumrelData(LALSimInspiralWaveformFlags *waveFlags);
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformFlags.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformFlags.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformTaper.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimInspiralWaveformTaper.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarEOS.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarEOS.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarFamily.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarFamily.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarTOV.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNeutronStarTOV.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimNoise.c ./LALSimNoise.c
52c52
< 	stilde = XLALCreateCOMPLEX16FrequencySeries("STILDE", &s->epoch, 0.0, 1.0/(s->data->length * s->deltaT), &lalSecondUnit, s->data->length/2 + 1);
---
> 	stilde = XLALCreateCOMPLEX16FrequencySeries("STILDE", &s->epoch, 0.0, 1.0/(s->data->length * s->deltaT), &lalDimensionlessUnit, s->data->length/2 + 1);
58c58,60
< 	XLALUnitMultiply(&stilde->sampleUnits, &stilde->sampleUnits, &s->sampleUnits);
---
> 	/* correct units: [stilde] = sqrt([psd] * seconds) */
> 	XLALUnitMultiply(&stilde->sampleUnits, &psd->sampleUnits, &lalSecondUnit);
> 	XLALUnitSqrt(&stilde->sampleUnits, &stilde->sampleUnits);
73a76,81
> /**
>  * @addtogroup LALSimNoise_c
>  * @brief Routines to produce a continuous stream of simulated
>  * gravitational-wave detector noise.
>  * @{
>  */
76,77c84,85
<  * Routine that may be used to generate sequential segments of data with a
<  * specified stride from one segment to the next.
---
>  * @brief Routine that may be used to generate sequential segments of data with
>  * a specified stride from one segment to the next.
86c94
<  * \code
---
>  * @code
119c127
<  * \endcode
---
>  * @endcode
126,130c134,136
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
---
>  * @note
>  * - If stride = 0, initialize h by generating one (periodic) realization of
>  *   noise; subsequent calls should have non-zero stride.
132,134c138,140
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
---
>  * - If stride = h->data->length then generate one segment of non-periodic
>  *   noise by generating two different realizations and feathering them
>  *   together.
136c142
<  * Warning: only the first stride points are valid.
---
>  * @warning Only the first stride points are valid.
193a200
> /** @} */
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimNoise.h ./LALSimNoise.h
19a20,31
> /**
>  * @defgroup LALSimNoise_h Header LALSimNoise.h
>  * @ingroup lalsimulation_noise
>  * @author Jolien Creighton
>  * @brief Routines for simulating gravitational wave detector noise.
>  *
>  * @{
>  * @defgroup LALSimNoise_c    Module LALSimNoise.c
>  * @defgroup LALSimNoisePSD_c Module LALSimNoisePSD.c
>  * @}
>  */
> 
44,51d55
< /*
<  *
<  *
<  * PSD GENERATION FUNCTIONS
<  *
<  *
<  */
< 
54,76c58,59
<  *
<  * FUNCTIONS TO GENERATE COMPONENT NOISE PSD
<  *
<  */
< 
< /**
<  * Provides a rather ad-hoc estimate of the seismic noise power spectral density
<  * at a given frequency.
<  *
<  * This is a crude estimate based on characteristic frequencies for the
<  * pendulum and the stack.  What is computed is
<  * \f[
<  * S_h(f) = L^{-2} S_g(f) (f_{\mathrm{pend}}/f)^4
<  * (f_{\mathrm{stack}}/f)^{4n_{\mathrm{stack}}}
<  * \f]
<  * where
<  * \f[
<  * S_g(f) = 10^{-18}\,\mathrm{m}^2\,\mathrm{Hz}^{-1}\times(10\,\mathrm{Hz}/f)^4
<  * \f]
<  * is the displacement power spectrum of ground motion.
<  *
<  * Warning: the transfer function is only correct at frequencies above the
<  * specified characteristic pendulum and stack frequencies.
---
>  * NOISE GENERATION ROUTINES
>  * in module LALSimNoise.c
78,84d60
< double XLALSimNoisePSDSeismic(
< 	double f,		/**< frequency (Hz) */
< 	double L,		/**< arm length (m) */
< 	double f_pend,		/**< characteristic frequency of pendulum suspension (Hz) */
< 	double f_stack,		/**< characteristic frequency of isolation stack (Hz) */
< 	double n_stack		/**< number of layers of stack */
< );
86,107d61
< /**
<  * Provides a rather ad-hoc estimate of the suspension thermal noise power
<  * spectral density at a given frequency.
<  *
<  * This is a crude estimate based on the characteristic frequency of the
<  * pendulum suspension and its quality factor (= 1 / loss angle).  What is
<  * computed is
<  * \f[
<  * S_h(f) = L^{-2} \frac{2 k T}{\pi^3 f_0^3 M Q} \left( \frac{f_0}{f} \right)^5.
<  * \f]
<  *
<  * Warning: this only describes the broadband noise at frequencies above the
<  * pendulum frequency; it does not have the correct noise near the resonances.
<  */
< double XLALSimNoisePSDSuspTherm(
< 	double f,		/**< frequency (Hz) */
< 	double L,		/**< arm length (m) */
< 	double M,		/**< mirror mass (kg) */
< 	double T,		/**< temperature (K) */
< 	double f0,		/**< pendulum frequency */
< 	double Q		/**< pendulum quality */
< );
109,130c63
< /**
<  * Provides a rather ad-hoc estimate of the mirror thermal noise power spectral
<  * density at a given frequency.
<  *
<  * This is a crude estimate based on the characteristic frequency of the
<  * mirror/coating internal modes and their quality factor (= 1 / loss angle).
<  * What is computed is
<  * \f[
<  * S_h(f) = L^{-2} \frac{2 k T}{\pi^3 f_0^3 M Q} \frac{f_0}{f}
<  * \f]
<  *
<  * Warning: this only describes the broadband noise at frequencies below the
<  * resonance frequency; it does not have the correct noise near the resonances.
<  */
< double XLALSimNoisePSDMirrorTherm(
< 	double f,		/**< frequency (Hz) */
< 	double L,		/**< arm length (m) */
< 	double M,		/**< mirror mass (kg) */
< 	double T,		/**< average per mirror power loss */
< 	double f0,		/**< average per mirror power loss */
< 	double Q		/**< average per mirror power loss */
< );
---
> int XLALSimNoise(REAL8TimeSeries *s, size_t stride, REAL8FrequencySeries *psd, gsl_rng *rng);
132,176d64
< /**
<  * Computes the shot noise in strain-equivalent units using a conventional
<  * model appropriate to initial interferometric detectors.
<  *
<  * Uses the formula for shot noise from
<  *
<  */
< double XLALSimNoisePSDShot(
< 	double f,		/**< frequency (Hz) */
< 	double P_BS,		/**< laser power on beamsplitter (W) */
< 	double lambda,		/**< laser wavelength (m) */
< 	double L,		/**< arm length (m) */
< 	double finesse,		/**< arm cavity finesse */
< 	double eta		/**< effective quantum efficiency of photodiode */
< );
< 
< /**
<  * Computes the quantum noise (shot noise and radiation pressure noise)
<  * according to Buonanno and Chen, Phys. Rev. D 64 0402006 (2001).
<  *
<  * This code is adapted from the GWINC matlab function shotrad.m which includes
<  * updated losses by Kirk McKenzie.
<  *
<  * For simplicity, only losses from the mirrors are included.  Losses from
<  * coupling and from the SRC are ignored.  (These could be included as
<  * effective losses in A_BS if needed.) A fixed photdiode quantum efficiency of
<  * eta = 0.9 is used.
<  *
<  * Note: this code is adapted from GWINC.
<  */
< double XLALSimNoisePSDQuantum(
< 	double f,		/**< frequency (Hz) */
< 	double I0,		/**< laser power (W) */
< 	double lambda,		/**< laser wavelength (m) */
< 	double L,		/**< arm length (m) */
< 	double M,		/**< mirror mass (kg) */
< 	double A,		/**< average per mirror power loss */
< 	double A_BS,		/**< power loss at beam splitter */
< 	double T_ITM,		/**< transmittance of ITM */
< 	double T_PRM,		/**< transmittance of PRM */
< 	double T_SRM,		/**< transmittance of SRM */
< 	double ds,		/**< detuning phase (rad) */
< 	double zeta,		/**< demod/detection/homodyne phase */
< 	double eta		/**< quantum efficiency of photodiode */
< );
179,234c67,68
<  *
<  * NOISE PSD ROUTINES FOR FIRST GENERATION DETECTORS
<  *
<  */
< 
< 
< /**
<  * Provides the noise power spectrum based on a phenomenological fit
<  * to the SRD curve for iLIGO.
<  *
<  * This is a fit to the data provided for the Science Requirements Document
<  * (SRD) curve for initial LIGO given, which can be found at
<  * http://www.ligo.caltech.edu/~jzweizig/distribution/LSC_Data/
<  *
<  * The Science Requirements Document is located at
<  * http://www.ligo.caltech.edu/docs/E/E950018-02.pdf
<  */
< double XLALSimNoisePSDiLIGOSRD(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the seismic noise power spectrum for iLIGO.
<  *
<  * Note: only valit for f > 10 Hz.
<  * This is mostly a phenomenological fit.
<  */
< double XLALSimNoisePSDiLIGOSeismic(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the thermal noise (suspension + coating) power spectrum for iLIGO.
<  *
<  * Note: this is a phenomenological fit to the broadband component.
<  */
< double XLALSimNoisePSDiLIGOThermal(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the shot noise power spectrum for iLIGO.
<  *
<  * Note: the effective quantum efficiency is one-third the actual quantum
<  * efficiency owing to the RF readout scheme.  A fiducial value of 250 W
<  * of power on the beamsplitter is used.
<  */
< double XLALSimNoisePSDiLIGOShot(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the shot noise power spectrum for eLIGO.
<  *
<  * Note: A fiducial value of 250 W of power on the beamsplitter is used.
<  */
< double XLALSimNoisePSDeLIGOShot(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for a model of the iLIGO detector.
<  *
<  * Warning: not all noise sources are correctly accounted for (in particular,
<  * there is no actuation noise modelled) so this noise spectrum does not
<  * correspond to the S5 spectrum.
---
>  * PSD GENERATION FUNCTIONS
>  * in module LALSimNoisePSD.c
236d69
< double XLALSimNoisePSDiLIGOModel(double f /**< frequency (Hz) */);
238,244d70
< /**
<  * Provides the noise power spectrum for a model of the eLIGO detector.
<  *
<  * Warning: not all noise sources are correctly accounted for so this noise
<  * spectrum does not correspond to the S6 spectrum.
<  */
< double XLALSimNoisePSDeLIGOModel(double f /**< frequency (Hz) */);
246,259c72,73
< /**
<  * Provides the design noise power spectrum for Virgo based on a
<  * phenomenological fit (from the Virgo webiste) that can be approximated by the
<  * following:
<  * \f{equation}{
<  * S_h(f) =
<  * s_0 \left ( \frac {7.87f}{f_0} \right )^{-4.8} + \frac{6}{17} \frac{f_0}{f}
<  * + \left [1 + \left (\frac {f}{f_0} \right)^2 \right ],
<  * \f}
<  * where \f$s_0=10.2e-46\f$.
<  *
<  * Warning: This comes from the deprecated function LALVIRGOPsd in the lal
<  * noisemodels package, which comes with no reference to the curve. An updated
<  * version of this model, with a reference would be welcomed.
---
> /*
>  * FUNCTIONS TO GENERATE COMPONENT NOISE PSD
261d74
< double XLALSimNoisePSDVirgo(double f /**< frequency (Hz) */);
263,270c76,80
< /**
<  * Provides a GEO noise power spectrum based on that from Table IV of
<  * \cite dis2001 .
<  *
<  * The comes from the deprecated function LALGEOPsd in the lal noisemodels
<  * package.
<  */
< double XLALSimNoisePSDGEO(double f /**< frequency (Hz) */);
---
> double XLALSimNoisePSDSeismic(double f, double L, double f_pend, double f_stack, double n_stack);
> double XLALSimNoisePSDSuspTherm(double f, double L, double M, double T, double f0, double Q);
> double XLALSimNoisePSDMirrorTherm(double f, double L, double M, double T, double f0, double Q);
> double XLALSimNoisePSDShot(double f, double P_BS, double lambda, double L, double finesse, double eta);
> double XLALSimNoisePSDQuantum(double f, double I0, double lambda, double L, double M, double A, double A_BS, double T_ITM, double T_PRM, double T_SRM, double ds, double zeta, double eta);
272,277c82,83
< /**
<  * Provides a GEO-HF noise power spectrum based on a fit to Figure 6
<  * from \cite Grote2010 .
<  *
<  * The fit is good between 50Hz to 8kHz and errors between the analytic
<  * fit given and the <a href="https://intranet.aei.uni-hannover.de/geo600/geohflogbook.nsf/7e8722dffa24dea0c1256de900406c84/4837a612ac990060c12575ce004e70fd?OpenDocument">estimated curve</a> are less than 1%.
---
> /*
>  * NOISE PSD ROUTINES FOR FIRST GENERATION DETECTORS
279d84
< double XLALSimNoisePSDGEOHF(double f /**< frequency (Hz) */);
281,288c86,97
< /**
<  * Provides a TAMA300 noise power spectrum based on that from Table IV of
<  * \cite dis2001 .
<  *
<  * The comes from the deprecated function LALTAMAPsd in the lal noisemodels
<  * package.
<  */
< double XLALSimNoisePSDTAMA(double f /**< frequency (Hz) */);
---
> double XLALSimNoisePSDiLIGOSRD(double f);
> double XLALSimNoisePSDiLIGOSeismic(double f);
> double XLALSimNoisePSDiLIGOThermal(double f);
> double XLALSimNoisePSDiLIGOShot(double f);
> double XLALSimNoisePSDeLIGOShot(double f);
> 
> double XLALSimNoisePSDiLIGOModel(double f);
> double XLALSimNoisePSDeLIGOModel(double f);
> double XLALSimNoisePSDVirgo(double f);
> double XLALSimNoisePSDGEO(double f);
> double XLALSimNoisePSDGEOHF(double f);
> double XLALSimNoisePSDTAMA(double f);
291d99
<  *
293,376d100
<  *
<  */
< 
< 
< /**
<  * Provides the thermal noise (suspension + coating) power spectrum for iLIGO.
<  *
<  * Note: this is a phenomenological fit to the broadband component.
<  */
< double XLALSimNoisePSDaLIGOThermal(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the low-power
<  * no-signal-recycling-mirror configuration.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled No SRM.
<  */
< double XLALSimNoisePSDaLIGOQuantumNoSRMLowPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the high-power
<  * no-signal-recycling-mirror configuration.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is the same a No SRM but with 125 W laser power.
<  */
< double XLALSimNoisePSDaLIGOQuantumNoSRMHighPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the low-power
<  * broad-band signal recycling (no detuning of the signal recycling cavity).
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled Zero Detune, Low Power.
<  */
< double XLALSimNoisePSDaLIGOQuantumZeroDetLowPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the high-power
<  * broad-band signal recycling (no detuning of the signal recycling cavity).
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled Zero Detune, High Power.
<  */
< double XLALSimNoisePSDaLIGOQuantumZeroDetHighPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the
<  * configuration tuned to optimize sensitivity to NS-NS inspirals.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled NS-NS Opt.
<  */
< double XLALSimNoisePSDaLIGOQuantumNSNSOpt(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the
<  * configuration tuned to optimize sensitivity to 30+30 solar mass binary
<  * black holes with fixed signal recycling cavity detuning of 20 degrees.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled BHBH 20-degree Detune.
<  */
< double XLALSimNoisePSDaLIGOQuantumBHBH20Deg(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the quantum noise power spectrum for aLIGO under the
<  * configuration tuned to narrow-band high-frequency sensitivity around
<  * 1 kHz.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled High Freq.
<  */
< double XLALSimNoisePSDaLIGOQuantumHighFrequency(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the low-power
<  * no-signal-recycling-mirror configuration.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled No SRM.
<  *
<  * Note: This includes only thermal and quantum noise.
378,467d101
< double XLALSimNoisePSDaLIGONoSRMLowPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the high-power
<  * no-signal-recycling-mirror configuration.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is the same a No SRM but with 125 W laser power.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGONoSRMHighPower(double f /**< frequency (Hz) */);
< 
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the low-power
<  * broad-band signal recycling (no detuning of the signal recycling cavity).
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled Zero Detune, Low Power.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGOZeroDetLowPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the high-power
<  * broad-band signal recycling (no detuning of the signal recycling cavity).
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled Zero Detune, High Power.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGOZeroDetHighPower(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the
<  * configuration tuned to optimize sensitivity to NS-NS inspirals.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled NS-NS Opt.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGONSNSOpt(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the
<  * configuration tuned to optimize sensitivity to 30+30 solar mass binary
<  * black holes with fixed signal recycling cavity detuning of 20 degrees.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled BHBH 20-degree Detune.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGOBHBH20Deg(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for aLIGO under the
<  * configuration tuned to narrow-band high-frequency sensitivity around
<  * 1 kHz.
<  *
<  * See: LIGO-T0900288-v3 and LIGO-T070247-01.
<  * This configuration is labelled High Freq.
<  *
<  * Warning: This includes only thermal and quantum noise.  It is only valid
<  * above around 9 Hz.
<  */
< double XLALSimNoisePSDaLIGOHighFrequency(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for KAGRA based on that from Eqn 5 of
<  * \cite md2012 . This is a phenomenological fit to the KAGRA spectrum from
<  * http://gwcenter.icrr.u-tokyo.ac.jp/en/researcher/parameter.
<  */
< double XLALSimNoisePSDKAGRA(double f /**< frequency (Hz) */);
< 
< /**
<  * Provides the noise power spectrum for AdvVirgo based on that from Eqn 6 of
<  * \cite md2012 . This is a phenomenological fit to the AdvVirgo spectrum from
<  * http://wwwcascina.virgo.infin.it/advirgo.
<  */
< double XLALSimNoisePSDAdvVirgo(double f /**< frequency (Hz) */);
468a103,120
> double XLALSimNoisePSDaLIGOThermal(double f);
> double XLALSimNoisePSDaLIGOQuantumNoSRMLowPower(double f);
> double XLALSimNoisePSDaLIGOQuantumNoSRMHighPower(double f);
> double XLALSimNoisePSDaLIGOQuantumZeroDetLowPower(double f);
> double XLALSimNoisePSDaLIGOQuantumZeroDetHighPower(double f);
> double XLALSimNoisePSDaLIGOQuantumNSNSOpt(double f);
> double XLALSimNoisePSDaLIGOQuantumBHBH20Deg(double f);
> double XLALSimNoisePSDaLIGOQuantumHighFrequency(double f);
> 
> double XLALSimNoisePSDaLIGONoSRMLowPower(double f);
> double XLALSimNoisePSDaLIGONoSRMHighPower(double f);
> double XLALSimNoisePSDaLIGOZeroDetLowPower(double f);
> double XLALSimNoisePSDaLIGOZeroDetHighPower(double f);
> double XLALSimNoisePSDaLIGONSNSOpt(double f);
> double XLALSimNoisePSDaLIGOBHBH20Deg(double f);
> double XLALSimNoisePSDaLIGOHighFrequency(double f);
> double XLALSimNoisePSDKAGRA(double f);
> double XLALSimNoisePSDAdvVirgo(double f);
471d122
<  *
473,489d123
<  *
<  */
< 
< /**
<  * Evaluates a power spectral density function, psdfunc, at the frequencies required
<  * to populate the frequency series psd, with a low frequency cutoff flow.
<  */
< int XLALSimNoisePSD(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow,			/**< low frequency cutoff (Hz) */
< 	double (*psdfunc)(double)	/**< function that provides the PSD at a specified frequency */
< );
< 
< /**
<  * Reads file fname containing two-column amplitude spectral density data file
<  * and interpolates at the frequencies required to populate the frequency
<  * series psd, with a low frequency cutoff flow.
491,693d124
< int XLALSimNoisePSDFromFile(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow,			/**< low frequency cutoff (Hz) */
< 	const char *fname		/**< file containing amplitude spectral density data */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "NO_SRM.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGONoSRMLowPowerGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "ZERO_DET_low_P.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGOZeroDetLowPowerGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "ZERO_DET_high_P.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGOZeroDetHighPowerGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "NSNS_Opt.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGONSNSOptGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "BBH_20deg.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGOBHBH20DegGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the "High_Freq.txt" data file in LIGO-T0900288.
<  */
< int XLALSimNoisePSDaLIGOHighFrequencyGWINC(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2015 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOEarlyLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2015 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOEarlyHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2016-2017 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOMidLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2016-2017 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOMidHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2017-2018 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOLateLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2017-2018 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOLateHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO 2019 design sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGODesignSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the aLIGO BNS-optimized sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDaLIGOBNSOptimizedSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2016-2017 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVEarlyLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2016-2017 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVEarlyHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2017-2018 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVMidLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2017-2018 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVMidHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2018-2020 low-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVLateLowSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2018-2020 high-sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVLateHighSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV 2021 design sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVDesignSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
< 
< /**
<  * Returns a frequency series psd with low frequency cutoff flow corresponding
<  * to the AdV BNS-optimized sensitivity scenario in LIGO-P1200087.
<  */
< int XLALSimNoisePSDAdVBNSOptimizedSensitivityP1200087(
< 	REAL8FrequencySeries *psd,	/**< frequency series to be computed */
< 	double flow 			/**< low frequency cutoff (Hz) */
< );
694a126,127
> int XLALSimNoisePSD(REAL8FrequencySeries *psd, double flow, double (*psdfunc)(double));
> int XLALSimNoisePSDFromFile(REAL8FrequencySeries *psd, double flow, const char *fname);
697,699c130
<  *
<  * NOISE GENERATION ROUTINES
<  *
---
>  * NOISE PSDs FROM LIGO-T0900288
702,771c133,159
< 
< /**
<  * Routine that may be used to generate sequential segments of data with a
<  * specified stride from one segment to the next.
<  *
<  * Calling instructions: for the first call, set stride = 0; subsequent calls
<  * should pass the same time series and have non-zero stride.  This routine
<  * will advance the time series by an amount given by the stride and will
<  * generate new data so that the data is continuous from one segment to the
<  * next.  For example: the following routine will output a continuous stream of
<  * detector noise with an Initial LIGO spectrum above 40 Hz:
<  *
<  * \code
<  * #include <stdio.h>
<  * #include <gsl/gsl_rng.h>
<  * #include <lal/LALStdlib.h>
<  * #include <lal/FrequencySeries.h>
<  * #include <lal/TimeSeries.h>
<  * #include <lal/LALSimNoise.h>
<  * void mkligodata(void)
<  * {
<  * 	const double flow = 40.0; // 40 Hz low frequency cutoff
<  * 	const double duration = 16.0; // 16 second segments
<  * 	const double srate = 16384.0; // sampling rate in Hertz
<  * 	size_t length = duration * srate; // segment length
<  * 	size_t stride = length / 2; // stride between segments
<  * 	LIGOTimeGPS epoch = { 0, 0 };
<  * 	REAL8FrequencySeries *psd;
<  * 	REAL8TimeSeries *seg;
<  *	gsl_rng *rng;
<  * 	gsl_rng_env_setup();
<  * 	rng = gsl_rng_alloc(gsl_rng_default);
<  * 	seg = XLALCreateREAL8TimeSeries("STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  *	psd = XLALCreateREAL8FrequencySeries("LIGO SRD", &epoch, 0.0, 1.0/duration, &lalSecondUnit, length/2 + 1);
<  *	XLALSimNoisePSD(psd, flow, XLALSimNoisePSDiLIGOSRD);
<  * 	XLALSimNoise(seg, 0, psd, rng); // first time to initialize
<  *	while (1) { // infinite loop
<  * 		double t0 = XLALGPSGetREAL8(&seg->epoch);
<  * 		size_t j;
<  *		for (j = 0; j < stride; ++j) // output first stride points
<  * 			printf("%.9f\t%e\n", t0 + j*seg->deltaT, seg->data->data[j]);
<  *		XLALSimNoise(seg, stride, psd, rng); // make more data
<  * 	}
<  * }
<  * \endcode
<  *
<  *
<  * If only one single segment of data is required, set stride to be the length
<  * of the timeseries data vector.  This will make a single segment of data
<  * that is *not* periodic (also, in this case it will not advance the epoch of
<  * the timeseries).
<  *
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
<  *
<  * Warning: only the first stride points are valid.
<  */
< int XLALSimNoise(
< 	REAL8TimeSeries *s,		/**< [in/out] noise time series */
< 	size_t stride,			/**< [in] stride (samples) */
< 	REAL8FrequencySeries *psd,	/**< [in] power spectrum frequency series */
< 	gsl_rng *rng			/**< [in] GSL random number generator */
< );
---
> int XLALSimNoisePSDaLIGONoSRMLowPowerGWINC(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOZeroDetLowPowerGWINC(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOZeroDetHighPowerGWINC(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGONSNSOptGWINC(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOBHBH20DegGWINC(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOHighFrequencyGWINC(REAL8FrequencySeries *psd, double flow);
> 
> /*
>  * NOISE PSDs FROM LIGO-P1200087
>  */
> 
> int XLALSimNoisePSDaLIGOEarlyLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOEarlyHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOMidLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOMidHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOLateLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOLateHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGODesignSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDaLIGOBNSOptimizedSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVEarlyLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVEarlyHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVMidLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVMidHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVLateLowSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVLateHighSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVDesignSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
> int XLALSimNoisePSDAdVBNSOptimizedSensitivityP1200087(REAL8FrequencySeries *psd, double flow);
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNoise.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNoise.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimNoisePSD.c ./LALSimNoisePSD.c
26a27
> #include <lal/Units.h>
29a31,33
> // PSD units
> static LALUnit strainSquaredPerHertzUnit = { 0, { 0, 0, 1, 0, 0, 2, 0}, { 0, 0, 0, 0, 0, 0, 0} };
> 
64a69,74
> /* prefix for noise psd files provided by LIGO-T0900288 */
> #define T0900288 "LIGO-T0900288-v3-"
> 
> /* prefix for noise psd files provided by LIGO-T0900288 */
> #define P1200087 "LIGO-P1200087-v18-"
> 
65a76,81
> /**
>  * @addtogroup LALSimNoisePSD_c
>  * @brief Routines to compute noise power spectral densities for
>  * gravitational-wave detectors.
>  * @{
>  */
66a83,86
> /**
>  * @name Routines to Generate Component Noise PSDs
>  * @{
>  */
84c104
<  * Warning: the transfer function is only correct at frequencies above the
---
>  * @warning The transfer function is only correct at frequencies above the
117c137
<  * Warning: this only describes the broadband noise at frequencies above the
---
>  * @warning This only describes the broadband noise at frequencies above the
145c165
<  * Warning: this only describes the broadband noise at frequencies below the
---
>  * @warning This only describes the broadband noise at frequencies below the
198c218
<  * Note: this code is adapted from GWINC.
---
>  * @note This code is adapted from GWINC.
275a296
> /** @} */
277,280c298,300
< /*
<  *
<  * FIRST GENERATION DETECTORS
<  *
---
> /**
>  * @name Noise PSD Routines for First-Generation Detectors
>  * @{
283d302
< 
313c332
<  * Note: only valit for f > 10 Hz.
---
>  * @note
314a334
>  * Only valid for f > 10 Hz.
332c352
<  * Note: this is a phenomenological fit to the broadband component.
---
>  * @note This is a phenomenological fit to the broadband component.
357c377
<  * Note: the effective quantum efficiency is one-third the actual quantum
---
>  * @note The effective quantum efficiency is one-third the actual quantum
378c398
<  * Note: A fiducial value of 250 W of power on the beamsplitter is used.
---
>  * @note A fiducial value of 250 W of power on the beamsplitter is used.
397c417
<  * Warning: not all noise sources are correctly accounted for (in particular,
---
>  * @warning Not all noise sources are correctly accounted for (in particular,
418c438
<  * Warning: not all noise sources are correctly accounted for so this noise
---
>  * @warning Not all noise sources are correctly accounted for so this noise
445c465
<  * Warning: This comes from the deprecated function LALVIRGOPsd in the lal
---
>  * @warning This comes from the deprecated function LALVIRGOPsd in the lal
514,518c534
< /*
<  *
<  * SECOND GENERATION DETECTORS
<  *
<  */
---
> /** @} */
519a536,539
> /**
>  * @name Noise PSD Routines for Second Generation Detectors
>  * @{
>  */
524c544
<  * Note: this is a phenomenological fit to the broadband component.
---
>  * @note This is a phenomenological fit to the broadband component.
765c785
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
787c807
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
809c829
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
831c851
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
853c873
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
876c896
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
899c919
<  * Warning: This includes only thermal and quantum noise.  It is only valid
---
>  * @warning This includes only thermal and quantum noise.  It is only valid
956a977,982
> /** @} */
> 
> /**
>  * @name Noise PSD Utility Routines
>  * @{
>  */
971,973c997,998
< 	/* set DC and Nyquist to zero */
< 	/* note: assumes last element is Nyquist */
< 	psd->data->data[0] = psd->data->data[psd->data->length - 1] = 0.0;
---
> 	/* set sample units */
> 	psd->sampleUnits = strainSquaredPerHertzUnit;
976c1001,1006
< 	kmin = flow / psd->deltaF;
---
> 	if (flow < psd->f0) 
> 		flow = psd->f0;
> 	if (psd->f0 == 0.0)
> 		kmin = 1; /* will set DC to zero */
> 	else
> 		kmin = (flow - psd->f0) / psd->deltaF;
978,979c1008
< 	psd->data->data[0] = 0.0; /* set DC to zero */
< 	for (k = 1; k < kmin; ++k) /* set low frequency components to zero */
---
> 	for (k = 0; k < kmin; ++k) /* set low frequency components to zero */
981,983c1010,1014
< 	for (; k < psd->data->length - 1; ++k) /* evaluate psdfn for frequencies in requested band */
< 		psd->data->data[k] = (*psdfunc)(k * psd->deltaF);
< 	psd->data->data[psd->data->length - 1] = 0.0; /* set Nyquist to zero (presume this is Nyquist!) */
---
> 	for (; k < psd->data->length - 1; ++k) /* evaluate psdfunc for frequencies in requested band */
> 		psd->data->data[k] = (*psdfunc)(psd->f0 + k * psd->deltaF);
> 
> 	/* set Nyquist to zero (assumes last element is Nyquist!) */
> 	psd->data->data[psd->data->length - 1] = 0.0;
992c1023,1025
<  * series psd, with a low frequency cutoff flow.
---
>  * series psd, with a low frequency cutoff @p flow.  If @p flow is zero or
>  * negative, the low frequency cutoff is the first frequency with non-zero
>  * amplitude spectral density in the file.
1003a1037
> 	size_t  imin = 0;
1016c1050,1052
< 	/* take the log of the amplitude spectral density data */
---
> 
> 	/* take the log of the amplitude spectral density data 
> 	 * and record the first valid index of h */
1018c1054,1060
< 		h[i] = log(h[i]);
---
> 		if (h[i] > 0.0) {
> 			h[i] = log(h[i]);
> 			if (imin == 0)
> 				imin = i;
> 		}
> 		else
> 			h[i] = 0.0;
1020,1022c1062,1063
< 	/* set DC and Nyquist to zero */
< 	/* note: assumes last element is Nyquist */
< 	psd->data->data[0] = psd->data->data[psd->data->length - 1] = 0.0;
---
> 	/* set sample units */
> 	psd->sampleUnits = strainSquaredPerHertzUnit;
1025c1066,1073
< 	kmin = flow / psd->deltaF;
---
> 	if (flow <= 0.0) /* use lowest non-zero value in data */
> 		flow = f[imin];
> 	if (flow < psd->f0) 
> 		flow = psd->f0;
> 
> 	kmin = (flow - psd->f0) / psd->deltaF;
> 	if (kmin == 0 && psd->f0 == 0.0)
> 		kmin = 1; /* will set DC to zero */
1027,1029c1075,1076
< 	i = 1;
< 	psd->data->data[0] = 0.0; /* set DC to zero */
< 	for (k = 1; k < kmin; ++k) /* set low frequency components to zero */
---
> 	i = imin + 1;
> 	for (k = 0; k < kmin; ++k) /* set low frequency components to zero */
1032c1079
< 		double fk = k * psd->deltaF; /* target frequency */
---
> 		double fk = psd->f0 + k * psd->deltaF; /* target frequency */
1043c1090,1091
< 	psd->data->data[psd->data->length - 1] = 0.0; /* set Nyquist to zero (presume this is Nyquist!) */
---
> 	/* set Nyquist to zero (assumes last element is Nyquist!) */
> 	psd->data->data[psd->data->length - 1] = 0.0;
1050,1051c1098,1103
< /* prefix for noise psd files provided by LIGO-T0900288 */
< #define T0900288 "LIGO-T0900288-v3-"
---
> /** @} */
> 
> /**
>  * @name Noise PSDs from LIGO-T0900288
>  * @{
>  */
1125,1126c1177,1182
< /* prefix for noise psd files provided by LIGO-T0900288 */
< #define P1200087 "LIGO-P1200087-v18-"
---
> /** @} */
> 
> /**
>  * @name Noise PSDs from LIGO-P1200087
>  * @{
>  */
1335a1392,1395
> /** @} */
> 
> /** @} */
> 
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNoisePSD.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimNoisePSD.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-ns-eos-table
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-ns-mass-radius
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-ns-params
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimPhenSpinRingDown.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimPhenSpinRingDown.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimReadData.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimReadData.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-sgwb
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimSGWB.c ./LALSimSGWB.c
36,99d35
< 
< /**
<  * Creates a frequency series that contains a flat SGWB spectrum with the
<  * specified power Omega0 above some low frequency cutoff flow.
<  */
< REAL8FrequencySeries *XLALSimSGWBOmegaGWFlatSpectrum(
< 	double Omega0,	/**< [in] sgwb spectrum power (dimensionless) */
< 	double flow,	/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
< 	double deltaF,	/**< [in] frequency bin width (Hz) */
< 	size_t length	/**< [in] number of frequency bins */
< )
< {
< 	REAL8FrequencySeries *OmegaGW;
< 	LIGOTimeGPS epoch = {0, 0};
< 	size_t klow = flow / deltaF;
< 	size_t k;
< 	OmegaGW = XLALCreateREAL8FrequencySeries("OmegaGW", &epoch, 0.0, deltaF, &lalDimensionlessUnit, length);
< 	/* zero DC component */
< 	OmegaGW->data->data[0] = 0.0;
< 	/* zero up to low frequency cutoff */
< 	for (k = 1; k < klow; ++k)
< 		OmegaGW->data->data[k] = 0.0;
< 	/* set remaining components */
< 	for (; k < length - 1; ++k)
< 		OmegaGW->data->data[k] = Omega0;
< 	/* zero Nyquist component */
< 	OmegaGW->data->data[length - 1] = 0.0;
< 	return OmegaGW;
< }
< 
< 
< /**
<  * Creates a frequency series that contains a power law SGWB spectrum with the
<  * specified power Omegaref at reference frequency fref and specified power law
<  * power alpha above some low frequency cutoff flow.
<  */
< REAL8FrequencySeries *XLALSimSGWBOmegaGWPowerLawSpectrum(
< 	double Omegaref,	/**< [in] sgwb spectrum power at reference frequency (dimensionless) */
< 	double alpha,		/**< [in] sgwb spectrum power law power */
< 	double fref,		/**< [in] reference frequency (Hz) */
< 	double flow,		/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
< 	double deltaF,		/**< [in] frequency bin width (Hz) */
< 	size_t length		/**< [in] number of frequency bins */
< )
< {
< 	REAL8FrequencySeries *OmegaGW;
< 	LIGOTimeGPS epoch = {0, 0};
< 	size_t klow = flow / deltaF;
< 	size_t k;
< 	OmegaGW = XLALCreateREAL8FrequencySeries("OmegaGW", &epoch, 0.0, deltaF, &lalDimensionlessUnit, length);
< 	/* zero DC component */
< 	OmegaGW->data->data[0] = 0.0;
< 	/* zero up to low frequency cutoff */
< 	for (k = 1; k < klow; ++k)
< 		OmegaGW->data->data[k] = 0.0;
< 	/* set remaining components */
< 	for (; k < length - 1; ++k)
< 		OmegaGW->data->data[k] = Omegaref * pow(k * deltaF / fref, alpha);
< 	/* zero Nyquist component */
< 	OmegaGW->data->data[length - 1] = 0.0;
< 	return OmegaGW;
< }
< 
< 
196a133,202
> /**
>  * @addtogroup LALSimSGWB_c
>  * @brief Routines to compute a stochastic gravitational-wave background
>  * power spectrum and to produce a continuous stream of simulated
>  * gravitational-wave detector strain.
>  * @{
>  */
> 
> /**
>  * Creates a frequency series that contains a flat SGWB spectrum with the
>  * specified power Omega0 above some low frequency cutoff flow.
>  */
> REAL8FrequencySeries *XLALSimSGWBOmegaGWFlatSpectrum(
> 	double Omega0,	/**< [in] sgwb spectrum power (dimensionless) */
> 	double flow,	/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
> 	double deltaF,	/**< [in] frequency bin width (Hz) */
> 	size_t length	/**< [in] number of frequency bins */
> )
> {
> 	REAL8FrequencySeries *OmegaGW;
> 	LIGOTimeGPS epoch = {0, 0};
> 	size_t klow = flow / deltaF;
> 	size_t k;
> 	OmegaGW = XLALCreateREAL8FrequencySeries("OmegaGW", &epoch, 0.0, deltaF, &lalDimensionlessUnit, length);
> 	/* zero DC component */
> 	OmegaGW->data->data[0] = 0.0;
> 	/* zero up to low frequency cutoff */
> 	for (k = 1; k < klow; ++k)
> 		OmegaGW->data->data[k] = 0.0;
> 	/* set remaining components */
> 	for (; k < length - 1; ++k)
> 		OmegaGW->data->data[k] = Omega0;
> 	/* zero Nyquist component */
> 	OmegaGW->data->data[length - 1] = 0.0;
> 	return OmegaGW;
> }
> 
> 
> /**
>  * Creates a frequency series that contains a power law SGWB spectrum with the
>  * specified power Omegaref at reference frequency fref and specified power law
>  * power alpha above some low frequency cutoff flow.
>  */
> REAL8FrequencySeries *XLALSimSGWBOmegaGWPowerLawSpectrum(
> 	double Omegaref,	/**< [in] sgwb spectrum power at reference frequency (dimensionless) */
> 	double alpha,		/**< [in] sgwb spectrum power law power */
> 	double fref,		/**< [in] reference frequency (Hz) */
> 	double flow,		/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
> 	double deltaF,		/**< [in] frequency bin width (Hz) */
> 	size_t length		/**< [in] number of frequency bins */
> )
> {
> 	REAL8FrequencySeries *OmegaGW;
> 	LIGOTimeGPS epoch = {0, 0};
> 	size_t klow = flow / deltaF;
> 	size_t k;
> 	OmegaGW = XLALCreateREAL8FrequencySeries("OmegaGW", &epoch, 0.0, deltaF, &lalDimensionlessUnit, length);
> 	/* zero DC component */
> 	OmegaGW->data->data[0] = 0.0;
> 	/* zero up to low frequency cutoff */
> 	for (k = 1; k < klow; ++k)
> 		OmegaGW->data->data[k] = 0.0;
> 	/* set remaining components */
> 	for (; k < length - 1; ++k)
> 		OmegaGW->data->data[k] = Omegaref * pow(k * deltaF / fref, alpha);
> 	/* zero Nyquist component */
> 	OmegaGW->data->data[length - 1] = 0.0;
> 	return OmegaGW;
> }
> 
213c219
<  * \code
---
>  * @code
252c258
<  * \endcode
---
>  * @endcode
259,267c265,270
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
---
>  * @note
>  * - If stride = 0, initialize h by generating one (periodic) realization of
>  *   noise; subsequent calls should have non-zero stride.
>  * - If stride = h->data->length then generate one segment of non-periodic
>  *   noise by generating two different realizations and feathering them
>  *   together.
269c272
<  * Warning: only the first stride points are valid.
---
>  * @warning Only the first stride points are valid.
371c374
<  * \code
---
>  * @code
408c411
<  * \endcode
---
>  * @endcode
415c418,423
<  * Note:
---
>  * @note
>  * - If stride = 0, initialize h by generating one (periodic) realization of
>  *   noise; subsequent calls should have non-zero stride.
>  * - If stride = h->data->length then generate one segment of non-periodic
>  *   noise by generating two different realizations and feathering them
>  *   together.
417,425c425
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
<  *
<  * Warning: only the first stride points are valid.
---
>  * @warning Only the first stride points are valid.
472c472
<  * \code
---
>  * @code
511c511
<  * \endcode
---
>  * @endcode
518,526c518,523
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
---
>  * @note
>  * - If stride = 0, initialize h by generating one (periodic) realization of
>  *   noise; subsequent calls should have non-zero stride.
>  * - If stride = h->data->length then generate one segment of non-periodic
>  *   noise by generating two different realizations and feathering them
>  *   together.
528c525
<  * Warning: only the first stride points are valid.
---
>  * @warning Only the first stride points are valid.
558a556
> /** @} */
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimSGWB.h ./LALSimSGWB.h
33a34,44
> /**
>  * @defgroup LALSimSGWB_h Header LALSimSGWB.h
>  * @ingroup lalsimulation_stochastic
>  * @author Jolien Creighton
>  * @brief Routines for simulating a stochastic gravitational-wave background.
>  *
>  * @{
>  * @defgroup LALSimSGWB_c     Module LALSimSGWB.c
>  * @defgroup LALSimSGWBORF_c  Module LALSimSGWBORF.c
>  * @}
>  */
36,37d46
<  *
<  *
39,40c48
<  *
<  *
---
>  * in module LALSimSGWBORF.c
43,54c51
< 
< /**
<  * Computes the overlap reduction function between two detectors at a specified
<  * frequency.
<  *
<  * Implements the formulae given in Allen & Romano (1999).
<  */
< double XLALSimSGWBOverlapReductionFunction(
< 	double f,			/**< [in] frequency (Hz) */
< 	const LALDetector *detector1,	/**< [in] 1st detector */
< 	const LALDetector *detector2	/**< [in] 2nd detector */
< );
---
> double XLALSimSGWBOverlapReductionFunction(double f, const LALDetector *detector1, const LALDetector *detector2);
58,59d54
<  *
<  *
61,62c56
<  *
<  *
---
>  * in module LALSimSGWB.c
65,90c59,60
< 
< /**
<  * Creates a frequency series that contains a flat SGWB spectrum with the
<  * specified power Omega0 above some low frequency cutoff flow.
<  */
< REAL8FrequencySeries *XLALSimSGWBOmegaGWFlatSpectrum(
< 	double Omega0,	/**< [in] sgwb spectrum power (dimensionless) */
< 	double flow,	/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
< 	double deltaF,	/**< [in] frequency bin width (Hz) */
< 	size_t length	/**< [in] number of frequency bins */
< );
< 
< 
< /**
<  * Creates a frequency series that contains a power law SGWB spectrum with the
<  * specified power Omegaref at reference frequency fref and specified power law
<  * power alpha above some low frequency cutoff flow.
<  */
< REAL8FrequencySeries *XLALSimSGWBOmegaGWPowerLawSpectrum(
< 	double Omegaref,	/**< [in] sgwb spectrum power at reference frequency (dimensionless) */
< 	double alpha,		/**< [in] sgwb spectrum power law power */
< 	double fref,		/**< [in] reference frequency (Hz) */
< 	double flow,		/**< [in] low frequncy cutoff of SGWB spectrum (Hz) */
< 	double deltaF,		/**< [in] frequency bin width (Hz) */
< 	size_t length		/**< [in] number of frequency bins */
< );
---
> REAL8FrequencySeries *XLALSimSGWBOmegaGWFlatSpectrum(double Omega0, double flow, double deltaF, size_t length);
> REAL8FrequencySeries *XLALSimSGWBOmegaGWPowerLawSpectrum(double Omegaref, double alpha, double fref, double flow, double deltaF, size_t length);
94d63
<  *
96,338c65
<  *
<  */
< 
< /**
<  * Routine that may be used to generate sequential segments of stochastic
<  * background gravitational wave signals for a network of detectors with a
<  * specified stride from one segment to the next.
<  *
<  * The spectrum is specified by the frequency series OmegaGW.
<  *
<  * Calling instructions: for the first call, set stride = 0; subsequent calls
<  * should pass the same time series and have non-zero stride.  This routine
<  * will advance the time series by an amount given by the stride and will
<  * generate new data so that the data is continuous from one segment to the
<  * next.  For example: the following routine will output a continuous stream of
<  * stochastic background signals with a "flat" (OmegaGW = const) spectrum for
<  * the HLV network.
<  *
<  * \code
<  * #include <stdio.h>
<  * #include <gsl/gsl_rng.h>
<  * #include <lal/LALStdlib.h>
<  * #include <lal/LALDetectors.h>
<  * #include <lal/FrequencySeries.h>
<  * #include <lal/TimeSeries.h>
<  * #include <lal/Units.h>
<  * #include <lal/LALSimSGWB.h>
<  * int mksgwbdata(void)
<  * {
<  * 	const double flow = 40.0; // 40 Hz low frequency cutoff
<  * 	const double duration = 16.0; // 16 second segments
<  * 	const double srate = 16384.0; // sampling rate in Hertz
<  * 	const double Omega0 = 1e-6; // fraction of critical energy in GWs
<  * 	const double H0 = 0.72 * LAL_H0FAC_SI; // Hubble's constant in seconds
<  * 	const LALDetector H1 = lalCachedDetectors[LAL_LHO_4K_DETECTOR]; // Hanford
<  * 	const LALDetector L1 = lalCachedDetectors[LAL_LLO_4K_DETECTOR]; // Livingston
<  * 	const LALDetector V1 = lalCachedDetectors[LAL_VIRGO_DETECTOR]; // Virgo
<  * 	LALDetector detectors[3] = {H1, L1, V1}; // the network of detectors
<  * 	size_t length = duration * srate; // segment length
<  * 	size_t stride = length / 2; // stride between segments
<  * 	LIGOTimeGPS epoch = { 0, 0 };
<  * 	REAL8FrequencySeries *OmegaGW; // the spectrum of the SGWB
<  * 	REAL8TimeSeries *h[3]; // the strain induced in the network of detectors
<  * 	gsl_rng *rng;
<  * 	gsl_rng_env_setup();
<  * 	rng = gsl_rng_alloc(gsl_rng_default);
<  * 	h[0] = XLALCreateREAL8TimeSeries("H1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[1] = XLALCreateREAL8TimeSeries("L1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[2] = XLALCreateREAL8TimeSeries("V1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
< 	OmegaGW = XLALSimSGWBOmegaGWFlatSpectrum(Omega0, flow, deltaF, seglen/2 + 1);
<  * 	XLALSimSGWB(h, detectors, 3, 0, Omega0, flow, H0, rng); // first time to initialize
<  * 	while (1) { // infinite loop
<  * 		size_t j;
<  * 		for (j = 0; j < stride; ++j) // output first stride points
<  * 			printf("%.9f\t%e\t%e\t%e\n", XLALGPSGetREAL8(&h[0]->epoch) + j / srate, h[0]->data->data[j], h[1]->data->data[j], h[2]->data->data[j]);
<  * 		XLALSimSGWB(h, detectors, 3, stride, Omega0, flow, H0, rng); // make more data
<  * 	}
<  * \endcode
<  *
<  * If only one single segment of data is required, set stride to be the length
<  * of the timeseries data vector.  This will make a single segment of data
<  * that is *not* periodic (also, in this case it will not advance the epoch of
<  * the timeseries).
<  *
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
<  *
<  * Warning: only the first stride points are valid.
<  */
< int XLALSimSGWB(
< 	REAL8TimeSeries **h,			/**< [in/out] array of sgwb timeseries for detector network */
< 	const LALDetector *detectors,		/**< [in] array of detectors in network */
< 	size_t numDetectors,			/**< [in] number of detectors in network */
< 	size_t stride,				/**< [in] stride (samples) */
< 	const REAL8FrequencySeries *OmegaGW,	/**< [in] sgwb spectrum frequeny series */
< 	double H0,				/**< [in] Hubble's constant (s) */
< 	gsl_rng *rng				/**< [in] GSL random number generator */
< );
< 
< /**
<  * Routine that may be used to generate sequential segments of stochastic
<  * background gravitational wave signals for a network of detectors with a
<  * specified stride from one segment to the next.
<  *
<  * The spectrum is flat for frequencies above flow with power given by Omega0,
<  * and zero for frequencies below the low frequency cutoff flow.
<  *
<  * Calling instructions: for the first call, set stride = 0; subsequent calls
<  * should pass the same time series and have non-zero stride.  This routine
<  * will advance the time series by an amount given by the stride and will
<  * generate new data so that the data is continuous from one segment to the
<  * next.  For example: the following routine will output a continuous stream of
<  * stochastic background signals with a "flat" (OmegaGW = const) spectrum for
<  * the HLV network.
<  *
<  * \code
<  * #include <stdio.h>
<  * #include <gsl/gsl_rng.h>
<  * #include <lal/LALStdlib.h>
<  * #include <lal/LALDetectors.h>
<  * #include <lal/FrequencySeries.h>
<  * #include <lal/TimeSeries.h>
<  * #include <lal/Units.h>
<  * #include <lal/LALSimSGWB.h>
<  * int mkgwbdata_flat(void)
<  * {
<  * 	const double flow = 40.0; // 40 Hz low frequency cutoff
<  * 	const double duration = 16.0; // 16 second segments
<  * 	const double srate = 16384.0; // sampling rate in Hertz
<  * 	const double Omega0 = 1e-6; // fraction of critical energy in GWs
<  * 	const double H0 = 0.72 * LAL_H0FAC_SI; // Hubble's constant in seconds
<  * 	const LALDetector H1 = lalCachedDetectors[LAL_LHO_4K_DETECTOR]; // Hanford
<  * 	const LALDetector L1 = lalCachedDetectors[LAL_LLO_4K_DETECTOR]; // Livingston
<  * 	const LALDetector V1 = lalCachedDetectors[LAL_VIRGO_DETECTOR]; // Virgo
<  * 	LALDetector detectors[3] = {H1, L1, V1}; // the network of detectors
<  * 	size_t length = duration * srate; // segment length
<  * 	size_t stride = length / 2; // stride between segments
<  * 	LIGOTimeGPS epoch = { 0, 0 };
<  * 	REAL8TimeSeries *h[3]; // the strain induced in the network of detectors
<  * 	gsl_rng *rng;
<  * 	gsl_rng_env_setup();
<  * 	rng = gsl_rng_alloc(gsl_rng_default);
<  * 	h[0] = XLALCreateREAL8TimeSeries("H1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[1] = XLALCreateREAL8TimeSeries("L1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[2] = XLALCreateREAL8TimeSeries("V1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	XLALSimSGWBFlatSpectrum(h, detectors, 3, 0, Omega0, flow, H0, rng); // first time to initialize
<  * 	while (1) { // infinite loop
<  * 		size_t j;
<  * 		for (j = 0; j < stride; ++j) // output first stride points
<  * 			printf("%.9f\t%e\t%e\t%e\n", XLALGPSGetREAL8(&h[0]->epoch) + j / srate, h[0]->data->data[j], h[1]->data->data[j], h[2]->data->data[j]);
<  * 		XLALSimSGWBFlatSpectrum(h, detectors, 3, stride, Omega0, flow, H0, rng); // make more data
<  * 	}
<  * \endcode
<  *
<  * If only one single segment of data is required, set stride to be the length
<  * of the timeseries data vector.  This will make a single segment of data
<  * that is *not* periodic (also, in this case it will not advance the epoch of
<  * the timeseries).
<  *
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
<  *
<  * Warning: only the first stride points are valid.
<  */
< int XLALSimSGWBFlatSpectrum(
< 	REAL8TimeSeries **h,			/**< [in/out] array of sgwb timeseries for detector network */
< 	const LALDetector *detectors,		/**< [in] array of detectors in network */
< 	size_t numDetectors,			/**< [in] number of detectors in network */
< 	size_t stride,				/**< [in] stride (samples) */
< 	double Omega0,				/**< [in] flat sgwb spectrum power (dimensionless) */
< 	double flow,				/**< [in] low frequency cutoff (Hz) */
< 	double H0,				/**< [in] Hubble's constant (s) */
< 	gsl_rng *rng				/**< [in] GSL random number generator */
< );
< 
< /**
<  * Routine that may be used to generate sequential segments of stochastic
<  * background gravitational wave signals for a network of detectors with a
<  * specified stride from one segment to the next.
<  *
<  * The spectrum is a power law with power alpha for frequencies above flow with
<  * power given by Omegaref at the reference frequency fref, and zero for
<  * frequencies below the low frequency cutoff flow.
<  *
<  * Calling instructions: for the first call, set stride = 0; subsequent calls
<  * should pass the same time series and have non-zero stride.  This routine
<  * will advance the time series by an amount given by the stride and will
<  * generate new data so that the data is continuous from one segment to the
<  * next.  For example: the following routine will output a continuous stream of
<  * stochastic background signals with a "flat" (OmegaGW = const) spectrum for
<  * the HLV network.
<  *
<  * \code
<  * #include <stdio.h>
<  * #include <gsl/gsl_rng.h>
<  * #include <lal/LALStdlib.h>
<  * #include <lal/LALDetectors.h>
<  * #include <lal/FrequencySeries.h>
<  * #include <lal/TimeSeries.h>
<  * #include <lal/Units.h>
<  * #include <lal/LALSimSGWB.h>
<  * int mksgwbdata_powerlaw(void)
<  * {
<  * 	const double flow = 40.0; // 40 Hz low frequency cutoff
<  * 	const double duration = 16.0; // 16 second segments
<  * 	const double srate = 16384.0; // sampling rate in Hertz
<  * 	const double Omegaref = 1e-6; // fraction of critical energy in GWs
<  * 	const double fref = 100; // reference frequency in Hertz
<  * 	const double alpha = 3.0; // sgwb spectrum power law power
<  * 	const double H0 = 0.72 * LAL_H0FAC_SI; // Hubble's constant in seconds
<  * 	const LALDetector H1 = lalCachedDetectors[LAL_LHO_4K_DETECTOR]; // Hanford
<  * 	const LALDetector L1 = lalCachedDetectors[LAL_LLO_4K_DETECTOR]; // Livingston
<  * 	const LALDetector V1 = lalCachedDetectors[LAL_VIRGO_DETECTOR]; // Virgo
<  * 	LALDetector detectors[3] = {H1, L1, V1}; // the network of detectors
<  * 	size_t length = duration * srate; // segment length
<  * 	size_t stride = length / 2; // stride between segments
<  * 	LIGOTimeGPS epoch = { 0, 0 };
<  * 	REAL8TimeSeries *h[3]; // the strain induced in the network of detectors
<  * 	gsl_rng *rng;
<  * 	gsl_rng_env_setup();
<  * 	rng = gsl_rng_alloc(gsl_rng_default);
<  * 	h[0] = XLALCreateREAL8TimeSeries("H1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[1] = XLALCreateREAL8TimeSeries("L1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	h[2] = XLALCreateREAL8TimeSeries("V1:STRAIN", &epoch, 0.0, 1.0/srate, &lalStrainUnit, length);
<  * 	XLALSimSGWBPowerLawSpectrum(h, detectors, 3, 0, Omegaref, alpha, fref, flow, H0, rng); // first time to initialize
<  * 	while (1) { // infinite loop
<  * 		size_t j;
<  * 		for (j = 0; j < stride; ++j) // output first stride points
<  * 			printf("%.9f\t%e\t%e\t%e\n", XLALGPSGetREAL8(&h[0]->epoch) + j / srate, h[0]->data->data[j], h[1]->data->data[j], h[2]->data->data[j]);
<  * 		XLALSimSGWBPowerLawSpectrum(h, detectors, 3, stride, Omegaref, alpha, fref, flow, H0, rng); // make more data
<  * 	}
<  * \endcode
<  *
<  * If only one single segment of data is required, set stride to be the length
<  * of the timeseries data vector.  This will make a single segment of data
<  * that is *not* periodic (also, in this case it will not advance the epoch of
<  * the timeseries).
<  *
<  * Note:
<  *
<  * - If stride = 0, initialize h by generating one (periodic)
<  * realization of noise; subsequent calls should have non-zero
<  * stride.
<  *
<  * - If stride = h->data->length then generate one segment of
<  * non-periodic noise by generating two different realizations
<  * and feathering them together.
<  *
<  * Warning: only the first stride points are valid.
---
>  * in module LALSimSGWB.c
340,351d66
< int XLALSimSGWBPowerLawSpectrum(
< 	REAL8TimeSeries **h,			/**< [in/out] array of sgwb timeseries for detector network */
< 	const LALDetector *detectors,		/**< [in] array of detectors in network */
< 	size_t numDetectors,			/**< [in] number of detectors in network */
< 	size_t stride,				/**< [in] stride (samples) */
< 	double Omegaref,			/**< [in] sgwb spectrum power at reference frequency (dimensionless) */
< 	double alpha,				/**< [in] sgwb spectrum power power law */
< 	double fref,				/**< [in] sgwb spectrum reference frequency (Hz) */
< 	double flow,				/**< [in] low frequency cutoff (Hz) */
< 	double H0,				/**< [in] Hubble's constant (s) */
< 	gsl_rng *rng				/**< [in] GSL random number generator */
< );
352a68,70
> int XLALSimSGWB(REAL8TimeSeries **h, const LALDetector *detectors, size_t numDetectors, size_t stride, const REAL8FrequencySeries *OmegaGW, double H0, gsl_rng *rng);
> int XLALSimSGWBFlatSpectrum(REAL8TimeSeries **h, const LALDetector *detectors, size_t numDetectors, size_t stride, double Omega0, double flow, double H0, gsl_rng *rng);
> int XLALSimSGWBPowerLawSpectrum(REAL8TimeSeries **h, const LALDetector *detectors, size_t numDetectors, size_t stride, double Omegaref, double alpha, double fref, double flow, double H0, gsl_rng *rng);
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSGWB.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSGWB.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimSGWBORF.c ./LALSimSGWBORF.c
26a27,32
> /**
>  * @addtogroup LALSimSGWBORF_c
>  * @brief Routines to compute the Overlap Reduction Function for stochastic
>  * background gravitational waves between two detectors.
>  * @{
>  */
107a114
> /** @} */
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSGWBORF.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSGWBORF.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSphHarmMode.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSphHarmMode.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSphHarmSeries.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimSphHarmSeries.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulationBuildInfo.c
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulationBuildInfo.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulationBuildInfo.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimulationConfig.h ./LALSimulationConfig.h
6c6
< #define LALSIMULATION_VERSION "1.4.0.1"
---
> #define LALSIMULATION_VERSION "1.4.1.1"
15c15
< #define LALSIMULATION_VERSION_MICRO 0
---
> #define LALSIMULATION_VERSION_MICRO 1
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimulation.h ./LALSimulation.h
52a53,128
>  *
>  * ### Coordinate Systems
>  *
>  * The diagram below illustrates the relationship between the wave frame
>  * (X,Y,Z) and the Earth's equatorial frame.  The Earth is at the origin
>  * of the diagram with its North pole in the direction indicated by N.
>  *
>  * @anchor lalsimulation_inject
>  * @image html lalsimulation_inject.svg "Injection Coordinates"
>  *
>  * The gravitational wave travels in the Z-direction in this diagram,
>  * and the reference direction on the wave-plane (the X-Y-plane) is
>  * given by the X-axis.  Note that the direction to the source is in
>  * the negative Z direction.
>  *
>  * The plus- and cross-polarizations of the gravitational waveform are defined
>  * in this wave frame.  Specifically, if \f$ h^{ij} \f$ is the metric
>  * perturbation, then
>  * \f[ h_+ = \frac12 ( \hat{p}_i \hat{p}_j - \hat{q}_i \hat{q}_j ) h^{ij} \f]
>  * and
>  * \f[ h_\times = \frac12 ( \hat{p}_i \hat{q}_j + \hat{q}_i \hat{p}_j ) h^{ij} \f]
>  * where \f$ \hat{p}_i \f$ are the components of the unit vector pointing
>  * along the X-axis and \f$ \hat{q}_i \f$ are the components of the unit
>  * vector pointing along the Y-axis.
>  *
>  * The angles relating the wave frame to the equatorial frame are:
>  *
>  *  * Declination (&delta;).  The angle along the hour circle passing through
>  *    the source between the equatorial plane and the source.  It is positive
>  *    for a source that is north of the equatorial plane and negative for
>  *    a source that is south of the equatorial plane.  The hour circle passing
>  *    through the source is the great arc on the celestial sphere that passes
>  *    through the north celestial pole (marked as N in the diagram), the
>  *    source, and the south celestial pole.
>  *
>  *    Note that the diagram depicts a source having a negative declination.
>  *
>  *  * Right ascension (&alpha;).  The angle from the vernal equinox
>  *    @htmlonly &#x2648; @endhtmlonly to the hour circle passing through
>  *    the source.  The angle is measured counter-clockwise about the axis
>  *    pointing toward the north celestial pole.
>  *
>  *  * Greenwich sidereal time (GST).  The right ascension of the prime
>  *    meridian at the time of arrival of the signal.
>  *
>  *  * Greenwich hour angle (GHA).  The angle along the equatorial plane between
>  *    the prime meridian and the hour circle containing the source.  This
>  *    angle is measured @e clockwise about the axis pointing toward the
>  *    north celestial pole.
>  *
>  *    The right ascension, Greenwich hour angle, and Greenwich sidereal time
>  *    are related by GHA = GST - &alpha;.
>  *
>  *  * Polarization angle (&psi;).  The angle from the ascending line of
>  *    nodes to the X-axis of the wave plane.  The angle is measured counter
>  *    clockwise about the Z-axis of the wave plane.
>  *
>  * @sa
>  * A complete description of the coordinate conventions adopted here can be
>  * found in
>  * > Warren Anderson, Patrick Brady, David Chin, Jolien Creighton, Keith Riles,
>  * > and John Whelan,
>  * > "Beam Pattern Response Functions and Times of Arrival for Earthbound
>  * > Interferometer",
>  * > LIGO Technical Document LIGO-T010110-v1 (2009)
>  * > https://dcc.ligo.org/LIGO-T010110/public
>  *
>  * @sa
>  * The conventions are also described in Appendix B of
>  * > Warren G. Anderson, Patrick R. Brady, Jolien D. E. Creighton, and Eanna E.
>  * > Flanagan,
>  * > "Excess power statistic for detection of burst sources of gravitational
>  * > radiation",
>  * > Phys. Rev. D @b 63, 042003 (2001)
>  * > http://dx.doi.org/10.1103/PhysRevD.63.042003
>  * > http://arxiv.org/abs/gr-qc/0008066
Only in .: lalsimulation_inject.svg
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulation.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulation.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/LALSimulationVCSInfoHeader.h ./LALSimulationVCSInfoHeader.h
36,38c36,38
< #define LALSIMULATION_VCS_ID "28bd665ba829b9626f90fc1823412de4362ad688"
< #define LALSIMULATION_VCS_DATE "2015-08-20 20:20:35 +0000"
< #define LALSIMULATION_VCS_BRANCH "printing_stuff"
---
> #define LALSIMULATION_VCS_ID "9f6c4496495f9d19ad4484ac5b3c01b5db3b2ada"
> #define LALSIMULATION_VCS_DATE "2015-12-23 04:47:53 +0000"
> #define LALSIMULATION_VCS_BRANCH "devel"
40,41c40,41
< #define LALSIMULATION_VCS_AUTHOR "Swetha Bhagwat <swetha.bhagwat@ligo.org>"
< #define LALSIMULATION_VCS_COMMITTER "Swetha Bhagwat <swetha.bhagwat@ligo.org>"
---
> #define LALSIMULATION_VCS_AUTHOR "Evan Goetz <evan.goetz@ligo.org>"
> #define LALSIMULATION_VCS_COMMITTER "Evan Goetz <evan.goetz@ligo.org>"
45,47c45,47
< #define LALSIMULATION_VCS_IDENT_ID "$" "LALSimulationId: 28bd665ba829b9626f90fc1823412de4362ad688 " "$"
< #define LALSIMULATION_VCS_IDENT_DATE "$" "LALSimulationDate: 2015-08-20 20:20:35 +0000 " "$"
< #define LALSIMULATION_VCS_IDENT_BRANCH "$" "LALSimulationBranch: printing_stuff " "$"
---
> #define LALSIMULATION_VCS_IDENT_ID "$" "LALSimulationId: 9f6c4496495f9d19ad4484ac5b3c01b5db3b2ada " "$"
> #define LALSIMULATION_VCS_IDENT_DATE "$" "LALSimulationDate: 2015-12-23 04:47:53 +0000 " "$"
> #define LALSIMULATION_VCS_IDENT_BRANCH "$" "LALSimulationBranch: devel " "$"
49,50c49,50
< #define LALSIMULATION_VCS_IDENT_AUTHOR "$" "LALSimulationAuthor: Swetha Bhagwat <swetha.bhagwat@ligo.org> " "$"
< #define LALSIMULATION_VCS_IDENT_COMMITTER "$" "LALSimulationCommitter: Swetha Bhagwat <swetha.bhagwat@ligo.org> " "$"
---
> #define LALSIMULATION_VCS_IDENT_AUTHOR "$" "LALSimulationAuthor: Evan Goetz <evan.goetz@ligo.org> " "$"
> #define LALSIMULATION_VCS_IDENT_COMMITTER "$" "LALSimulationCommitter: Evan Goetz <evan.goetz@ligo.org> " "$"
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulationVCSInfo.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimulationVCSInfo.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: lalsim-unicorn
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimUnicorn.lo
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: LALSimUnicorn.o
Only in .: LALSimUtils.c
Only in .: LALSimUtils.h
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: liblalsimulation.la
Common subdirectories: /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/.libs and ./.libs
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/Makefile ./Makefile
49,53c49,54
< 	lalsim-bh-sphwf$(EXEEXT) lalsim-detector-noise$(EXEEXT) \
< 	lalsim-detector-strain$(EXEEXT) lalsim-inject$(EXEEXT) \
< 	lalsim-inspiral$(EXEEXT) lalsim-ns-eos-table$(EXEEXT) \
< 	lalsim-ns-mass-radius$(EXEEXT) lalsim-ns-params$(EXEEXT) \
< 	lalsim-sgwb$(EXEEXT) lalsim-unicorn$(EXEEXT)
---
> 	lalsim-bh-sphwf$(EXEEXT) lalsim-burst$(EXEEXT) \
> 	lalsim-detector-noise$(EXEEXT) lalsim-detector-strain$(EXEEXT) \
> 	lalsim-inject$(EXEEXT) lalsim-inspiral$(EXEEXT) \
> 	lalsim-ns-eos-table$(EXEEXT) lalsim-ns-mass-radius$(EXEEXT) \
> 	lalsim-ns-params$(EXEEXT) lalsim-sgwb$(EXEEXT) \
> 	lalsim-unicorn$(EXEEXT)
99c100
< 	LALSimIMRSEOBNRv1ROMEffectiveSpin.lo \
---
> 	LALSimIMRSpinPrecEOB.lo LALSimIMRSEOBNRv1ROMEffectiveSpin.lo \
103,109c104,112
< 	LALSimIMRSEOBNRv2ChirpTime.lo LALSimIMRPhenom.lo \
< 	LALSimIMRPhenomC.lo LALSimIMRPhenomD.lo LALSimIMRPhenomP.lo \
< 	LALSimIMRPSpinInspiralRD.lo LALSimPhenSpinRingDown.lo \
< 	LALSimInspiralWaveformFlags.lo LALSimInspiralTestGRParams.lo \
< 	LALSimInspiralPrecess.lo LALSimInspiral.lo \
< 	LALSimInspiralPNMode.lo LALSimInspiralSpinTaylor.lo \
< 	LALSimInspiralSpinTaylorF2.lo LALSimInspiralEccentricityFD.lo \
---
> 	LALSimIMRSEOBNRv2ROMDoubleSpinHI.lo \
> 	LALSimIMRSEOBNRv2ChirpTime.lo LALSimIMREOBNRv2HMROM.lo \
> 	LALSimIMRPhenom.lo LALSimIMRPhenomC.lo LALSimIMRPhenomD.lo \
> 	LALSimIMRPhenomP.lo LALSimIMRPSpinInspiralRD.lo \
> 	LALSimPhenSpinRingDown.lo LALSimInspiralWaveformFlags.lo \
> 	LALSimInspiralTestGRParams.lo LALSimInspiralPrecess.lo \
> 	LALSimInspiral.lo LALSimInspiralPNMode.lo \
> 	LALSimInspiralSpinTaylor.lo LALSimInspiralSpinTaylorF2.lo \
> 	LALSimInspiralEccentricityFD.lo \
120,126c123,129
< 	LALSimInspiralWaveformTaper.lo LALSimulation.lo \
< 	LALSimulationVCSInfo.lo LALSimNeutronStarEOS.lo \
< 	LALSimNeutronStarFamily.lo LALSimNeutronStarTOV.lo \
< 	LALSimNoisePSD.lo LALSimNoise.lo LALSimReadData.lo \
< 	LALSimSGWB.lo LALSimSGWBORF.lo LALSimSphHarmMode.lo \
< 	LALSimSphHarmSeries.lo LALSimUnicorn.lo \
< 	LALSimInspiralHGimri.lo
---
> 	LALSimInspiralWaveformTaper.lo LALSimIMRNRWaveforms.lo \
> 	LALSimulation.lo LALSimulationVCSInfo.lo \
> 	LALSimNeutronStarEOS.lo LALSimNeutronStarFamily.lo \
> 	LALSimNeutronStarTOV.lo LALSimNoisePSD.lo LALSimNoise.lo \
> 	LALSimReadData.lo LALSimSGWB.lo LALSimSGWBORF.lo \
> 	LALSimSphHarmMode.lo LALSimSphHarmSeries.lo LALSimUnicorn.lo \
> 	LALSimUtils.lo LALSimInspiralHGimri.lo LALSimFindAttachTime.lo
149a153,156
> am_lalsim_burst_OBJECTS = burst.$(OBJEXT)
> lalsim_burst_OBJECTS = $(am_lalsim_burst_OBJECTS)
> lalsim_burst_LDADD = $(LDADD)
> lalsim_burst_DEPENDENCIES = liblalsimulation.la
215c222,223
< 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_detector_noise_SOURCES) \
---
> 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_burst_SOURCES) \
> 	$(lalsim_detector_noise_SOURCES) \
222c230,231
< 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_detector_noise_SOURCES) \
---
> 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_burst_SOURCES) \
> 	$(lalsim_detector_noise_SOURCES) \
226a236,242
> RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
> 	html-recursive info-recursive install-data-recursive \
> 	install-dvi-recursive install-exec-recursive \
> 	install-html-recursive install-info-recursive \
> 	install-pdf-recursive install-ps-recursive install-recursive \
> 	installcheck-recursive installdirs-recursive pdf-recursive \
> 	ps-recursive uninstall-recursive
228a245,249
> RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
>   distclean-recursive maintainer-clean-recursive
> AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
> 	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
> 	distdir
230a252
> DIST_SUBDIRS = $(SUBDIRS)
231a254,278
> am__relativize = \
>   dir0=`pwd`; \
>   sed_first='s,^\([^/]*\)/.*$$,\1,'; \
>   sed_rest='s,^[^/]*/*,,'; \
>   sed_last='s,^.*/\([^/]*\)$$,\1,'; \
>   sed_butlast='s,/*[^/]*$$,,'; \
>   while test -n "$$dir1"; do \
>     first=`echo "$$dir1" | sed -e "$$sed_first"`; \
>     if test "$$first" != "."; then \
>       if test "$$first" = ".."; then \
>         dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
>         dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
>       else \
>         first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
>         if test "$$first2" = "$$first"; then \
>           dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
>         else \
>           dir2="../$$dir2"; \
>         fi; \
>         dir0="$$dir0"/"$$first"; \
>       fi; \
>     fi; \
>     dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
>   done; \
>   reldir="$$dir2"
233,236c280,283
< ACLOCAL = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run aclocal-1.11
< AMTAR = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run tar
< AM_CFLAGS =   -O2 -g  -Wno-unknown-pragmas  -g3 -Wall -W -Werror -Wmissing-prototypes -Wstrict-prototypes -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align -Wwrite-strings -fno-common -Wnested-externs -Wno-format-zero-length -fno-strict-aliasing -Wno-unused-result -Wno-unknown-pragmas 
< AM_CPPFLAGS = -I$(top_builddir)/include -DPKG_DATA_DIR='"$(pkgdatadir)/"'  -I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include   -D_ISOC99_SOURCE 
---
> ACLOCAL = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run aclocal-1.11
> AMTAR = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run tar
> AM_CFLAGS =   -O2 -g  -fopenmp  -g3 -Wall -W -Werror -Wmissing-prototypes -Wstrict-prototypes -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align -Wwrite-strings -fno-common -Wnested-externs -Wno-format-zero-length -fno-strict-aliasing -Wno-unused-result -Wno-unknown-pragmas 
> AM_CPPFLAGS = -I$(top_builddir)/include -DPKG_DATA_DIR='"$(pkgdatadir)/"'  -I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include   -D_ISOC99_SOURCE 
243,245c290,292
< AUTOCONF = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run autoconf
< AUTOHEADER = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run autoheader
< AUTOMAKE = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run automake-1.11
---
> AUTOCONF = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run autoconf
> AUTOHEADER = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run autoheader
> AUTOMAKE = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run automake-1.11
246a294
> BIBTEX = 
259c307
< DISTCHECK_CONFIGURE_FLAGS =  '--disable-option-checking' '--enable-swig-python' 'LAL_DATA_PATH=$(top_srcdir)/../lal/test' 'LAL_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave' 'LAL_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python' 'LALSUITE_BUILD=true' 'PKG_CONFIG_PATH=/opt/lscsoft/gst/lib64/pkgconfig:' 'LAL_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include' 'LAL_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/liblal.la' 'LAL_HTMLDIR=${docdir}/../lal' 'LALSUPPORT_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include' 'LALSUPPORT_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/support/liblalsupport.la' 'LALSUPPORT_DATA_PATH=$(top_srcdir)/../lal/test' 'LALSUPPORT_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave' 'LALSUPPORT_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python' 'LALSUPPORT_HTMLDIR=${docdir}/../lal'
---
> DISTCHECK_CONFIGURE_FLAGS =  '--disable-option-checking' '--enable-swig-python' '--enable-mpi' '--enable-openmp' '--disable-lalstochastic' '--disable-laldetchar' 'LAL_DATA_PATH=$(top_srcdir)/../lal/test' 'LAL_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave' 'LAL_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python' 'LALSUITE_BUILD=true' 'PKG_CONFIG_PATH=/opt/lscsoft/gst/lib64/pkgconfig:' 'LAL_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include' 'LAL_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/liblal.la' 'LAL_HTMLDIR=${docdir}/../lal' 'LALSUPPORT_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include' 'LALSUPPORT_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/support/liblalsupport.la' 'LALSUPPORT_DATA_PATH=$(top_srcdir)/../lal/test' 'LALSUPPORT_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave' 'LALSUPPORT_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python' 'LALSUPPORT_HTMLDIR=${docdir}/../lal'
287c335
< LALSUPPORT_CFLAGS = -I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include
---
> LALSUPPORT_CFLAGS = -I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include
290,292c338,340
< LALSUPPORT_LIBS = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/support/liblalsupport.la
< LALSUPPORT_OCTAVE_PATH = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave
< LALSUPPORT_PYTHON_PATH = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python
---
> LALSUPPORT_LIBS = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/support/liblalsupport.la
> LALSUPPORT_OCTAVE_PATH = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave
> LALSUPPORT_PYTHON_PATH = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python
294c342
< LAL_CFLAGS = -I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include
---
> LAL_CFLAGS = -I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include
297,299c345,347
< LAL_LIBS = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/liblal.la
< LAL_OCTAVE_PATH = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave
< LAL_PYTHON_PATH = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python
---
> LAL_LIBS = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/liblal.la
> LAL_OCTAVE_PATH = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave
> LAL_PYTHON_PATH = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python
308,309c356,357
< LIBREVISION = 0
< LIBS =  /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/support/liblalsupport.la  /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/liblal.la -lgsl -lgslcblas  -lgsl -lgslcblas -lm -lm 
---
> LIBREVISION = 1
> LIBS =  /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/support/liblalsupport.la  /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/liblal.la -lgsl -lgslcblas  -lgsl -lgslcblas -lm -lm 
311c359
< LIBVERSION = 12:0:0
---
> LIBVERSION = 12:1:0
316c364
< MAKEINFO = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/missing --run makeinfo
---
> MAKEINFO = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/missing --run makeinfo
325c373
< OPENMP_CFLAGS = 
---
> OPENMP_CFLAGS = -fopenmp
334c382
< PACKAGE_STRING = LALSimulation 1.4.0.1
---
> PACKAGE_STRING = LALSimulation 1.4.1.1
336c384
< PACKAGE_VERSION = 1.4.0.1
---
> PACKAGE_VERSION = 1.4.1.1
337a386
> PERL = 
341c390
< PYTHON = /usr/bin/python
---
> PYTHON = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/bin/python
351,352c400,401
< SWIG = /usr/bin/swig
< SWIG_CPPFLAGS =  -I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include -D_ISOC99_SOURCE
---
> SWIG = env CCACHE_DISABLE=1 /usr/bin/swig
> SWIG_CPPFLAGS =  -I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include -D_ISOC99_SOURCE
361,362c410,411
< SWIG_PYTHON_CPPFLAGS =  -I/usr/include/python2.6 -I/usr/include/python2.6 -I/home/swetha.bhagwat/.local/lib/python2.6/site-packages/numpy/core/include -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -DSWIGLAL_HAVE_NPY_ARRAY_WRITEABLE -DSWIGLAL_HAVE_PyArray_SetBaseObject
< SWIG_PYTHON_LDFLAGS =  -Wl,-export-dynamic -L/usr/lib/python2.6/site-packages -L/usr/lib64/python2.6/site-packages -L/usr/lib64/python2.6
---
> SWIG_PYTHON_CPPFLAGS =  -I/usr/include/python2.6 -I/usr/include/python2.6 -I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/lib/python2.6/site-packages/numpy/core/include -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -DSWIGLAL_HAVE_NPY_ARRAY_WRITEABLE -DSWIGLAL_HAVE_PyArray_SetBaseObject
> SWIG_PYTHON_LDFLAGS =  -Wl,-export-dynamic -L/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/lib/python2.6/site-packages -L/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/lib64/python2.6/site-packages -L/usr/lib64/python2.6
365,370c414,419
< VERSION = 1.4.0.1
< abs_builddir = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src
< abs_srcdir = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src
< abs_top_builddir = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation
< abs_top_srcdir = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation
< ac_configure_args =  '--disable-option-checking' '--prefix=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/install_2' '--enable-swig-python' '--cache-file=/dev/null' '--srcdir=.' 'LAL_DATA_PATH=$(top_srcdir)/../lal/test' 'LAL_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave' 'LAL_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python' 'LALSUITE_BUILD=true' 'PKG_CONFIG_PATH=/opt/lscsoft/gst/lib64/pkgconfig:' 'LAL_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include' 'LAL_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/liblal.la' 'LAL_HTMLDIR=${docdir}/../lal' 'LALSUPPORT_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/include' 'LALSUPPORT_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/src/support/liblalsupport.la' 'LALSUPPORT_DATA_PATH=$(top_srcdir)/../lal/test' 'LALSUPPORT_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/octave' 'LALSUPPORT_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lal/python' 'LALSUPPORT_HTMLDIR=${docdir}/../lal'
---
> VERSION = 1.4.1.1
> abs_builddir = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/src
> abs_srcdir = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/src
> abs_top_builddir = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation
> abs_top_srcdir = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation
> ac_configure_args =  '--disable-option-checking' '--prefix=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/opt/lalsuite' '--enable-swig-python' '--enable-mpi' '--enable-openmp' '--disable-lalstochastic' '--disable-laldetchar' '--cache-file=/dev/null' '--srcdir=.' 'LAL_DATA_PATH=$(top_srcdir)/../lal/test' 'LAL_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave' 'LAL_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python' 'LALSUITE_BUILD=true' 'PKG_CONFIG_PATH=/opt/lscsoft/gst/lib64/pkgconfig:' 'LAL_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include' 'LAL_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/liblal.la' 'LAL_HTMLDIR=${docdir}/../lal' 'LALSUPPORT_CFLAGS=-I/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/include' 'LALSUPPORT_LIBS=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/src/support/liblalsupport.la' 'LALSUPPORT_DATA_PATH=$(top_srcdir)/../lal/test' 'LALSUPPORT_OCTAVE_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/octave' 'LALSUPPORT_PYTHON_PATH=/home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lal/python' 'LALSUPPORT_HTMLDIR=${docdir}/../lal'
388c437
< configure_date = 2015-12-22T05:15:21-0500
---
> configure_date = 2015-12-23T00:23:44-0500
402c451
< install_sh = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/gnuscripts/install-sh
---
> install_sh = ${SHELL} /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/src/lalsuite/lalsimulation/gnuscripts/install-sh
414c463
< prefix = /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/install_2
---
> prefix = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev/opt/lalsuite
418,419c467,468
< python_exec_prefix = /usr
< python_prefix = /usr
---
> python_exec_prefix = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev
> python_prefix = /home/swetha.bhagwat/Projects/TidalEOB/Adding_Tidal_effect/teob_dev
430a480,483
> SUBDIRS = \
> 	mathematica_codes \
> 	$(END_OF_LIST)
> 
475a529
> 	LALSimUtils.h \
478,480c532
< 	LALSimulationVCSInfoHeader.h \
< 	LALSimIMREOBNRv2.h \
< 	LALSimIMRTNSEOBFactorizedWaveform.c 
---
> 	LALSimulationVCSInfoHeader.h
485a538,540
> 	LALSimIMREOBNRv2.h \
> 	LALSimIMRTNSEOB.h \
> 	LALSimFindAttachTime.h\
489a545,546
> 	LALSimIMRSpinEOBHamiltonianOptimized.c \
> 	LALSimIMRSpinEOBComputeAmpPhasefromEOMSoln.c \
490a548
> 	LALSimIMRSpinEOBHcapExactDerivative.c \
491a550,551
> 	LALSimIMRSpinAlignedEOBHcapDerivativeOptimized.c \
> 	LALSimIMRSpinAlignedEOBGSLOptimizedInterpolation.c \
496d555
<         LALSimIMRTNSEOBFactorizedFlux.c \
497a557
> 	LALSimIMRSpinEOBFactorizedFluxOptimized.c \
501a562
> 	LALSimIMRPhenomC_internals.h \
502a564
> 	LALSimIMRPhenomD_internals.h \
505c567,579
< 	LALSimIMRSEOBNRROMUtilities.c
---
> 	LALSimIMRPhenomP.h \
> 	LALSimIMRSEOBNRROMUtilities.c \
> 	LALSimIMREOBNRv2HMROMUtilities.c \
> 	LALSimBlackHoleRingdownPrec.c \
> 	LALSimBlackHoleRingdownPrec.h \
> 	LALSimIMRSpinEOBFactorizedWaveformPrec.c \
> 	LALSimIMRSpinEOBHamiltonianPrec.c \
> 	LALSimIMRSpinEOBAuxFuncsPrec.c \
> 	LALSimIMRSpinEOBFactorizedWaveformCoefficientsPrec.c \
> 	LALSimIMREOBHybridRingdownPrec.c \
> 	LALSimIMRSpinEOBFactorizedFluxPrec.c \
> 	LALSimIMRSpinEOBHcapNumericalDerivativePrec.c \
> 	LALSimIMRSpinEOBInitialConditionsPrec.c
514c588,589
<         LALSimIMRSpinAlignedEOB.c \
---
> 	LALSimIMRSpinAlignedEOB.c \
> 	LALSimIMRSpinPrecEOB.c \
518a594
> 	LALSimIMRSEOBNRv2ROMDoubleSpinHI.c \
519a596
> 	LALSimIMREOBNRv2HMROM.c \
549a627
>         LALSimIMRNRWaveforms.c \
562a641
> 	LALSimUtils.c \
566c645,646
< 	LALSimInspiralHGimri.c
---
> 	LALSimInspiralHGimri.c \
> 	LALSimFindAttachTime.c
572a653
> lalsim_burst_SOURCES = burst.c
591a673,674
> 	lalsiminspiral_orbitelements.svg \
> 	lalsimulation_inject.svg \
599c682
< 	$(MAKE) $(AM_MAKEFLAGS) all-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
748a832,834
> lalsim-burst$(EXEEXT): $(lalsim_burst_OBJECTS) $(lalsim_burst_DEPENDENCIES) 
> 	@rm -f lalsim-burst$(EXEEXT)
> 	$(AM_V_CCLD)$(LINK) $(lalsim_burst_OBJECTS) $(lalsim_burst_LDADD) $(LIBS)
785a872
> include ./$(DEPDIR)/LALSimFindAttachTime.Plo
786a874,875
> include ./$(DEPDIR)/LALSimIMREOBNRv2HMROM.Plo
> include ./$(DEPDIR)/LALSimIMRNRWaveforms.Plo
795a885
> include ./$(DEPDIR)/LALSimIMRSEOBNRv2ROMDoubleSpinHI.Plo
797a888
> include ./$(DEPDIR)/LALSimIMRSpinPrecEOB.Plo
835a927
> include ./$(DEPDIR)/LALSimUtils.Plo
841a934
> include ./$(DEPDIR)/burst.Po
924a1018,1087
> # This directory's subdirectories are mostly independent; you can cd
> # into them and run `make' without going through this Makefile.
> # To change the values of `make' variables: instead of editing Makefiles,
> # (1) if the variable is set in `config.status', edit `config.status'
> #     (which will cause the Makefiles to be regenerated when you run `make');
> # (2) otherwise, pass the desired values on the `make' command line.
> $(RECURSIVE_TARGETS):
> 	@fail= failcom='exit 1'; \
> 	for f in x $$MAKEFLAGS; do \
> 	  case $$f in \
> 	    *=* | --[!k]*);; \
> 	    *k*) failcom='fail=yes';; \
> 	  esac; \
> 	done; \
> 	dot_seen=no; \
> 	target=`echo $@ | sed s/-recursive//`; \
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  echo "Making $$target in $$subdir"; \
> 	  if test "$$subdir" = "."; then \
> 	    dot_seen=yes; \
> 	    local_target="$$target-am"; \
> 	  else \
> 	    local_target="$$target"; \
> 	  fi; \
> 	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
> 	  || eval $$failcom; \
> 	done; \
> 	if test "$$dot_seen" = "no"; then \
> 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
> 	fi; test -z "$$fail"
> 
> $(RECURSIVE_CLEAN_TARGETS):
> 	@fail= failcom='exit 1'; \
> 	for f in x $$MAKEFLAGS; do \
> 	  case $$f in \
> 	    *=* | --[!k]*);; \
> 	    *k*) failcom='fail=yes';; \
> 	  esac; \
> 	done; \
> 	dot_seen=no; \
> 	case "$@" in \
> 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
> 	  *) list='$(SUBDIRS)' ;; \
> 	esac; \
> 	rev=''; for subdir in $$list; do \
> 	  if test "$$subdir" = "."; then :; else \
> 	    rev="$$subdir $$rev"; \
> 	  fi; \
> 	done; \
> 	rev="$$rev ."; \
> 	target=`echo $@ | sed s/-recursive//`; \
> 	for subdir in $$rev; do \
> 	  echo "Making $$target in $$subdir"; \
> 	  if test "$$subdir" = "."; then \
> 	    local_target="$$target-am"; \
> 	  else \
> 	    local_target="$$target"; \
> 	  fi; \
> 	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
> 	  || eval $$failcom; \
> 	done && test -z "$$fail"
> tags-recursive:
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
> 	done
> ctags-recursive:
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
> 	done
> 
935c1098
< TAGS:  $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
---
> TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
938a1102,1114
> 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
> 	  include_option=--etags-include; \
> 	  empty_fix=.; \
> 	else \
> 	  include_option=--include; \
> 	  empty_fix=; \
> 	fi; \
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    test ! -f $$subdir/TAGS || \
> 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
> 	  fi; \
> 	done; \
957c1133
< CTAGS:  $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
---
> CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
1006a1183,1210
> 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    test -d "$(distdir)/$$subdir" \
> 	    || $(MKDIR_P) "$(distdir)/$$subdir" \
> 	    || exit 1; \
> 	  fi; \
> 	done
> 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
> 	    $(am__relativize); \
> 	    new_distdir=$$reldir; \
> 	    dir1=$$subdir; dir2="$(top_distdir)"; \
> 	    $(am__relativize); \
> 	    new_top_distdir=$$reldir; \
> 	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
> 	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
> 	    ($(am__cd) $$subdir && \
> 	      $(MAKE) $(AM_MAKEFLAGS) \
> 	        top_distdir="$$new_top_distdir" \
> 	        distdir="$$new_distdir" \
> 		am__remove_distdir=: \
> 		am__skip_length_check=: \
> 		am__skip_mode_fix=: \
> 	        distdir) \
> 	      || exit 1; \
> 	  fi; \
> 	done
1009c1213
< 	$(MAKE) $(AM_MAKEFLAGS) check-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) check-recursive
1014c1218,1219
< installdirs:
---
> installdirs: installdirs-recursive
> installdirs-am:
1019,1022c1224,1227
< 	$(MAKE) $(AM_MAKEFLAGS) install-am
< install-exec: install-exec-am
< install-data: install-data-am
< uninstall: uninstall-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) install-recursive
> install-exec: install-exec-recursive
> install-data: install-data-recursive
> uninstall: uninstall-recursive
1027c1232
< installcheck: installcheck-am
---
> installcheck: installcheck-recursive
1047c1252
< clean: clean-am
---
> clean: clean-recursive
1052c1257
< distclean: distclean-am
---
> distclean: distclean-recursive
1058c1263
< dvi: dvi-am
---
> dvi: dvi-recursive
1062c1267
< html: html-am
---
> html: html-recursive
1066c1271
< info: info-am
---
> info: info-recursive
1072c1277
< install-dvi: install-dvi-am
---
> install-dvi: install-dvi-recursive
1078c1283
< install-html: install-html-am
---
> install-html: install-html-recursive
1082c1287
< install-info: install-info-am
---
> install-info: install-info-recursive
1088c1293
< install-pdf: install-pdf-am
---
> install-pdf: install-pdf-recursive
1092c1297
< install-ps: install-ps-am
---
> install-ps: install-ps-recursive
1098c1303
< maintainer-clean: maintainer-clean-am
---
> maintainer-clean: maintainer-clean-recursive
1103c1308
< mostlyclean: mostlyclean-am
---
> mostlyclean: mostlyclean-recursive
1108c1313
< pdf: pdf-am
---
> pdf: pdf-recursive
1112c1317
< ps: ps-am
---
> ps: ps-recursive
1119c1324,1326
< .MAKE: all check install install-am install-strip
---
> .MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
> 	ctags-recursive install install-am install-strip \
> 	tags-recursive
1121c1328,1329
< .PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
---
> .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
> 	all all-am check check-am clean clean-binPROGRAMS \
1123,1134c1331,1343
< 	distclean distclean-compile distclean-generic distclean-hdr \
< 	distclean-libtool distclean-tags distdir dvi dvi-am html \
< 	html-am info info-am install install-am install-binPROGRAMS \
< 	install-data install-data-am install-dvi install-dvi-am \
< 	install-exec install-exec-am install-html install-html-am \
< 	install-info install-info-am install-libLTLIBRARIES \
< 	install-man install-pdf install-pdf-am install-pkgdataDATA \
< 	install-pkgincludeHEADERS install-ps install-ps-am \
< 	install-strip installcheck installcheck-am installdirs \
< 	maintainer-clean maintainer-clean-generic mostlyclean \
< 	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
< 	pdf pdf-am ps ps-am tags uninstall uninstall-am \
---
> 	ctags-recursive distclean distclean-compile distclean-generic \
> 	distclean-hdr distclean-libtool distclean-tags distdir dvi \
> 	dvi-am html html-am info info-am install install-am \
> 	install-binPROGRAMS install-data install-data-am install-dvi \
> 	install-dvi-am install-exec install-exec-am install-html \
> 	install-html-am install-info install-info-am \
> 	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
> 	install-pkgdataDATA install-pkgincludeHEADERS install-ps \
> 	install-ps-am install-strip installcheck installcheck-am \
> 	installdirs installdirs-am maintainer-clean \
> 	maintainer-clean-generic mostlyclean mostlyclean-compile \
> 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
> 	tags tags-recursive uninstall uninstall-am \
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/Makefile.am ./Makefile.am
5a6,9
> SUBDIRS = \
> 	mathematica_codes \
> 	$(END_OF_LIST)
> 
40a45
> 	lalsim-burst \
66a72
> 	LALSimUtils.h \
69,71c75,76
< 	LALSimulationVCSInfoHeader.h \
< 	LALSimIMREOBNRv2.h \
< 	LALSimIMRTNSEOBFactorizedWaveform.c 
---
> 	LALSimulationVCSInfoHeader.h
> 
75a81,83
> 	LALSimIMREOBNRv2.h \
> 	LALSimIMRTNSEOB.h \
> 	LALSimFindAttachTime.h\
79a88,89
> 	LALSimIMRSpinEOBHamiltonianOptimized.c \
> 	LALSimIMRSpinEOBComputeAmpPhasefromEOMSoln.c \
80a91
> 	LALSimIMRSpinEOBHcapExactDerivative.c \
81a93,94
> 	LALSimIMRSpinAlignedEOBHcapDerivativeOptimized.c \
> 	LALSimIMRSpinAlignedEOBGSLOptimizedInterpolation.c \
86d98
<         LALSimIMRTNSEOBFactorizedFlux.c \
87a100
> 	LALSimIMRSpinEOBFactorizedFluxOptimized.c \
91a105
> 	LALSimIMRPhenomC_internals.h \
92a107
> 	LALSimIMRPhenomD_internals.h \
95c110,122
< 	LALSimIMRSEOBNRROMUtilities.c
---
> 	LALSimIMRPhenomP.h \
> 	LALSimIMRSEOBNRROMUtilities.c \
> 	LALSimIMREOBNRv2HMROMUtilities.c \
> 	LALSimBlackHoleRingdownPrec.c \
> 	LALSimBlackHoleRingdownPrec.h \
> 	LALSimIMRSpinEOBFactorizedWaveformPrec.c \
> 	LALSimIMRSpinEOBHamiltonianPrec.c \
> 	LALSimIMRSpinEOBAuxFuncsPrec.c \
> 	LALSimIMRSpinEOBFactorizedWaveformCoefficientsPrec.c \
> 	LALSimIMREOBHybridRingdownPrec.c \
> 	LALSimIMRSpinEOBFactorizedFluxPrec.c \
> 	LALSimIMRSpinEOBHcapNumericalDerivativePrec.c \
> 	LALSimIMRSpinEOBInitialConditionsPrec.c
104c131,132
<         LALSimIMRSpinAlignedEOB.c \
---
> 	LALSimIMRSpinAlignedEOB.c \
> 	LALSimIMRSpinPrecEOB.c \
108a137
> 	LALSimIMRSEOBNRv2ROMDoubleSpinHI.c \
109a139
> 	LALSimIMREOBNRv2HMROM.c \
139a170
>         LALSimIMRNRWaveforms.c \
152a184
> 	LALSimUtils.c \
156c188,189
< 	LALSimInspiralHGimri.c
---
> 	LALSimInspiralHGimri.c \
> 	LALSimFindAttachTime.c
164a198
> lalsim_burst_SOURCES = burst.c
184a219,220
> 	lalsiminspiral_orbitelements.svg \
> 	lalsimulation_inject.svg \
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/Makefile.in ./Makefile.in
49,53c49,54
< 	lalsim-bh-sphwf$(EXEEXT) lalsim-detector-noise$(EXEEXT) \
< 	lalsim-detector-strain$(EXEEXT) lalsim-inject$(EXEEXT) \
< 	lalsim-inspiral$(EXEEXT) lalsim-ns-eos-table$(EXEEXT) \
< 	lalsim-ns-mass-radius$(EXEEXT) lalsim-ns-params$(EXEEXT) \
< 	lalsim-sgwb$(EXEEXT) lalsim-unicorn$(EXEEXT)
---
> 	lalsim-bh-sphwf$(EXEEXT) lalsim-burst$(EXEEXT) \
> 	lalsim-detector-noise$(EXEEXT) lalsim-detector-strain$(EXEEXT) \
> 	lalsim-inject$(EXEEXT) lalsim-inspiral$(EXEEXT) \
> 	lalsim-ns-eos-table$(EXEEXT) lalsim-ns-mass-radius$(EXEEXT) \
> 	lalsim-ns-params$(EXEEXT) lalsim-sgwb$(EXEEXT) \
> 	lalsim-unicorn$(EXEEXT)
99c100
< 	LALSimIMRSEOBNRv1ROMEffectiveSpin.lo \
---
> 	LALSimIMRSpinPrecEOB.lo LALSimIMRSEOBNRv1ROMEffectiveSpin.lo \
103,109c104,112
< 	LALSimIMRSEOBNRv2ChirpTime.lo LALSimIMRPhenom.lo \
< 	LALSimIMRPhenomC.lo LALSimIMRPhenomD.lo LALSimIMRPhenomP.lo \
< 	LALSimIMRPSpinInspiralRD.lo LALSimPhenSpinRingDown.lo \
< 	LALSimInspiralWaveformFlags.lo LALSimInspiralTestGRParams.lo \
< 	LALSimInspiralPrecess.lo LALSimInspiral.lo \
< 	LALSimInspiralPNMode.lo LALSimInspiralSpinTaylor.lo \
< 	LALSimInspiralSpinTaylorF2.lo LALSimInspiralEccentricityFD.lo \
---
> 	LALSimIMRSEOBNRv2ROMDoubleSpinHI.lo \
> 	LALSimIMRSEOBNRv2ChirpTime.lo LALSimIMREOBNRv2HMROM.lo \
> 	LALSimIMRPhenom.lo LALSimIMRPhenomC.lo LALSimIMRPhenomD.lo \
> 	LALSimIMRPhenomP.lo LALSimIMRPSpinInspiralRD.lo \
> 	LALSimPhenSpinRingDown.lo LALSimInspiralWaveformFlags.lo \
> 	LALSimInspiralTestGRParams.lo LALSimInspiralPrecess.lo \
> 	LALSimInspiral.lo LALSimInspiralPNMode.lo \
> 	LALSimInspiralSpinTaylor.lo LALSimInspiralSpinTaylorF2.lo \
> 	LALSimInspiralEccentricityFD.lo \
120,126c123,129
< 	LALSimInspiralWaveformTaper.lo LALSimulation.lo \
< 	LALSimulationVCSInfo.lo LALSimNeutronStarEOS.lo \
< 	LALSimNeutronStarFamily.lo LALSimNeutronStarTOV.lo \
< 	LALSimNoisePSD.lo LALSimNoise.lo LALSimReadData.lo \
< 	LALSimSGWB.lo LALSimSGWBORF.lo LALSimSphHarmMode.lo \
< 	LALSimSphHarmSeries.lo LALSimUnicorn.lo \
< 	LALSimInspiralHGimri.lo
---
> 	LALSimInspiralWaveformTaper.lo LALSimIMRNRWaveforms.lo \
> 	LALSimulation.lo LALSimulationVCSInfo.lo \
> 	LALSimNeutronStarEOS.lo LALSimNeutronStarFamily.lo \
> 	LALSimNeutronStarTOV.lo LALSimNoisePSD.lo LALSimNoise.lo \
> 	LALSimReadData.lo LALSimSGWB.lo LALSimSGWBORF.lo \
> 	LALSimSphHarmMode.lo LALSimSphHarmSeries.lo LALSimUnicorn.lo \
> 	LALSimUtils.lo LALSimInspiralHGimri.lo LALSimFindAttachTime.lo
149a153,156
> am_lalsim_burst_OBJECTS = burst.$(OBJEXT)
> lalsim_burst_OBJECTS = $(am_lalsim_burst_OBJECTS)
> lalsim_burst_LDADD = $(LDADD)
> lalsim_burst_DEPENDENCIES = liblalsimulation.la
215c222,223
< 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_detector_noise_SOURCES) \
---
> 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_burst_SOURCES) \
> 	$(lalsim_detector_noise_SOURCES) \
222c230,231
< 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_detector_noise_SOURCES) \
---
> 	$(lalsim_bh_sphwf_SOURCES) $(lalsim_burst_SOURCES) \
> 	$(lalsim_detector_noise_SOURCES) \
226a236,242
> RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
> 	html-recursive info-recursive install-data-recursive \
> 	install-dvi-recursive install-exec-recursive \
> 	install-html-recursive install-info-recursive \
> 	install-pdf-recursive install-ps-recursive install-recursive \
> 	installcheck-recursive installdirs-recursive pdf-recursive \
> 	ps-recursive uninstall-recursive
228a245,249
> RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
>   distclean-recursive maintainer-clean-recursive
> AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
> 	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
> 	distdir
230a252
> DIST_SUBDIRS = $(SUBDIRS)
231a254,278
> am__relativize = \
>   dir0=`pwd`; \
>   sed_first='s,^\([^/]*\)/.*$$,\1,'; \
>   sed_rest='s,^[^/]*/*,,'; \
>   sed_last='s,^.*/\([^/]*\)$$,\1,'; \
>   sed_butlast='s,/*[^/]*$$,,'; \
>   while test -n "$$dir1"; do \
>     first=`echo "$$dir1" | sed -e "$$sed_first"`; \
>     if test "$$first" != "."; then \
>       if test "$$first" = ".."; then \
>         dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
>         dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
>       else \
>         first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
>         if test "$$first2" = "$$first"; then \
>           dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
>         else \
>           dir2="../$$dir2"; \
>         fi; \
>         dir0="$$dir0"/"$$first"; \
>       fi; \
>     fi; \
>     dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
>   done; \
>   reldir="$$dir2"
246a294
> BIBTEX = @BIBTEX@
337a386
> PERL = @PERL@
430a480,483
> SUBDIRS = \
> 	mathematica_codes \
> 	$(END_OF_LIST)
> 
475a529
> 	LALSimUtils.h \
478,480c532
< 	LALSimulationVCSInfoHeader.h \
< 	LALSimIMREOBNRv2.h \
< 	LALSimIMRTNSEOBFactorizedWaveform.c 
---
> 	LALSimulationVCSInfoHeader.h
485a538,540
> 	LALSimIMREOBNRv2.h \
> 	LALSimIMRTNSEOB.h \
> 	LALSimFindAttachTime.h\
489a545,546
> 	LALSimIMRSpinEOBHamiltonianOptimized.c \
> 	LALSimIMRSpinEOBComputeAmpPhasefromEOMSoln.c \
490a548
> 	LALSimIMRSpinEOBHcapExactDerivative.c \
491a550,551
> 	LALSimIMRSpinAlignedEOBHcapDerivativeOptimized.c \
> 	LALSimIMRSpinAlignedEOBGSLOptimizedInterpolation.c \
496d555
<         LALSimIMRTNSEOBFactorizedFlux.c \
497a557
> 	LALSimIMRSpinEOBFactorizedFluxOptimized.c \
501a562
> 	LALSimIMRPhenomC_internals.h \
502a564
> 	LALSimIMRPhenomD_internals.h \
505c567,579
< 	LALSimIMRSEOBNRROMUtilities.c
---
> 	LALSimIMRPhenomP.h \
> 	LALSimIMRSEOBNRROMUtilities.c \
> 	LALSimIMREOBNRv2HMROMUtilities.c \
> 	LALSimBlackHoleRingdownPrec.c \
> 	LALSimBlackHoleRingdownPrec.h \
> 	LALSimIMRSpinEOBFactorizedWaveformPrec.c \
> 	LALSimIMRSpinEOBHamiltonianPrec.c \
> 	LALSimIMRSpinEOBAuxFuncsPrec.c \
> 	LALSimIMRSpinEOBFactorizedWaveformCoefficientsPrec.c \
> 	LALSimIMREOBHybridRingdownPrec.c \
> 	LALSimIMRSpinEOBFactorizedFluxPrec.c \
> 	LALSimIMRSpinEOBHcapNumericalDerivativePrec.c \
> 	LALSimIMRSpinEOBInitialConditionsPrec.c
514c588,589
<         LALSimIMRSpinAlignedEOB.c \
---
> 	LALSimIMRSpinAlignedEOB.c \
> 	LALSimIMRSpinPrecEOB.c \
518a594
> 	LALSimIMRSEOBNRv2ROMDoubleSpinHI.c \
519a596
> 	LALSimIMREOBNRv2HMROM.c \
549a627
>         LALSimIMRNRWaveforms.c \
562a641
> 	LALSimUtils.c \
566c645,646
< 	LALSimInspiralHGimri.c
---
> 	LALSimInspiralHGimri.c \
> 	LALSimFindAttachTime.c
572a653
> lalsim_burst_SOURCES = burst.c
591a673,674
> 	lalsiminspiral_orbitelements.svg \
> 	lalsimulation_inject.svg \
599c682
< 	$(MAKE) $(AM_MAKEFLAGS) all-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
748a832,834
> lalsim-burst$(EXEEXT): $(lalsim_burst_OBJECTS) $(lalsim_burst_DEPENDENCIES) 
> 	@rm -f lalsim-burst$(EXEEXT)
> 	$(AM_V_CCLD)$(LINK) $(lalsim_burst_OBJECTS) $(lalsim_burst_LDADD) $(LIBS)
785a872
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimFindAttachTime.Plo@am__quote@
786a874,875
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimIMREOBNRv2HMROM.Plo@am__quote@
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimIMRNRWaveforms.Plo@am__quote@
795a885
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimIMRSEOBNRv2ROMDoubleSpinHI.Plo@am__quote@
797a888
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimIMRSpinPrecEOB.Plo@am__quote@
835a927
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LALSimUtils.Plo@am__quote@
841a934
> @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/burst.Po@am__quote@
924a1018,1087
> # This directory's subdirectories are mostly independent; you can cd
> # into them and run `make' without going through this Makefile.
> # To change the values of `make' variables: instead of editing Makefiles,
> # (1) if the variable is set in `config.status', edit `config.status'
> #     (which will cause the Makefiles to be regenerated when you run `make');
> # (2) otherwise, pass the desired values on the `make' command line.
> $(RECURSIVE_TARGETS):
> 	@fail= failcom='exit 1'; \
> 	for f in x $$MAKEFLAGS; do \
> 	  case $$f in \
> 	    *=* | --[!k]*);; \
> 	    *k*) failcom='fail=yes';; \
> 	  esac; \
> 	done; \
> 	dot_seen=no; \
> 	target=`echo $@ | sed s/-recursive//`; \
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  echo "Making $$target in $$subdir"; \
> 	  if test "$$subdir" = "."; then \
> 	    dot_seen=yes; \
> 	    local_target="$$target-am"; \
> 	  else \
> 	    local_target="$$target"; \
> 	  fi; \
> 	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
> 	  || eval $$failcom; \
> 	done; \
> 	if test "$$dot_seen" = "no"; then \
> 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
> 	fi; test -z "$$fail"
> 
> $(RECURSIVE_CLEAN_TARGETS):
> 	@fail= failcom='exit 1'; \
> 	for f in x $$MAKEFLAGS; do \
> 	  case $$f in \
> 	    *=* | --[!k]*);; \
> 	    *k*) failcom='fail=yes';; \
> 	  esac; \
> 	done; \
> 	dot_seen=no; \
> 	case "$@" in \
> 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
> 	  *) list='$(SUBDIRS)' ;; \
> 	esac; \
> 	rev=''; for subdir in $$list; do \
> 	  if test "$$subdir" = "."; then :; else \
> 	    rev="$$subdir $$rev"; \
> 	  fi; \
> 	done; \
> 	rev="$$rev ."; \
> 	target=`echo $@ | sed s/-recursive//`; \
> 	for subdir in $$rev; do \
> 	  echo "Making $$target in $$subdir"; \
> 	  if test "$$subdir" = "."; then \
> 	    local_target="$$target-am"; \
> 	  else \
> 	    local_target="$$target"; \
> 	  fi; \
> 	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
> 	  || eval $$failcom; \
> 	done && test -z "$$fail"
> tags-recursive:
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
> 	done
> ctags-recursive:
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
> 	done
> 
935c1098
< TAGS:  $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
---
> TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
938a1102,1114
> 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
> 	  include_option=--etags-include; \
> 	  empty_fix=.; \
> 	else \
> 	  include_option=--include; \
> 	  empty_fix=; \
> 	fi; \
> 	list='$(SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    test ! -f $$subdir/TAGS || \
> 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
> 	  fi; \
> 	done; \
957c1133
< CTAGS:  $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
---
> CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in LALSimulationConfig.h.in $(TAGS_DEPENDENCIES) \
1006a1183,1210
> 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    test -d "$(distdir)/$$subdir" \
> 	    || $(MKDIR_P) "$(distdir)/$$subdir" \
> 	    || exit 1; \
> 	  fi; \
> 	done
> 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
> 	  if test "$$subdir" = .; then :; else \
> 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
> 	    $(am__relativize); \
> 	    new_distdir=$$reldir; \
> 	    dir1=$$subdir; dir2="$(top_distdir)"; \
> 	    $(am__relativize); \
> 	    new_top_distdir=$$reldir; \
> 	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
> 	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
> 	    ($(am__cd) $$subdir && \
> 	      $(MAKE) $(AM_MAKEFLAGS) \
> 	        top_distdir="$$new_top_distdir" \
> 	        distdir="$$new_distdir" \
> 		am__remove_distdir=: \
> 		am__skip_length_check=: \
> 		am__skip_mode_fix=: \
> 	        distdir) \
> 	      || exit 1; \
> 	  fi; \
> 	done
1009c1213
< 	$(MAKE) $(AM_MAKEFLAGS) check-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) check-recursive
1014c1218,1219
< installdirs:
---
> installdirs: installdirs-recursive
> installdirs-am:
1019,1022c1224,1227
< 	$(MAKE) $(AM_MAKEFLAGS) install-am
< install-exec: install-exec-am
< install-data: install-data-am
< uninstall: uninstall-am
---
> 	$(MAKE) $(AM_MAKEFLAGS) install-recursive
> install-exec: install-exec-recursive
> install-data: install-data-recursive
> uninstall: uninstall-recursive
1027c1232
< installcheck: installcheck-am
---
> installcheck: installcheck-recursive
1047c1252
< clean: clean-am
---
> clean: clean-recursive
1052c1257
< distclean: distclean-am
---
> distclean: distclean-recursive
1058c1263
< dvi: dvi-am
---
> dvi: dvi-recursive
1062c1267
< html: html-am
---
> html: html-recursive
1066c1271
< info: info-am
---
> info: info-recursive
1072c1277
< install-dvi: install-dvi-am
---
> install-dvi: install-dvi-recursive
1078c1283
< install-html: install-html-am
---
> install-html: install-html-recursive
1082c1287
< install-info: install-info-am
---
> install-info: install-info-recursive
1088c1293
< install-pdf: install-pdf-am
---
> install-pdf: install-pdf-recursive
1092c1297
< install-ps: install-ps-am
---
> install-ps: install-ps-recursive
1098c1303
< maintainer-clean: maintainer-clean-am
---
> maintainer-clean: maintainer-clean-recursive
1103c1308
< mostlyclean: mostlyclean-am
---
> mostlyclean: mostlyclean-recursive
1108c1313
< pdf: pdf-am
---
> pdf: pdf-recursive
1112c1317
< ps: ps-am
---
> ps: ps-recursive
1119c1324,1326
< .MAKE: all check install install-am install-strip
---
> .MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
> 	ctags-recursive install install-am install-strip \
> 	tags-recursive
1121c1328,1329
< .PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
---
> .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
> 	all all-am check check-am clean clean-binPROGRAMS \
1123,1134c1331,1343
< 	distclean distclean-compile distclean-generic distclean-hdr \
< 	distclean-libtool distclean-tags distdir dvi dvi-am html \
< 	html-am info info-am install install-am install-binPROGRAMS \
< 	install-data install-data-am install-dvi install-dvi-am \
< 	install-exec install-exec-am install-html install-html-am \
< 	install-info install-info-am install-libLTLIBRARIES \
< 	install-man install-pdf install-pdf-am install-pkgdataDATA \
< 	install-pkgincludeHEADERS install-ps install-ps-am \
< 	install-strip installcheck installcheck-am installdirs \
< 	maintainer-clean maintainer-clean-generic mostlyclean \
< 	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
< 	pdf pdf-am ps ps-am tags uninstall uninstall-am \
---
> 	ctags-recursive distclean distclean-compile distclean-generic \
> 	distclean-hdr distclean-libtool distclean-tags distdir dvi \
> 	dvi-am html html-am info info-am install install-am \
> 	install-binPROGRAMS install-data install-data-am install-dvi \
> 	install-dvi-am install-exec install-exec-am install-html \
> 	install-html-am install-info install-info-am \
> 	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
> 	install-pkgdataDATA install-pkgincludeHEADERS install-ps \
> 	install-ps-am install-strip installcheck installcheck-am \
> 	installdirs installdirs-am maintainer-clean \
> 	maintainer-clean-generic mostlyclean mostlyclean-compile \
> 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
> 	tags tags-recursive uninstall uninstall-am \
Only in .: mathematica_codes
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: ns-eos-table.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: ns-mass-radius.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: ns-params.o
diff /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src/sgwb.c ./sgwb.c
19a20,80
> /**
>  * @defgroup lalsim_sgwb lalsim-sgwb
>  * @ingroup lalsimulation_programs
>  *
>  * @brief Simulates a stochastic gravitational wave background
>  *
>  * ### Synopsis
>  *
>  *     lalsim-sgwb [options]
>  *
>  * ### Description
>  *
>  * The `lalsim-sgwb` utility produces a continuous stream of simulated detector
>  * stochastic gravitational wave background noise for a specified interval of
>  * time, for the specified detectors, and for a specified flat spectral energy
>  * density.  The output is written to the standard output in multi-column ascii
>  * format data in which the first column contains the GPS times of each sample
>  * and the remaining columns contain the (correlated) noise strain values
>  * in the various detectors.
>  *
>  * ### Options
>  *
>  * <DL>
>  * <DT>`-h`, `--help`</DT>                   	<DD>print a help message and exit</DD>
>  * <DT>`-G`, `--geo`</DT>                    	<DD>include GEO</DD>
>  * <DT>`-H`, `--hanford`</DT>                	<DD>include LHO</DD>
>  * <DT>`-L`, `--livingston`</DT>             	<DD>include LLO</DD>
>  * <DT>`-V`, `--virgo`</DT>                  	<DD>include Virgo</DD>
>  * <DT>`-s`, `--start-time` GPSSTART</DT>    	<DD>GPS start time (s)</DD>
>  * <DT>`-t`, `--duration`   DURATION</DT>    	<DD>(required) duration of data to produce (s)</DD>
>  * <DT>`-r`, `--sample-rate` SRATE</DT>            	<DD>sample rate (Hz) [16384]</DD>
>  * <DT>`-W`, `--Omega0`     OMEGA0</DT>      	<DD>(required) flat spectral energy density</DD>
>  * <DT>`-f`, `--low-frequency` FLOW</DT>     	<DD>low frequency cutoff (Hz) (default = 10 Hz)</DD>
>  * </DL>
>  *
>  * ### Environment
>  *
>  * The `LAL_DEBUG_LEVEL` can used to control the error and warning reporting of
>  * `lalsim-sgwb`.  Common values are: `LAL_DEBUG_LEVEL=0` which suppresses
>  * error messages, `LAL_DEBUG_LEVEL=1`  which prints error messages alone,
>  * `LAL_DEBUG_LEVEL=3` which prints both error messages and warning messages,
>  * and `LAL_DEBUG_LEVEL=7` which additionally prints informational messages.
>  *
>  * The `GSL_RNG_SEED` and `GSL_RNG_TYPE` environment variables can be used
>  * to set the random number generator seed and type respectively.
>  *
>  * ### Exit Status
>  *
>  * The `lalsim-sgwb` utility exits 0 on success, and >0 if an error occurs.
>  *
>  * ### Example
>  *
>  * The command:
>  *
>  *     lalsim-sgwb -H -L -V -W 1e-6 -s 1000000000 -t 1000
>  *
>  * will stream 1000 seconds of stochastic gravitational-wave background
>  * strain noise in the LHO, LLO, and Virgo detectors having
>  * \f$ {\Omega_0=10^{-6}} \f$ .
>  */
> 
198,201c259,262
< 	fprintf(stderr, "\t-s, --start-time GPSSTART    \tGPS start time (s)\n");
< 	fprintf(stderr, "\t-t, --duration   DURATION    \t(required) duration of data to produce (s)\n");
< 	fprintf(stderr, "\t-r, --sample-rate            \tsample rate (Hz) [16384]\n");
< 	fprintf(stderr, "\t-W, --Omega0     OMEGA0      \t(required) flat spectral energy density\n");
---
> 	fprintf(stderr, "\t-s, --start-time    GPSSTART \tGPS start time (s)\n");
> 	fprintf(stderr, "\t-t, --duration      DURATION \t(required) duration of data to produce (s)\n");
> 	fprintf(stderr, "\t-r, --sample-rate   SRATE    \tsample rate (Hz) [16384]\n");
> 	fprintf(stderr, "\t-W, --Omega0        OMEGA0   \t(required) flat spectral energy density\n");
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: sgwb.o
Only in /home/swetha.bhagwat/Projects/TidalEOB/git_teob4/TNSEOB_development/src_2/lalsuite/lalsimulation/src: unicorn.o
