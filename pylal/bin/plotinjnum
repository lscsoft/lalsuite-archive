#!/usr/bin/python

__Id__ = "$Id$"
__author__ = "Drew Keppel <keppel_d@ligo.caltech.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__prog__ = "plotinjnum"
__title__ = "Found and Missed Plots"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *
from glue.ligolw import ligolw
from glue.ligolw import table
from glue import lal
from pylal import SimInspiralUtils
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from pylal import InspiralUtils

##############################################################################
def found_missed(opts,foundFiles,missedFiles):
  """
  """
  statistic = CoincInspiralUtils.coincStatistic( opts.statistic, None, None, opts.eff_snr_denom_fac )
  coincTriggers = CoincInspiralUtils.coincInspiralTable()
  for file in foundFiles:
    file = [file]
    simFound = SimInspiralUtils.ReadSimInspiralFromFiles(file)
    inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(file,mangle_event_id=True,old_document=opts.old_document)
    if simFound and inspTriggers:
    # construct the coincs
      fileCoincTriggers = \
        CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)
      fileCoincTriggers.add_sim_inspirals(simFound)
      for coinc in fileCoincTriggers:
        coincTriggers.append(coinc)
     
  missed = {}
  missed['mchirp'] = []
  missed['end_time_gmst'] = []
  missed['eff_dist_h'] = []
  missed['chirp_dist_h'] = []
  for file in missedFiles:
    file = [file]
    
    simMissed = SimInspiralUtils.ReadSimInspiralFromFiles(file)
    if simMissed:
      for sim in simMissed:
        missed['mchirp'].append(sim.mchirp)
        missed['end_time_gmst'].append(sim.end_time_gmst)
        missed['eff_dist_h'].append(sim.eff_dist_h)
        missed['chirp_dist_h'].append(sim.eff_dist_h*(2.8*.25**(3.0/5.0)/sim.mchirp)**(5.0/6.0))

  found = []
  if len(coincTriggers) > 0:
    for coinc in coincTriggers:
      if coinc.numifos > len(found):
        while coinc.numifos > len(found):
          found.append({'mchirp':[],'end_time_gmst':[],'eff_dist_h':[],
              'chirp_dist_h':[]})
      found[coinc.numifos - 1]['mchirp'].append(coinc.sim.mchirp)
      found[coinc.numifos - 1]['end_time_gmst'].append(coinc.sim.end_time_gmst)
      found[coinc.numifos - 1]['eff_dist_h'].append(coinc.sim.eff_dist_h)
      found[coinc.numifos - 1]['chirp_dist_h'].append(coinc.sim.eff_dist_h* \
          (2.8*.25**(3.0/5.0)/coinc.sim.mchirp)**(5.0/6.0))

  return missed, found


def plot_found_missed(figNum, opts, missed, found, xtype, ytype):
  """
  """
  figure(figNum,figsize=(8,8))
  ax = axes([0.15, 0.15, 0.7, 0.7])

  typeNames = ['Missed', 'Doubles', 'Triples', 'Quadruples', 'Quintuples']
  colors = ['rx','cx','bx','mx','gx']

  if xtype == 'mchirp':
    xStr = '$M_{chirp}(M_{\odot})$'
  elif xtype == 'end_time_gmst':
    xStr = 'GMST End Time'

  if ytype == 'eff_dist_h':
    yStr = 'Hanford Effective Distance (Mpc)'
  elif ytype == 'chirp_dist_h':
    yStr = 'Hanford Chirp Distance'

  legend_text = []
  for idx in range(len(found)):
    idx = len(found) - 1 - idx
    if idx > 0:
      semilogy(found[idx][xtype], found[idx][ytype], colors[idx])
      legend_text.append(typeNames[idx])
      hold(True)

  semilogy(missed[xtype], missed[ytype], colors[0])
  legend_text.append(typeNames[0])
  grid()

  title('Found and Missed Injections in ' + opts.ifo_times + ' times',
      size='xx-large')
  xlabel(xStr,size='xx-large')
  ylabel(yStr,size='xx-large')
  xticks(fontsize='xx-large')
  yticks(fontsize='xx-large')
  leg = legend(legend_text,loc=0)
  leg_text=leg.get_texts()
  setp(leg_text,fontsize='x-large')

  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, 'found_missed_' + \
        ytype + '_vs_' + xtype)
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
    if not opts.show_plot:
      close()
    return fname
  else:
    figName = opts.ifo_type + 'found_missed_' + ytype + '_vs_' + xtype + '.png'
    fname_thumb = InspiralUtils.savefig_pylal(filename=figName, doThumb=True, dpi_thumb=opts.figure_resolution)
    if not opts.show_plot:
      close()
    return figName 

###################################
# Defining a config parser function
###################################

usage = """
usage: %prog [options]

Injection Plotting Function

Generates plots showing the number of IFOs an injection is found in
"""
def parse_command_line():

  parser = OptionParser( usage=usage, \
      version="%prog CVS\n" + 
      "$Id$\n" + 
      "Name: $\n") 
  parser.add_option("-g","--found-glob",action="store",type="string",\
      default=None, metavar=" GLOB",\
      help="GLOB of FOUND injection files to read" )
  parser.add_option("-m","--missed-glob",action="store",type="string",\
      default=None, metavar=" GLOB",\
      help="GLOB of MISSED injection files to read" )
  parser.add_option("-S","--statistic",action="store",default='snr',\
      type="string",\
      help="choice of statistic used in making plots, valid arguments are: "
          "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr,")
  parser.add_option("","--eff-snr-denom-fac",action="store",default=250.0,\
      type="float", help="Effective snr denom fac: default = 250")
  parser.add_option("-I","--cache-file",action="store",type="string",\
      default=None, metavar=" CACHE_FILE",\
      help="input file to read Cache file" )
  parser.add_option("-i","--ifo-type",action="store",type="string",\
      default=None,  help="selects the ifo type for sieve for" )
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None,metavar=" USERTAG",  \
      help="a user tag for the output filenames" )
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTARTTIME",\
      help="gps start time (for naming figure and output files")
  parser.add_option("","--gps-end-time",action="store",\
      type="int",  metavar=" GPSENDTIME",\
      help="gps end time (for naming figure and output files")
  parser.add_option("-t","--ifo-tag",action="store",\
      type="string",  metavar=" IFOTAG",\
      help="ifo tag gives the information about ifo times and stage")
  parser.add_option("-T","--ifo-times",action="store",\
      type="string",  metavar=" IFOTIMES",\
      help="ifo times e.g H1H2, H1L1, H1H2L1 etc.")
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("","--inj-found-pattern", action="store",type="string",\
      default="", metavar="INJECTIONSPATTERN", help="sieving the cache file with injection pattern description" )
  parser.add_option("","--inj-missed-pattern", action="store",type="string",\
      default="", metavar="MISSEDPATTERN", help="sieving the cache file with missed pattern description" )
  parser.add_option("", "--figure-resolution",action="store",type="int",\
      default=50, help="dpi of the thumbnails (50 by default)")
  parser.add_option("", "--html-for-cbcweb",action="store",\
      default=False, metavar = "CVS DIRECTORY", help="publish the html "\
      "output in a format that can be directly published on the cbc webpage "\
      "or in CVS. This only works IF --enable-output is also specified. The "\
      "argument should be the cvs directory where the html file will be placed "\
      "Example: --html-for-cbcweb protected/projects/s5/yourprojectdir")

  parser.add_option("", "--old-document",action="store_true",\
      default=False,help="this option turns on mangling. you are only "\
      "supposed to use it if you are handling old documents")

  (options,args) = parser.parse_args()
  # test the input options


  return options, sys.argv[1:]

################
# Alphabets used
# 

############################
# get command line arguments
opts, args = parse_command_line()

######################################################
# to avoid  display problem when show plot is not used
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz


############
# Initialise
opts = InspiralUtils.initialise(opts, __prog__, __version__)
comments = ""
# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file

############################################
# Checking for found files and missed files.
if opts.found_glob:
  foundFiles = glob.glob(opts.found_glob)
  if opts.verbose:
    print __prog__+" ...reading the following list of found files " + str(foundFiles) + "\n"
elif opts.cache_file:
  foundFiles =  lal.Cache.fromfile(open(opts.cache_file)).sieve(description = opts.inj_found_pattern).\
      sieve(ifos=opts.ifo_times, exact_match=True).\
      checkfilesexist()[0].pfnlist()  
  if opts.verbose:
    print __prog__+"...reading the following list of found files: \n" 
    for file in foundFiles:
      print file

else:  
  print >>sys.stderr, "Must specify a glob of FOUND injections or cache file"
  sys.exit(1)

if not foundFiles:
  # give up and exit
  err_msg = "List of found files for given pattern is empty"
  print >>sys.stderr, err_msg
  comments += InspiralUtils.message(opts, err_msg)
  if opts.enable_output is True: 
    html_filename = InspiralUtils.write_html_output(opts, args, fnameList, \
        tagList, comment=comments)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)
  if opts.show_plot:
    sys.exit(1)
  else:
    sys.exit(0)


if opts.missed_glob:
   missedFiles = glob.glob(opts.missed_glob)
   if opts.verbose:
      print __prog__+" ...reading the following list of missed files " + str(missedFiles) + "\n"
elif opts.cache_file:
  missedFiles =  lal.Cache.fromfile(open(opts.cache_file)).sieve(description = opts.inj_missed_pattern).\
      sieve(ifos=opts.ifo_times, exact_match=True).\
      checkfilesexist()[0].pfnlist()
  if opts.verbose:
    print __prog__+"...reading the following list of missed files \n"
    for file in missedFiles:
      print file
else:
  print >>sys.stderr, "Must specify a glob or sieve pattern of MISSED injections"
  sys.exit(1)

if not missedFiles:
  print >>sys.stdout, "List of missed files for " + opts.ifo_times + " is empty"
  sys.exit(0)

##############################################
# Generating missed, doubles and triple coincs
missed, found = found_missed(opts,foundFiles,missedFiles)

#########################################
# final step: plot, html, cache file generation
figNum = 0

figNum += 1
fname = plot_found_missed(figNum, opts, missed, found, 'mchirp', 'chirp_dist_h')
fnameList.append(fname)
tagList.append("Found Chirp distance versus chirp mass")

figNum += 1
fname = plot_found_missed(figNum, opts, missed, found, 'end_time_gmst',
    'eff_dist_h')
fnameList.append(fname)
tagList.append("Missed versus end time")

figNum += 1
fname = plot_found_missed(figNum, opts, missed, found, 'mchirp', 'eff_dist_h')
fnameList.append(fname)
tagList.append("Found and missed versus chirp mass")

if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, tagList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

  if opts.html_for_cbcweb:
    html_filename_publish = InspiralUtils.write_html_output(opts, args, fnameList, tagList, cbcweb=True)

####################
if opts.show_plot:
    show()
