#!/usr/bin/env python
"""
GRB Summary Information

Generate a set of summary information and plots for on-source and off-source
segments around a GRB trigger.
"""
from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

import ConfigParser
import glob
import optparse
import os
import os.path as p
import sys

from lalapps import inspiral
from lalapps import inspiralutils
from glue import lal
from glue import segments, segmentsUtils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import grbsummary

def get_options():
    """
    Parse user input and return opts.
    """
    parser = optparse.OptionParser(usage=__doc__,
        version="%prog CVS $Id$")

    # always required parameters
    parser.add_option("-c", "--plot-config-file",
        help="plotting ini-file with parameters to pass to plotting routines")
    parser.add_option("-g","--injection-config",action="store",type="string",\
      default=None, metavar=" FILE", help="use configuration file FILE" )

    parser.add_option("-l","--list",action="store",type="string",\
        default=None, metavar=" GRB LIST",\
        help="path to the file with GRB data stored")

    parser.add_option("-P", "--log-path",
        help="directory in which to place Condor logs")

    # mode parameters - their presence turns on a feature
    parser.add_option("-d", "--dq-file", help="get data quality mask from file")
    parser.add_option("-q", "--query-dq", action="store_true", default=False,
        help="query for data quality flags from CIT daily dump")

    parser.add_option("-n", "--figure-name", help="tag for plot output")
    parser.add_option("-O", "--analyze-onsource", action="store_true",
        default=False,
        help="open the box and include on-source segments in the summary")

    # auxiliary parameters
    parser.add_option("-p", "--padding-time", type=int,
        help="pad analysis segments by PADDING_TIME seconds")
    parser.add_option("-m", "--num-trials", type=int,
        help="number of off-source segments to use for background estimation")
    parser.add_option("-a","--onsource-left",action="store",type="int",\
        default=120, metavar=" ONLEFT",\
        help="Specifies the left onsource time window (default: 120)")
    parser.add_option("-b","--onsource-right",action="store",type="int",\
        default=60, metavar=" ONRIGHT",\
        help="Specifies the right onsource time window (default:60)")
    parser.add_option("-u", "--usertag", help="usertag for all DAGs")
    parser.add_option("-v", "--verbose", action="store_true", default=False,
        help="print additional information during pipeline construction")


    (opts, args) = parser.parse_args()

    error_if_missing = ["list", "log_path", "plot_config_file",
        "onsource_left", "onsource_right", "padding_time", "injection_config"]
    
    for opt in error_if_missing:
        if getattr(opts, opt) is None:
            raise ValueError, "missing required option: --%s" % opt.replace("_", "-")

    return opts

def initialize_jobs_nodes_descr(cp):
    """
    Return dictionaries of jobs and node classes.
    """
    job_dict = {}
    job_dict["plotinspiral"] = inspiral.PlotInspiralJob(cp)
    job_dict["plotthinca"] = inspiral.PlotThincaJob(cp)
    job_dict["plotnumtemplates"] = inspiral.PlotNumtemplatesJob(cp)
    job_dict["plotinjnum"] = inspiral.PlotInjnumJob(cp)
    job_dict["plotethinca"] = inspiral.PlotEthincaJob(cp)
    job_dict["plotinspmissed"] = inspiral.PlotInspmissedJob(cp)
    job_dict["plotinspinj"] = inspiral.PlotInspinjJob(cp)
    job_dict["plotsnrchi"] = inspiral.PlotSnrchiJob(cp)
    
    node_class_dict = {}
    node_class_dict["plotinspiral"] = inspiral.PlotInspiralNode
    node_class_dict["plotthinca"] = inspiral.PlotThincaNode
    node_class_dict["plotnumtemplates"] = inspiral.PlotNumtemplatesNode
    node_class_dict["plotinjnum"] = inspiral.PlotInjnumNode
    node_class_dict["plotethinca"] = inspiral.PlotEthincaNode
    node_class_dict["plotinspmissed"] = inspiral.PlotInspmissedNode
    node_class_dict["plotinspinj"] = inspiral.PlotInspinjNode
    node_class_dict["plotsnrchi"] = inspiral.PlotSnrchiNode
    
    return job_dict, node_class_dict

def determine_plots_to_do(cp):
    """
    Determine plots to make from the plotting configuration file.  A plot
    will be made if it has a section in the plotting file.
    """
    plots = [sec for sec in cp.sections() if sec.beginswith("plot") and \
                                             not sec.endswith("-meta")]
    for plot in plots:
        if not has_section(plot + "-meta"):
            raise ValueError, "plot configuration file has section %s, "\
                "but not %s-meta." % (plot, plot)
    return plots

def write_masked_segments(exttrig_time, exttrig_dir, before_time, after_time):
    # load all analyzable segments
    analyzable_seglist = segmentsUtils.fromsegwizard(open(opts.analyzable_segfile))

    # determine on-source and off-source intervals for the external trigger
    on_source_seg = segments.segment(exttrig_time-before_time,
                                     exttrig_time+after_time)
    full_seg = grbsummary.symmetric_protraction(analyzable_seglist,
        on_source_seg, opts.padding_time, quantization_time, opts.num_trials)

    full_filename = "%s/full_segs.txt" % exttrig_dir
    segmentsUtils.tosegwizard(open(full_filename, "w"), segments.segmentlist([full_seg]))
    on_source_filename = "%s/on_source_segs.txt" % exttrig_dir
    segmentsUtils.tosegwizard(open(on_source_filename, "w"), segments.segmentlist([on_source_seg]))

    # get DQ info
    dq_veto_seglist = segments.segmentlist()  # FIXME
    dq_veto_filename = "dq_veto.txt"
    segmentsUtils.tosegwizard(open(dq_veto_filename, "w"), dq_veto_seglist)

    # generate on-source and off-source veto segmentlists
    on_source_veto_segs, off_source_veto_segs = \
        grbsummary.compute_masked_segments(analyzable_seglist,
        on_source_seg, veto_seglist=dq_veto_seglist,
        quantization_time=quantization_time)
    on_source_veto_filename = "%s/on_source_veto.txt" % exttrig_dir
    segmentsUtils.tosegwizard(open(on_source_filename, "w"),
        segments.segmentlist([on_source_seg]))
    off_source_veto_filename = "%s/off_source_veto.txt" % exttrig_dir
    segmentsUtils.tosegwizard(open(off_source_veto_filename, "w"),
        off_source_veto_segs)

    return on_source_veto_filename, on_source_veto_filename

def prepare_nodes(plot_name, node_class, job, cp, output_dir, dag, usertag=None):
    """
    Create a node of type node_class, set its input and output, then add
    it to the DAG. If cache is empty, no node is created.
    
    TODO: allow veto files
    """    
    for ifotag in ("FIRST", "SECOND"):
        # set the nodes and all parameters
        node = node_class(job)
        
        # set important things by hand...
        node.add_var_opt('output-path', output_dir)
        node.add_input_file(output_dir)
        
        # set sieve patterns
        sieve_patterns = inspiralutils.determine_sieve_patterns(cp, plot_name,
            ifotag, usertag)
        for opt, val in sieve_patterns.iteritems():
            node.add_var_opt(opt, val)
        
        # attach to DAG
        dag.add_node(node)

##############################################################################
# Main
##############################################################################

if __name__ == "__main__":
    # parse input
    opts = get_options()
    quantization_time = opts.onsource_left + opts.onsource_right
    
    # load plotting configuration
    plot_cp = ConfigParser.ConfigParser()
    plot_cp.read(opts.plot_config_file)
    
    # load external trigger times
    ext_triggers = grbsummary.load_external_triggers(opts.list)
    
    # determine what subdirectories each GRB will have
    injection_cp = ConfigParser.ConfigParser()
    injection_cp.read(opts.injection_config)
    dag_dirs = ["offsource", "onsource"] + injection_cp.sections()
    
    # initialize DAG
    if opts.verbose:
        print "Initializing DAG and plotting Jobs"
    dag = grbsummary.GRBSummaryDAG(opts.plot_config_file, opts.log_path)
    job_dict, node_class_dict = initialize_jobs_nodes_descr(plot_cp)
    
    # FIXME: make all plots for now
    plots_to_do = job_dict.keys()
    
    ### Loop over GRBs
    for trigger in ext_triggers:
        ### Setup directory with human readable GRB number
        exttrig_dir = "GRB" + trigger.event_number_grb
        plot_dir = exttrig_dir + "_plot"
        inspiralutils.mkdir(plot_dir)
        
        if opts.usertag is not None:
            usertag = opts.usertag + "_GRB" + trigger.event_number_grb
        else:
            usertag = "GRB" + trigger.event_number_grb
        
        if opts.verbose:
            print "Designing workflow for %s" % plot_dir

        for run_dir in dag_dirs:
            ### Determine and write segments
            # on_source_veto_filename, off_source_veto_filename = \
            #     write_masked_segments(exttrig_time, exttrig_dir,
            #                           opts.search_before_trigger,
            #                           opts.search_after_trigger)
            
            ### Design Workflow
            for plot_type in plots_to_do: # e.g. 'inspiral' 'thinca' 'ethinca' ...
                node_class = node_class_dict[plot_type]
                job = job_dict[plot_type]
                
                prepare_nodes(plot_type, node_class, job, plot_cp, plot_dir, dag, usertag)

    ### Write DAG
    dag.write_sub_files()
    dag.write_dag()
    dag.write_script()
