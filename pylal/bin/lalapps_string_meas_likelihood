#!/usr/bin/python
#
# Copyright (C) 2009  Kipp Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
from optparse import OptionParser
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import string
import sys


from glue import iterutils
from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import ligolw_burca_tailor
from pylal import SnglBurstUtils
from pylal import git_version
from pylal import inject
from pylal import rate


__author__ = "Kipp Cannon <kipp.cannon@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


# characters allowed to appear in the description string
T010150_letters = set(string.ascii_lowercase + string.ascii_uppercase + string.digits + "_+#")


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg,
		usage = "%prog [options] [filename ...]",
		description = "%prog analyzes a collection of sqlite3 database files containing ligolw_burca outputs of string-cusp coincidence events, and measures probability distributions for a variety of parameters computed from those coincidences.  The distributions are written to a likelihood data file in XML format, which can later be used by to assign likelihoods to the coincidences.  The command line arguments are used to provide shell patterns for the files from which to obtain injection and backgroun coincidences.  If file names are given on the command line following the arguments, then likelihood data is loaded from those files and added to the output."
	)
	parser.add_option("-o", "--output", metavar = "filename", default = None, help = "Set the name of the likelihood data file to write (default = stdout).")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("--T010150", metavar = "description", default = None, help = "Write the output to a file whose name is compatible with the file name format described in LIGO-T010150-00-E, \"Naming Convention for Frame Files which are to be Processed by LDAS\".  The description string will be used to form the second field in the file name.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if options.T010150 is not None:
		if options.output is not None:
			raise ValueError, "cannot set both --T010150 and --output"
		if options.T010150 == "":
			options.T010150 = "STRING_LIKELIHOOD"
		elif set(options.T010150) - T010150_letters:
			raise ValueError, "invalid characters in description \"%s\"" % options.T010150

	if not filenames:
		raise ValueError, "no input files!"

	return options, filenames


#
# =============================================================================
#
#                                  Machinery
#
# =============================================================================
#


#
# Coinc params function
#


def coinc_params_func(events, offsetdict):
	params = {}

	#
	# one-instrument parameters
	#

	for event in events:
		prefix = "%s_" % event.ifo

		params["%ssnr2_chi2" % prefix] = (event.snr**2.0, event.chisq / event.chisq_dof)

	#
	# two-instrument parameters
	#

	for event1, event2 in iterutils.choices(sorted(events, lambda a, b: cmp(a.ifo, b.ifo)), 2):
		if event1.ifo == event2.ifo:
			# shouldn't happen, but might as well check for it
			continue

		prefix = "%s_%s_" % (event1.ifo, event2.ifo)

		dt = float((event1.get_peak() + offsetdict[event1.ifo]) - (event2.get_peak() + offsetdict[event2.ifo]))
		params["%sdt" % prefix] = (dt,)

		dA = math.log(abs(event1.amplitude) / abs(event2.amplitude))
		params["%sdA" % prefix] = (dA,)

	#
	# done
	#

	return params


#
# Parameter distributions
#


def dt_binning(instrument1, instrument2):
	dt = 0.02 + inject.light_travel_time(instrument1, instrument2)	# seconds
	return rate.NDBins((rate.ATanBins(-dt, +dt, 12001),))


class DistributionsStats(ligolw_burca_tailor.Stats):
	"""
	A subclass of the Stats class used to populate a
	CoincParamsDistribution instance with the data from the outputs of
	ligolw_burca and ligolw_binjfind.
	"""

	binnings = {
		"H1_snr2_chi2": rate.NDBins((rate.LogarithmicBins(1, 1e8, 12001), rate.LogarithmicBins(.01, 1e8, 12001))),
		"H2_snr2_chi2": rate.NDBins((rate.LogarithmicBins(1, 1e8, 12001), rate.LogarithmicBins(.01, 1e8, 12001))),
		"L1_snr2_chi2": rate.NDBins((rate.LogarithmicBins(1, 1e8, 12001), rate.LogarithmicBins(.01, 1e8, 12001))),
		"V1_snr2_chi2": rate.NDBins((rate.LogarithmicBins(1, 1e8, 12001), rate.LogarithmicBins(.01, 1e8, 12001))),
		"H1_H2_dt": dt_binning("H1", "H2"),
		"H1_L1_dt": dt_binning("H1", "L1"),
		"H1_V1_dt": dt_binning("H1", "V1"),
		"H2_L1_dt": dt_binning("H2", "L1"),
		"H2_V1_dt": dt_binning("H2", "V1"),
		"L1_V1_dt": dt_binning("L1", "V1"),
		"H1_H2_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),)),
		"H1_L1_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),)),
		"H1_V1_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),)),
		"H2_L1_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),)),
		"H2_V1_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),)),
		"L1_V1_dA": rate.NDBins((rate.ATanBins(-3, +3, 12001),))
	}

	filters = {
		"H1_snr2_chi2": rate.gaussian_window2d(11, 11),
		"H2_snr2_chi2": rate.gaussian_window2d(11, 11),
		"L1_snr2_chi2": rate.gaussian_window2d(11, 11),
		"V1_snr2_chi2": rate.gaussian_window2d(11, 11),
		"H1_H2_dt": rate.gaussian_window(11),
		"H1_L1_dt": rate.gaussian_window(11),
		"H1_V1_dt": rate.gaussian_window(11),
		"H2_L1_dt": rate.gaussian_window(11),
		"H2_V1_dt": rate.gaussian_window(11),
		"L1_V1_dt": rate.gaussian_window(11),
		"H1_H2_dA": rate.gaussian_window(11),
		"H1_L1_dA": rate.gaussian_window(11),
		"H1_V1_dA": rate.gaussian_window(11),
		"H2_L1_dA": rate.gaussian_window(11),
		"H2_V1_dA": rate.gaussian_window(11),
		"L1_V1_dA": rate.gaussian_window(11)
	}

	def __init__(self):
		ligolw_burca_tailor.Stats.__init__(self)
		self.distributions = ligolw_burca_tailor.CoincParamsDistributions(**self.binnings)

	def _add_zero_lag(self, param_func, events, offsetdict, *args):
		self.distributions.add_zero_lag(param_func, events, offsetdict, *args)

	def _add_background(self, param_func, events, offsetdict, *args):
		self.distributions.add_background(param_func, events, offsetdict, *args)

	def _add_injections(self, param_func, sim, events, offsetdict, *args):
		self.distributions.add_injection(param_func, events, offsetdict, *args)

	def finish(self):
		self.distributions.finish(filters = self.filters)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line.
#


options, filenames = parse_command_line()


#
# Clear the statistics book-keeping object.
#


segs = segments.segmentlistdict()
stats = DistributionsStats()


#
# Iterate over files
#


for n, filename in enumerate(filenames):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)

	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)

	#
	# Summarize the database.
	#

	database = SnglBurstUtils.CoincDatabase(connection, live_time_program = "StringSearch", search = "StringCusp", verbose = options.verbose)
	if not database.seglists and options.verbose:
		print >>sys.stderr, "\twarning:  no segments found"
	segs |= database.seglists

	#
	# Record statistics.  Assume all files with sim_burst tables are
	# the outputs of injection runs, and others aren't.
	#

	if database.sim_burst_table is None:
		stats.add_noninjections(coinc_params_func, database)
	else:
		stats.add_injections(coinc_params_func, database)

	#
	# Clean up.
	#

	dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)


#
# Output.
#


def T010150_basename(description, seglists):
	seg = seglists.extent_all()
	return "%s-%s-%s-%s" % ("+".join(sorted(seglists.keys())), description, str(seg[0]), str(abs(seg)))

if options.T010150:
	filename = "%s.xml.gz" % T010150_basename(options.T010150, segs)
else:
	filename = options.output

utils.write_filename(ligolw_burca_tailor.gen_likelihood_control(stats.distributions, segs), filename, verbose = options.verbose, gz = (filename or "stdout").endswith(".gz"))
