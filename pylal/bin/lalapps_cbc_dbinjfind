#!/usr/bin/python
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import sys
import numpy
from optparse import OptionParser
from pylal import git_version
from pylal import SnglBurstUtils
from glue.ligolw import dbtables
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw.utils import process
from xml import sax
from glue import iterutils
from glue import lal
from pylal import farutils
from pylal import llwapp

__author__ = "Chad Hanna channa@ligo.caltech.edu"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

def mchirp(m1,m2):
	return (m1+m2)**(0.6) / (m1*m2)**(0.2)

def check_table(xmldoc, tab, choke=False):

	#
	# Find out if there is a table and make one if not
	#

	try:
		ret_tab = table.get_table(xmldoc, tab.tableName)
	except ValueError:
		if choke: raise
		else: ret_tab = lsctables.New(dbtables.TableByName[table.StripTableName(tab.tableName)])
		# FIXME, make this xmldoc extraction work?
		#xmldoc.childNodes[0].appendChild(coinc_event_table)
	return ret_tab

def add_coinc(cetab, cemtab, segs, tsid, cdid, procid, ids, simtime, nevents):
	#
	# first do coinc_event
	#

	row = cetab.RowType()
	row.coinc_event_id = cetab.get_next_id()
	row.nevents = nevents
	row.likelihood = None
	row.set_instruments(segs.keys_at(simtime))
	row.time_slide_id = tsid
	row.coinc_def_id = cdid
	row.process_id = procid #FIXME do a proper process entry
	coinc_event_table.append(row)

	#
	# Then do coinc event map
	#

	for id in ids:
		cemrow = cemtab.RowType()
		cemrow.coinc_event_id = row.coinc_event_id
		cemrow.table_name = lsctables.SimInspiralTable.tableName
		cemrow.event_id = id
		coinc_event_map.append(cemrow)


def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg,
		usage = "%prog [options] [file ...]",
		description = "%prog finds coincidences of inspiral triggers"
	)
	parser.add_option("-i", "--input-cache", metavar = "filename", action = "append", help = "Retrieve database files from this LAL cache.  Can be given multiple times.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-p", "--live-time-program", help="live time program for extracting seglists")
	parser.add_option("-w", "--coinc-window", type="float", default=0.1, help="time window for coincidence, default 0.1 seconds")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()

	if options.input_cache is not None:
		filenames += [lal.CacheEntry(line).path() for filename in options.input_cache for line in file(filename)]

	return options, filenames

options, filenames = parse_command_line()

# initialize some table variables
cetab = None
citab = None
cemtab = None
cdtab = None
ptab = None

#
# This program treats every file as self contained and does not do coincidences across files
#

for filename in filenames:


	#
	# Open database and extract xmldoc
	#

	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	if options.verbose:
                print >>sys.stderr, "\tcalculating coincidences in %s with time window %f" % (working_filename, options.coinc_window)

	dbtables.DBTable_set_connection(connection)
	# pull this XML out so that we can build tables

	# sync the ids
	dbtables.idmap_create(connection)
	dbtables.DBTable.append = dbtables.DBTable._remapping_append
	dbtables.idmap_sync(connection)

	xmldoc = dbtables.get_xml(connection)

	#
	# Setup tables
	#

	# define custom classes if they don't exist
	if not cetab: cetab = dbtables.DBTable(sax.xmlreader.AttributesImpl({"Name":lsctables.CoincTable.tableName}))
	if not cemtab: cemtab = dbtables.DBTable(sax.xmlreader.AttributesImpl({"Name":lsctables.CoincMapTable.tableName}))
	if not cdtab: cdtab = dbtables.DBTable(sax.xmlreader.AttributesImpl({"Name":lsctables.CoincDefTable.tableName}))
	if not citab: citab = dbtables.DBTable(sax.xmlreader.AttributesImpl({"Name":lsctables.CoincInspiralTable.tableName}))
	if not ptab: ptab = dbtables.DBTable(sax.xmlreader.AttributesImpl({"Name":lsctables.ProcessTable.tableName}))

	# Find out if there is a time slide table and barf if not
	time_slide_table = check_table(xmldoc, lsctables.TimeSlideTable, choke=True)
	
	# Find out if there is a sim_inspiral table and barf if not
	sim_inspiral_table = check_table(xmldoc, lsctables.SimInspiralTable, choke=True)

	# Find out if there are other tables and make them if not
	coinc_event_table = check_table(xmldoc, lsctables.CoincTable)
	coinc_event_map = check_table(xmldoc, lsctables.CoincMapTable)
	coinc_definer = check_table(xmldoc, lsctables.CoincDefTable)
	coinc_inspiral_table = check_table(xmldoc, lsctables.CoincInspiralTable)
	process_table = check_table(xmldoc, lsctables.ProcessTable)

	# FIXME get the correct Coinc Def from somewhere in pylal?
	# setup coinc definer row
	CoincDefSimSngl = lsctables.CoincDef(search = u"inspiral", search_coinc_type = 1, description = u"sim_inspiral<-->sngl_inspiral coincidences")
	CoincDefSimSngl.coinc_def_id = coinc_definer.get_next_id()
	coinc_definer.append(CoincDefSimSngl)
	CoincDefSimCoinc = lsctables.CoincDef(search = u"inspiral", search_coinc_type = 2, description = u"sim_inspiral<-->coinc_inspiral coincidences")
	CoincDefSimCoinc.coinc_def_id = coinc_definer.get_next_id()
	coinc_definer.append(CoincDefSimCoinc)

	zero_lag_time_slides, background_time_slides = SnglBurstUtils.get_time_slides(connection)
	# FIXME get the instruments properly
	instruments = zero_lag_time_slides.items()[0][1].keys()
	proc = process.append_process(xmldoc, program = sys.argv[0], version = __version__, cvs_repository = None, cvs_entry_time = None, comment = "cbc db inj find", is_online = False, jobid = 0, domain = None, ifos = instruments)
	process_id = proc.process_id

	#
	# Pull out the seglists and store a copy of the old offsets to use later
	#

	seglists = llwapp.segmentlistdict_fromsearchsummary(xmldoc, options.live_time_program).coalesce()
	old_offsets = seglists.offsets.copy()

	# FIXME injections are assumed to only be done in zero lag
	time_slide_id = zero_lag_time_slides.keys()[0]

	connection.cursor().execute("CREATE TEMPORARY TABLE sims AS SELECT simulation_id AS id, geocent_end_time + geocent_end_time_ns*1e-9 AS time FROM sim_inspiral")
	connection.cursor().execute("CREATE TEMPORARY TABLE sngls AS SELECT event_id AS id, end_time + end_time_ns*1e-9 AS time FROM sngl_inspiral")
	connection.cursor().execute("CREATE TEMPORARY TABLE coincs AS SELECT coinc_inspiral.coinc_event_id AS id, end_time + end_time_ns*1e-9 AS time FROM coinc_inspiral JOIN coinc_event ON coinc_event.coinc_event_id == coinc_inspiral.coinc_event_id WHERE time_slide_id == ?", (time_slide_id,) )
	connection.cursor().execute("CREATE INDEX simtimeix ON sims (time)")
	connection.cursor().execute("CREATE INDEX sngltimeix ON sngls (time)")
	connection.cursor().execute("CREATE INDEX coinctimeix ON sngls (time)")

	if options.verbose: print >>sys.stderr, "Finding sngls in your area...\r", 

	# FIRST do sngl sim coincs
	cnt = 0
	for snglid, simid, sngltime, simtime in connection.cursor().execute("SELECT sngls.id, sngls.time, sims.id, sims.time FROM sngls JOIN sims WHERE sngls.time BETWEEN sims.time - ? AND sims.time + ?", (options.coinc_window, options.coinc_window)):
		cnt+=1
		add_coinc(coinc_event_table, coinc_event_map, seglists, time_slide_id, CoincDefSimSngl.coinc_def_id, process_id, [snglid, simid], simtime, 2)

	if options.verbose: print >>sys.stderr, "Finding sngls in your area...Done I found %d" % (cnt,)

	if options.verbose: print >>sys.stderr, "Fine, you didn't laugh at that last joke\nNow I am looking for coincs...\r",

	# FIRST do coinc sim coincs
	cnt = 0
	for coincid, simid, coinctime, simtime in connection.cursor().execute("SELECT coincs.id, coincs.time, sims.id, sims.time FROM coincs JOIN sims WHERE coincs.time BETWEEN sims.time - ? AND sims.time + ?", (options.coinc_window, options.coinc_window)):
		cnt+=1
		add_coinc(coinc_event_table, coinc_event_map, seglists, time_slide_id, CoincDefSimSngl.coinc_def_id, process_id, [coincid, simid], simtime, 2)

	if options.verbose: print >>sys.stderr, "Now I am looking for coincs...Done I found %d" % (cnt,)

	connection.cursor().execute("DROP INDEX simtimeix")
	connection.cursor().execute("DROP INDEX sngltimeix")
	connection.cursor().execute("DROP INDEX coinctimeix")
	connection.commit()
	dbtables.put_connection_filename(filename, working_filename, verbose = options.verbose)
