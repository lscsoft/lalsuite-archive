#!/usr/bin/python

"""
Add (merge) LIGO Lw XML files containing LSC tables.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"
__version__ = "$Revision$"


#
# Preamble.
#

from optparse import OptionParser
import sys
import urllib
from xml import sax

from glue import lal
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import docutils


#
# Parse command line.
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("-i", "--input-cache", metavar = "CACHEFILE", action = "append", help = "get input files from trigger cache CACHEFILE")
parser.add_option("--merge-processes", action = "store_true", help = "merge identical processes")
parser.add_option("-o", "--output", metavar = "FILENAME", help = "write output to FILENAME (default = stdout")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options, fnames = parser.parse_args()
del parser

# input files
urls = []
if options.input_cache:
	for cache in options.input_cache:
		urls += [c.url for c in map(lal.CacheEntry, file(cache))]


#
# Load all input documents.  The top-level LIGO_LW elements are all
# appended to a single in-RAM document.
#

if len(urls) + len(fnames) < 1:
	raise Exception, "no input files!"

def LoadDocuments(urls, fnames):
	doc = ligolw.Document()
	handler = lsctables.LIGOLWContentHandler(doc)
	for url in urls:
		if options.verbose:
			print >>sys.stderr, "Reading %s" % url
		sax.parse(urllib.urlopen(url), handler)
	for name in fnames:
		if options.verbose:
			print >>sys.stderr, "Reading %s" % name
		sax.parse(file(name), handler)
	return doc

doc = LoadDocuments(urls, fnames)


#
# Reassign process IDs to prevent collisions.
#

class ProcIDs(object):
	def __init__(self):
		self.base = "process:process_id:"
		self.n = 0

	def __iter__(self):
		return self

	def __str__(self):
		return self.base + str(self.n)

	def next(self):
		s = str(self)
		self.n += 1
		return s

new_process_ids = ProcIDs()

def IsProcessTable(elem):
	return lsctables.Is(lsctables.ProcessTable, elem)

def BuildProcessMapping(elem):
	# loop over all process tables below elem, constructing a map of
	# old process ID --> new process ID
	mapping = {}
	for table in elem.getElements(IsProcessTable):
		for key in table.keys():
			mapping[key] = new_process_ids.next()
	return mapping

# loop over all top-level LIGO_LW elements (input documents)
if options.verbose:
	print >>sys.stderr, "Remapping process IDs in each document..."
for elem in doc.getElementsByTagName(ligolw.LIGO_LW.tagName):
	# build process ID mapping
	idmap = BuildProcessMapping(elem)
	if options.verbose:
		print >>sys.stderr, "ID mapping: %s" % str(idmap)

	# loop over recognized LSC tables, replacing process IDs
	docutils.RemapProcessIDs(elem, idmap)


#
# Merge LIGO_LW elements.
#

reduce(docutils.MergeElements, doc.getElementsByTagName(ligolw.LIGO_LW.tagName))


#
# Merge tables of like type.
#

docutils.MergeCompatibleTables(doc)


#
# Search for matching processes, and merge.
#

if options.merge_processes:
	plist = docutils.ProcessList(doc)
	ids = plist.keys()

	idmap = {}
	for i in range(len(ids)):
		for j in range(i + 1, len(ids)):
			if (plist[ids[j]] == plist[ids[i]]) and (ids[j] not in idmap.keys()):
				idmap[ids[j]] = ids[i]

	for id in idmap.keys():
		del plist[id]
	docutils.RemapProcessIDs(doc, idmap)


#
# Write output.
#

if options.verbose:
	print >>sys.stderr, "Writing output..."
if options.output:
	doc.write(file(options.output, "w"))
else:
	doc.write(sys.stdout)
