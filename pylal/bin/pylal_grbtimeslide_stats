#!/usr/bin/env python
#
# Copyright (C) 2007  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Characterize a set of timeslide triggers.
"""

from __future__ import division

import glob
import optparse
import sys
from itertools import *

import numpy

from glue import lal
from glue import segmentsUtils
from glue.segments import segment, segmentlist
from glue.segmentsUtils import segmentlist_range
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils

##############################################################################
# handle user input
parser = optparse.OptionParser(version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob",
    help="glob of zero-lag thinca or thinca slide files to read")
parser.add_option("-i", "--input",
    help="lal cache of zero-lag thinca or thinca slide files to read")
parser.add_option("-o", "--outfile", default="stdout",
    help="write results to output file (default: stdout)")
parser.add_option("-V", "--veto-file",
    help="segwizard file with times to ignore")
parser.add_option("-t", "--fold-time", type="int",
    help="express result in terms of segments of length FOLD_TIME seconds")
(opts, args) = parser.parse_args()

if not ((opts.glob is None) ^ (opts.input is None)):
    print >>sys.stderr, "A glob or input file is required (but not both)"
    sys.exit(2)

if opts.fold_time is None:
    print >>sys.stderr, "A fold time is required."
    sys.exit(2)

if opts.outfile.lower() == "stdout":
    opts.outfile = sys.stdout
else:
    opts.outfile = open(opts.outfile, 'w')

# discover files containing coincs-
if opts.glob is not None:
    files = glob.glob(opts.glob)
else:
    files = [lal.CacheEntry(line).path() for line in open(opts.input)]

##############################################################################
# segment computation
segs = orig_segs = segmentsUtils.fromfilenames(files)

# incorporate veto file
if opts.veto_file is not None:
    segs -= segmentsUtils.fromsegwizard(open(opts.veto_file))

# quantize on fold_time
segs = segmentlist(chain(*[segmentlist_range(a, b, opts.fold_time) for a,b in segs]))

# sanity check: time is quantized correctly
assert (abs(segs) % opts.fold_time) == 0

# count how many fold times we have in a slide
nsegs = abs(segs) // opts.fold_time

##############################################################################
# reconstruct coincidences

# read in, then veto any triggers outside the segments we've decided upon
# NB: Ignoring SnglInspiral.veto() for speed.  lal.LIGOTimeGPS is really
#     slow and we only want second resolution, not nanosecond.
# NB: The coalesce() call makes a large speed difference also because of the
#     numerous 0 second gaps.
veto_segs = (~segs).coalesce()
triggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(files)
triggers = [trig for trig in triggers if trig.end_time not in veto_segs]

dummy_stat = CoincInspiralUtils.coincStatistic('snr')
coincTable = CoincInspiralUtils.coincInspiralTable(triggers, dummy_stat)

##############################################################################
# count coincidences in each opts.fold_time second segment
num_slides = len(coincTable.get_slide_numbers())
trials = numpy.zeros((num_slides, nsegs), dtype=int)
for c in coincTable:
    # NB: c.slide_num indexing OK with current inspiral slide implementation
    trials[c.slide_num, segs.find(getattr(c, c.get_ifos()[1][0]).end_time)] += 1

# sanity check: every coinc has been counted
assert len(coincTable) == trials.sum()

##############################################################################
# output statistics
print >>opts.outfile, "Total number of slides: %d" % num_slides
print >>opts.outfile, "Total time analyzed: %f" % abs(segs)
print >>opts.outfile, "Number of %d second segments per slide: %d" % (opts.fold_time, nsegs)
print >>opts.outfile, "Total number of coincidences: %d" % trials.sum()
print >>opts.outfile, "Mean coincidences per slide per segment: %f" % trials.mean()
print >>opts.outfile, "Stdev of trials: %f" % trials.std()

for i in range(min(10, trials.max())):
  print >>opts.outfile, "p(%d|0): %f" % (i, (trials == i).mean())