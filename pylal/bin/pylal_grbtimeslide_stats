#!/usr/bin/env python
#
# Copyright (C) 2007  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Characterize a set of timeslide triggers.
"""

from __future__ import division

import glob
import optparse
import sys
from itertools import *

import numpy
numpy.seterr(all="raise")

from glue import lal
from glue import segmentsUtils
from glue.segments import segment, segmentlist
from glue.segmentsUtils import segmentlist_range
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw.utils import ligolw_add
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
##############################################################################
# utility functions

def get_num_slides(xmldoc):
    # don't be too picky what program had --num-slides
    slide_params = [int(row.value) for row in table.get_table(xmldoc, lsctables.ProcessParamsTable.tableName) if (row.param == "--num-slides")] + [0]
    return max(slide_params)

##############################################################################
# handle user input
parser = optparse.OptionParser(version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob",
    help="glob of zero-lag thinca or thinca slide files to read")
parser.add_option("-i", "--cache-file",
    help="lal cache of zero-lag thinca or thinca slide files to read")
parser.add_option("-p", "--coinc-pattern",
    help="sieve pattern for coincidences of interest (slide or zerolag)")
parser.add_option("-o", "--outfile", default="stdout",
    help="write results to output file (default: stdout)")
parser.add_option("-V", "--veto-file",
    help="segwizard file with times to ignore")
parser.add_option("-t", "--fold-time", type="int",
    help="express result in terms of trials of length FOLD_TIME seconds")
parser.add_option("-v", "--verbose", action="store_true", default=False,
    help="print extra information to stdout")
(opts, args) = parser.parse_args()

if not ((opts.glob is None) ^ (opts.cache_file is None)):
    print >>sys.stderr, "A glob or input file is required (but not both)"
    sys.exit(2)

if opts.fold_time is None:
    print >>sys.stderr, "A fold time is required."
    sys.exit(2)

if opts.outfile.lower() == "stdout":
    opts.outfile = sys.stdout
else:
    opts.outfile = open(opts.outfile, 'w')

# discover files containing coincs
if opts.glob is not None:
    files = glob.glob(opts.glob)
else:
    cache = lal.Cache.fromfile(open(opts.cache_file), coltype=int)
    cache = cache.sieve(description=opts.coinc_pattern)
    if len(cache) == 0:
        raise ValueError, "no files in cache match coinc pattern"
    present, missing = cache.checkfilesexist()
    if len(missing) > 0:
        raise ValueError, "at least one file in cache does not exist on disk"
    files = present.pfnlist()

##############################################################################
# segment computation
segs = orig_segs = segmentsUtils.fromfilenames(files).coalesce()

# incorporate veto file
if opts.veto_file is not None:
    segs -= segmentsUtils.fromsegwizard(open(opts.veto_file))

# quantize on fold_time
segs = segmentlist(chain(*[segmentlist_range(a, b, opts.fold_time) for a,b in segs]))

# sanity check: time is quantized correctly
assert (abs(segs) % opts.fold_time) == 0

# count how many fold times we have in a slide
nsegs = abs(segs) // opts.fold_time

##############################################################################
# reconstruct coincidences

# read in, then veto any triggers outside the segments we've decided upon
# NB: Ignoring SnglInspiral.veto() for speed.  lal.LIGOTimeGPS is really
#     slow and we only want second resolution, not nanosecond.
# NB: The coalesce() call makes a large speed difference also because of the
#     numerous 0 second gaps.
veto_segs = (~segs).coalesce()

lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID_old(0)
doc = ligolw_add.ligolw_add(ligolw.Document(), files, verbose=opts.verbose)

triggers = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
triggers = [trig for trig in triggers if trig.end_time not in veto_segs]

dummy_stat = CoincInspiralUtils.coincStatistic('snr')
coincTable = CoincInspiralUtils.coincInspiralTable(triggers, dummy_stat)

##############################################################################
# count coincidences in each opts.fold_time second segment
num_slides = get_num_slides(doc)
trials = numpy.zeros((2*num_slides + 1, nsegs), dtype=int)
for c in coincTable:
    # NB: c.slide_num indexing OK with current inspiral slide implementation
    trials[c.slide_num, segs.find(getattr(c, c.get_ifos()[1][0]).end_time)] += 1

# sanity check: every coinc has been counted
assert len(coincTable) == trials.sum()

##############################################################################
# output statistics
total_num_slides = 2 * num_slides or 1
norm = 1 / (total_num_slides * nsegs)
mean = norm * trials.sum()
stdev = numpy.sqrt(norm * ((trials - mean)**2).sum())

print >>opts.outfile, "Total number of slides (pos + neg or zerolag): %d" % total_num_slides
print >>opts.outfile, "Total time analyzed (s): %d" % abs(segs)
print >>opts.outfile, "Number of %d second segments per slide: %d" % (opts.fold_time, nsegs)
print >>opts.outfile, "Total number of coincidences: %d" % len(coincTable)
print >>opts.outfile, "Mean coincidences per slide per segment: %f" % mean
print >>opts.outfile, "Stdev of trials: %f" % stdev

for i in range(min(10, trials.max() + 1)):
    prob = norm * (trials == i).sum()
    print >>opts.outfile, "p(%d|0): %f" % (i, prob)