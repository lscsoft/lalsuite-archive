#!/usr/bin/python

#
# =============================================================================
#
#                    Preamble
#
# =============================================================================
#

__Id__ = "$Id$"
__author__ = "David McKechan"
__title__ = "Track the SNR of found triggers"
__prog__ = "plotinspfound"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


import sys, os, re, glob, exceptions
from optparse import *
from matplotlib.ticker import FormatStrFormatter
from glue import segments
from glue import segmentsUtils
from glue import lal
from glue.ligolw import lsctables
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from pylal import InspiralUtils
from pylal import SimInspiralUtils
import numpy
import matplotlib
matplotlib.use('Agg')
from pylal import followup_missed
from pylab import *


usage =  """Usage: %prog [options]

plotinspfound --cache-file triggers.cache --inj-suffixes INJ1,INJ2 --all-triggers --gps-start-time GPSSTARTTIME --gps-end-time GPSENDTIME --check-mchirp

"""



#
# =============================================================================
#
#                     Parse Command Line
#
# =============================================================================
#

def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage) 
  parser.add_option("-c", "--cache-file", help="LAL cache of relevant files")
  parser.add_option("-e", "--enable-output", action="store_true",\
                     default=False, help="write output to webpage" )
  parser.add_option("-o", "--output-path", action="store", type="string", \
                    default=".", help="specify output path");
  parser.add_option("-t", "--threshold", action="store", type="float", \
                    default=0.001,help="actual loss in  SNR to flag.")
  parser.add_option("-q", "--quiet", action="store_true",\
                     default=False, help="print only error information" )
  parser.add_option("-d", "--vocal", action="store_true",\
                     default=False, help="print some information" )
  parser.add_option("-v", "--verbose",action="store_true",\
                     default=False,help="print all information" )
  parser.add_option("-a", "--all-coire-first",action="store_true",\
                     default=False,help="check injections found at coireFirst \
even if they are missed at coireSecond" )
  parser.add_option("-M", "--check-mchirp",action="store_true",\
                     default=False,help="check the value of mchirp for \
triggers that lose snr" )
  parser.add_option("-C", "--check-chisq",action="store_true",\
                     default=False,help="check the value of chisq for \
coire_first triggers that lose snr" )
  parser.add_option("-N", "--check-eff-snr",action="store_true",\
                     default=False,help="check the value of effective_snr for \
coire_first triggers that lose snr" )
  parser.add_option("-E", "--check-eff-dist",action="store_true",\
                     default=False,help="check the value of eff_dist for \
triggers that lose snr" )
  parser.add_option("-i", "--inj-suffixes",help="analyze only the injection \
runs in this comma separated list" )
  parser.add_option("-V", "--veto-suffix",help="specify coire second triggers \
to analyze." )
  parser.add_option("-A", "--all-triggers",action="store_true",\
                     default=False,help="use ALL triggers" )
  parser.add_option("-H", "--h1-triggers",action="store_true",\
                     default=False,help="use H1 triggers" )
  parser.add_option("-w", "--h2-triggers",action="store_true",\
                     default=False,help="use H2 triggers" )
  parser.add_option("-L", "--l1-triggers",action="store_true",\
                     default=False,help="use L1 triggers" )
  parser.add_option("", "--v1-triggers",action="store_true",\
                     default=False,help="use V1 triggers" )
  parser.add_option("","--gps-start-time",action="store",\
                    type="int",  metavar="GPSSTARTTIME",\
                    help="gps start time")
  parser.add_option("","--gps-end-time",action="store",\
                    type="int",  metavar=" GPSENDTIME",\
                    help="gps end time")
  parser.add_option("-u","--user-tag",action="store", type="string", \
                     default=None,help="specify user tag for file names")
  parser.add_option("--do-followup",action="store_true",\
    default=False,help="activates the followup of missed injections" )

  parser.add_option("--followup-tag",action="store",\
                    default=None,help="followup tag")
  parser.add_option("--followup-exttrig",action="store_true",\
                    default=False,help="followup exttrig")
  parser.add_option("--followup-flow", type="float", \
                    default=40.0, metavar=" F_LOW", help="followup f_low")
  parser.add_option("--figure-resolution",type="int",\
                    default=50, metavar="FIGURERESOLUTION", \
                    help="set the resoultion of the thumbnail (50 dpi by default)" )
  parser.add_option("--followup-time-window",type="float",\
                    default=10.0, metavar="TIME WINDOW IN SECONDS", \
                    help="followup time window in seconds")

  command_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  options = InspiralUtils.initialise(options, __prog__, __version__)
  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()
if opts.verbose:
  opts.vocal = True
comments = ""

if opts.vocal:
  opts.quiet = True
  print "Parsing the command line..."

if opts.cache_file:
  cache = lal.Cache.fromfile( open( opts.cache_file ) )
  missed_cache = cache.sieve( description="COIRE*MISSED" )
else:
  print "--cache-file must be specified!"
  sys.exit()

if not opts.gps_start_time:
  print "ERROR! --gps-start-time must be specified."
  sys.exit()

if not opts.gps_end_time:
  print "ERROR! --gps-end-time must be specified."
  sys.exit()
  
times = segments.segment( opts.gps_start_time, opts.gps_end_time )

injPatterns=[]
if opts.inj_suffixes:
  injPatterns = opts.inj_suffixes.split(",")

if len( injPatterns ) == 0:
  print "ERROR! must specify --inj-suffixes"    
  sys.exit()

if opts.veto_suffix:
  # Remove veto suffix from injPattern
  suf = "_" + opts.veto_suffix.lstrip( "_" )
  injPatterns = [pat[:-len( suf )] + pat[-len( suf ):].replace( suf, "" ) \
                                                       for pat in injPatterns]
else:
   if opts.quiet:
     print "WARNING! --veto-suffix not specified. Are you sure?"

if opts.all_triggers:
  opts.h1_triggers = True
  opts.h2_triggers = True
  opts.l1_triggers = True
  opts.v1_triggers = True

ifos=[]
if opts.h1_triggers:
  ifos.append( "H1" )
if opts.h2_triggers:
  ifos.append( "H2" )
if opts.l1_triggers:
  ifos.append( "L1" )
if opts.v1_triggers:
  ifos.append( "V1" )
if len( ifos ) == 0:
  print "ERROR! must specify one of --h1-triggers, --h2-triggers,", \
        "--l1-triggers, --v1-triggers or --all-triggers"
  sys.exit()

if opts.threshold < 0:
  opts.threshold *= -1
  if opts.quiet:
    print "ERROR! threshold cannot be negative as we compare the magnitude ", \
          "of any changes in SNR. Setting threshold = ", opts.threshold, "."

if opts.threshold == 0:
  if opts.quiet:
    print "ERROR! threshold = 0.0. if plotinspfound cannot find a matching ", \
          "trigger when checking the loss it will set the loss equal to ", \
          "0.0. This can lead to incorrect output. Setting threshold = 0.001.\n"
  opts.threshold = 0.001



# Look at the columns we want to track. chisq will be added later since it does
# is only checked between coire_first and coire_second
check=[]
if opts.check_mchirp:
  check.append( "mchirp" ) 
if opts.check_eff_dist:
  check.append( "eff_distance" )


#
# =============================================================================
#
#                    Specific functions for reading triggers
#
# =============================================================================
#

def get_sire_triggers( opts, ifo, pattern, times ):
  """
  Returns sngl triggers and injections from sire files
  """ 

  trigcache = cache.sieve( ifos = ifo, description = pattern, segment = times )
  trigFiles = trigcache.checkfilesexist()[0].pfnlist()

  if len( trigFiles ) == 0:
    if opts.quiet:
      print "ERROR! Cannot find specified sire files. Check cache file and/or",\
            "specified ifos/injections."
    sys.exit()

  if opts.vocal:
    print "Reading sire files..."
    if opts.verbose:
      for file in trigFiles:
        print file

  triggers  = SnglInspiralUtils.ReadSnglInspiralFromFiles( trigFiles )
  injections = SimInspiralUtils.ReadSimInspiralFromFiles( trigFiles )
  return triggers, injections


##############################################################################
def get_coire_triggers( opts, ifo, pattern, times ):
  """
  Returns sngl triggers from coire files
  """

  trigcache = cache.sieve( ifos = ifo, description = pattern, segment = times )
  trigFiles = trigcache.checkfilesexist()[0].pfnlist()

  if len( trigFiles ) == 0:
    if opts.quiet:
      print "ERROR! Cannot find specified coire files. Check cache file", \
            "and/or specified ifos/injections/gps times.\n"
    sys.exit()

  if opts.vocal:
    print "Reading coire files..."
    if opts.verbose:
      for file in trigFiles:
        print file

  inspTriggers  = SnglInspiralUtils.ReadSnglInspiralFromFiles( trigFiles,
      mangle_event_id = True )
  coincTriggers = CoincInspiralUtils.coincInspiralTable( inspTriggers, \
                             CoincInspiralUtils.coincStatistic( "snr") )
  
  triggers = coincTriggers.getsngls( ifo )

  return triggers



##############################################################################
def get_inspiral_triggers( opts, ifo, pattern, times ):
  """
  Returns sngl triggers from inspiral files
  """

  trigcache = cache.sieve( ifos = ifo, description = pattern, segment = times )
  trigFiles = trigcache.checkfilesexist()[0].pfnlist()

  if len( trigFiles ) == 0:
    if opts.quiet:
      print "ERROR! Cannot find specified inspiral files. Either check cache", \
            "file or remove --check-chisq/--check-eff-snr option(s)."
    sys.exit()


  # This one gets called a lot so we only mention it for verbose
  if opts.verbose:
    print "Reading the following inspiral files..."
    if opts.verbose:
      for file in trigFiles:
        print file

  triggers  = SnglInspiralUtils.ReadSnglInspiralFromFiles( trigFiles )
  
  return triggers



# =============================================================================
#
#                    A new class to store all the info for each ifo
#
# =============================================================================
#

class Triggers( object ):
  """__init__() functions as the class constructor"""
  def __init__( self, injections=None, sirefirst=None, sirefirstTimes=None, \
                   coirefirst=None, coirefirstTimes=None, coiresecond=None, \
                                                     coiresecondTimes=None ):

    Triggers.injections       = injections
    Triggers.sirefirst        = sirefirst
    Triggers.sirefirstTimes   = sirefirstTimes
    Triggers.coirefirst       = coirefirst
    Triggers.coirefirstTimes  = coirefirstTimes
    Triggers.coiresecond      = coiresecond
    Triggers.coiresecondTimes = coiresecondTimes



# =============================================================================
#
#                    Functions that operate on the Trigger class
#
# =============================================================================
#

def get_all_triggers( opts, ifo, injPattern ):
  theseTrigs = Triggers() 
  
  pattern = 'SIRE*FOUND_FIRST*' + injPattern
  [theseTrigs.sirefirst, theseTrigs.injections] = \
                                 get_sire_triggers( opts, ifo, pattern, times ) 
  theseTrigs.sirefirstTimes = \
                          list( theseTrigs.sirefirst.get_column( "end_time" ) )
      
  pattern = 'COIRE*FOUND_FIRST*' + injPattern
  theseTrigs.coirefirst = get_coire_triggers( opts, ifo, pattern, times )      
  theseTrigs.coirefirstTimes = \
                         list( theseTrigs.coirefirst.get_column( "end_time" ) )
      
  pattern = 'COIRE*FOUND_SECOND*' + injPattern 
  if opts.veto_suffix:
    pattern += '*' + opts.veto_suffix
  theseTrigs.coiresecond = get_coire_triggers( opts, ifo, pattern, times )      
  theseTrigs.coiresecondTimes = \
                        list( theseTrigs.coiresecond.get_column( "end_time" ) )

  return theseTrigs



##############################################################################
def search_trigger_times( trigger_times, time):
  """
  triggers may be gps  time +/- 1 second from injection end time.
  """

  if time in trigger_times:
    i = trigger_times.index( time )
  elif time - 1 in trigger_times:
    i = trigger_times.index( time - 1 )
  elif time + 1 in trigger_times:
    i = trigger_times.index( time + 1 )
  else:
    i = -1

  return i



##############################################################################
def check_snr_coirefirst( opts, Triggers, time ):

  foundInj = False
  flagInj  = False
  change   = 0

  if opts.all_coire_first:
    i = search_trigger_times( Triggers.coirefirstTimes, time )
  else:
    i = search_trigger_times( Triggers.coiresecondTimes, time )

  # If we have a coire first trigger then we must find the sire first
  # and check snr.
  if i != -1:
    j = search_trigger_times( Triggers.sirefirstTimes, time )

    if j != -1:
      foundInj = True
      if not opts.all_coire_first:
        i = search_trigger_times( Triggers.coirefirstTimes, time )
      change = Triggers.coirefirst[i].snr - Triggers.sirefirst[j].snr


  if abs( change ) >= opts.threshold:
    flagInj = True

  return flagInj, foundInj



##############################################################################
def check_snr_coiresecond( opts, Triggers, time ):

  foundInj = False
  flagInj  = False
  change = 0;

  i = search_trigger_times( Triggers.coiresecondTimes, time )

  # If we have a coire second trigger then we must find coire first and
  # check the snr.
  if i != -1:
    j = search_trigger_times( Triggers.coirefirstTimes, time )

    if j != -1:
      foundInj = True
      change = Triggers.coiresecond[i].snr - Triggers.coirefirst[j].snr

  if abs( change ) >= opts.threshold:
    flagInj = True

  return flagInj, foundInj



# =============================================================================
#
#                    Functions to write the output to a web page
#
# =============================================================================
#

def write_html_head( opts, injPatterns, title ): 
  """
  Creates a new html document wih the contents for the output
  """

  if opts.vocal:
    print "Initiating output web page..."

  # Begin html
  line = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"'
  line = line + '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> \n'
  fout.write( line )
  line = '<html xmlns="http://www.w3.org/1999/xhtml"> \n'
  fout.write( line )
  line = '<head> \n'
  fout.write( line )
  line = '<meta http-equiv="Content-Type" content="text/html;'
  line = line + ' charset=UTF-8" /> \n'
  fout.write( line )
  line = '<link media="all" href="plotinspfoundstyle.css" type="text/css"'
  line = line + 'rel="stylesheet" /> \n'
  fout.write( line )
  line = '<title>' + title + '</title> \n'
  fout.write( line )
  line = '</head> \n'
  fout.write( line )
  line = '<body> \n\n'
  fout.write( line )

  line = '<h1>' + title +'</h1> \n\n'
  fout.write( line )
  line = '<div class="table-of-contents"> \n'
  fout.write( line )
  line = '<p class="table-of-contents-heading"> Triggers looked at: \n'
  fout.write( line )
  line = '<ol> \n'
  fout.write( line )
  line = '<li><a href="' + title + '#info"> Information </a> \n'
  fout.write( line )

  for j in xrange( len( injPatterns ) ):
    line = '<li><a href="#sireFirst_coireFirst' + injPatterns[j] + '">' 
    line = line + 'Sire first to Coire first' + injPatterns[j] + '</a>\n' 
    fout.write( line )
    line = '<li><a href="#coireFirst_coireSecond' + injPatterns[j] + '">' 
    line = line + 'Coire first to Coire second' + injPatterns[j] + '</a>\n' 
    fout.write( line )

  line = '</li> \n'
  fout.write( line )
  line = '</ol> \n'
  fout.write( line )
  line = '</p> \n'
  fout.write( line )
  line = '</div> \n'
  fout.write( line )
  line = '<a name="info" id="info"></a> \n'
  fout.write( line )
  line = '<h2> Information </h2>'
  fout.write( line )
  line = '<p> User Options: <br /> \n'
  fout.write( line )
  line = '  <code> \n'
  fout.write( line )
  line = ''
  for i in xrange( len( sys.argv ) ):
    line = line + sys.argv[i] + ' '  
  line = line + ' \n'
  fout.write( line )
  line = '  </code> \n'
  fout.write( line )
  line = '</p> \n'
  fout.write( line )



##############################################################################
def write_inj_numbers( opts, numTotal, numFlagged ):
  line = '<p> ' + str( numFlagged ) + '/' + str( numTotal ) 
  line = line + ' injections flagged! </p> \n'
  fout.write( line )



##############################################################################
def write_inj_table( opts, injection ):

  line = '<h4> Injection </h4> \n'
  fout.write( line )

  line = '<table cellpadding=1 border=1> \n'
  fout.write( line )
  line = '<tr> \n'
  fout.write( line )
  line = '  <th> geocent_end_time </th>\n'
  fout.write( line )

  tmpifos = ifos[:]
  sites = []
  # Inside this function, you only need parameters for Hanford, not parameters
  # that are specific to H1 or H2. Hence, remove H2 if both appear.
  if ("H1" in tmpifos) and ("H2" in tmpifos):
    tmpifos.remove("H2")

  for site in tmpifos:
    sites.append(site[0].lower())

  for site in sites:
      line = '  <th> ' + site + '_end_time </th>\n'
      fout.write( line )

  for column in check:
    if column == "eff_distance":
      for site in sites:
        line = '  <th>' + site[0].lower() + '_eff_dist </th> \n'
        fout.write( line )

    elif column != "chisq" and column != "effective_snr":
      line = '  <th>' + column + '</th> \n'
      fout.write( line )
  
  if "SpinTaylor" in injection.waveform:
    line = '  <th> Mass<sub>1</sub> </th> \n'
    fout.write( line )
    line = '  <th> Mass<sub>2</sub> </th> \n'
    fout.write( line )
    line = '  <th> &#967;<sub>1</sub> </th> \n'
    fout.write( line )
    line = '  <th> &#967;<sub>2</sub> </th> \n'
    fout.write( line )

  line = '</tr>'            
  fout.write( line )

  line = '<tr>'            
  fout.write( line )
  line = '  <td align=right bgcolor="#ffffff"> ' 
  line += "%.4f" % (injection.geocent_end_time + injection.geocent_end_time_ns * 1e-9)
  line = line + '</td> \n'
  fout.write( line )

  for site in sites:
    line = '  <td align=right bgcolor="#ffffff"> '
    line += "%.4f" % (getattr(injection, site + "_end_time") + getattr(injection, site + "_end_time_ns") * 1e-9)
    line = line + '</td> \n'
    fout.write( line )

  for column in check:
    if column == "eff_distance":
      for site in sites:
        line = '  <td align=right bgcolor="#ffffff">'
        line = line + '%.4f' % ( getattr(injection, "eff_dist_" + site ) ) + '</td> \n'
        fout.write( line )

    elif column != "chisq" and column !="effective_snr":
      value = getattr( injection,  column )
      line = '  <td align=right bgcolor="#ffffff" >' 
      line = line + '%.4f' %  ( value ) + '</td> \n'
      fout.write( line )

  if "SpinTaylor" in injection.waveform:
    chi1 = sqrt( injection.spin1x * injection.spin1x \
               + injection.spin1y * injection.spin1y \
               + injection.spin1z * injection.spin1z )
 
    chi2 = sqrt( injection.spin2x * injection.spin2x \
               + injection.spin2y * injection.spin2y \
               + injection.spin2z * injection.spin2z )

    line = '  <td> ' + '%.2f' % ( injection.mass1 ) + ' </td> \n'
    fout.write( line )
    line = '  <td> ' + '%.2f' % ( injection.mass2 ) + ' </td> \n'
    fout.write( line )
    line = '  <td> ' + '%.4f' % ( chi1 ) + ' </td> \n'
    fout.write( line )
    line = '  <td> ' + '%.4f' % ( chi2 ) + ' </td> \n'
    fout.write( line )

  line = '</tr> \n'
  fout.write( line )
  line = '</table \n>'
  fout.write( line )




##############################################################################
def write_trig_table_head( opts, check ):

  line = '<h4> Associated triggers </h4> \n'
  fout.write( line )
  line = '<table cellpadding=1 border=1> \n'
  fout.write( line )
  line = '<tr> \n'
  fout.write( line )
  line = '  <th> ifo </th> \n'
  fout.write( line )
  line = '  <th> SNR <br/> before </th> \n'
  fout.write( line )
  line = '  <th> SNR <br/> after </th> \n'
  fout.write( line )
  line = '  <th> end_time / &Delta;t <br/> before</th> \n'
  fout.write( line )
  line = '  <th> end_time / &Delta;t <br/> after</th> \n'
  fout.write( line )
  for column in check:
    line = '  <th>' + column + '<br/> before </th> \n'
    fout.write( line )
    line = '  <th>' + column + '<br/> after</th> \n'
    fout.write( line )
  line = ' </tr> \n'            
  fout.write( line )



##############################################################################
def write_trigger_row( opts, ifo, injPattern, time, trigBefore, trigAfter, \
                                                         injection, check ):

  line = '<tr> \n'            
  fout.write( line )

  line = '  <td>' + ifo + '</td> \n'
  fout.write( line )

  line = '  <td align=right bgcolor="#ffffff">' 
  line = line + '%.4f' % ( trigBefore.snr ) + '</td> \n'
  fout.write( line )

  if trigAfter.snr < trigBefore.snr:
    colour = "#ff0000"
  elif trigAfter.snr > trigBefore.snr:
    colour = "#00ff00"
  else:
    colour = "#50ebec"
  line = '  <td align=right bgcolor="' + colour + '">'
  line = line + '%.4f' % ( trigAfter.snr ) + '</td> \n'
  fout.write( line )

  timeInj = injection.h_end_time + injection.h_end_time_ns/1000000000.0
  timeBefore = trigBefore.end_time + trigBefore.end_time_ns/1000000000.0
  dtBefore = timeBefore - timeInj

  line = '  <td align=center bgcolor="#ffffff">' + '%.4f' % timeBefore + '\n'
  fout.write( line )
  line = '<br/>    &Delta;t = ' + '%.4f' % ( dtBefore ) + '</td> \n'
  fout.write( line )

  timeAfter = trigAfter.end_time + trigAfter.end_time_ns/1000000000.0
  dtAfter = timeAfter - timeInj
  if abs( dtAfter ) < abs( dtBefore ):
    colour = "#00ff00"
  elif abs( dtAfter ) > abs( dtBefore ):
    colour = "#ff0000"
  else:
    colour = "#50ebec"
  line = '  <td align=center bgcolor="' + colour +'">' 
  line = line = line + '%.4f' % timeAfter + '\n'
  fout.write( line )
  line = '<br/>    &Delta;t = ' + '%.4f' % ( dtAfter ) + '</td> \n'
  fout.write( line )


  for column in check:
    if column == "chisq" or column == "effective_snr":
      # Now we need the inspiral tigger!
      inspSegTimes = segments.segment( time - 720, time + 720 )
      pattern = 'INSPIRAL_SECOND*' + injPattern
      inspTrig = get_inspiral_triggers( opts, ifo, pattern, inspSegTimes )
      inspTimes = list( inspTrig.get_column( "end_time" ) )
      inspTimesNS = list( inspTrig.get_column( "end_time_ns" ) )
      
      value = 'unset' 
      if time in inspTimes:
        k = inspTimes.index( time )
        flag = 0
        while not flag:
          try:
            if inspTimesNS[k] == trigBefore.end_time_ns:
              flag = 1
            else:
              k += 1
          except IndexError:
            k -= 1
            flag = 1
            value = 'not found'
      else:
        value = 'not found'               

      if column == "chisq":
        if value == "unset":
          value = inspTrig[k].chisq

        valueAfter = trigAfter.chisq 
        if valueAfter < value:
          colour = "#00ff00"
        elif valueAfter > value:
          colour = "#ff0000"
        else:
          colour = "#50ebec"
    
      elif column == "effective_snr":
        if value == "unset":
          value = inspTrig[k].get_effective_snr()

        valueAfter = trigAfter.get_effective_snr()
        if valueAfter > value:
          colour = "#00ff00"
        elif valueAfter < value:
          colour = "#ff0000"
        else:
          colour = "#50ebec"
     
      if value == "not found":
        line = '  <td align=right bgcolor="#ffffff"> not found </td> \n'
        fout.write( line )
        colour = "#50ebec"
      else:
        line = '  <td align=right bgcolor="#ffffff"> '
        line = line + '%.4f' % ( value )  + ' </td> \n'
        fout.write( line )
      line = '  <td align=right bgcolor="' + colour + '">' 
      line = line + '%.4f' % ( valueAfter ) + '</td> \n'
      fout.write( line )


    else:
      if column == "eff_distance":
        injColumn = "eff_dist_" + ifo[0].lower()

      else:
        injColumn = column
      injValue = getattr( injection, injColumn )

      valueBefore = getattr( trigBefore, column )
      line = '  <td align=right bgcolor="#ffffff">' 
      line = line + '%.4f' % ( valueBefore ) + '</td> \n'
      fout.write( line )

      valueAfter = getattr( trigAfter, column )
      deltaBefore = abs( valueBefore - injValue )
      deltaAfter = abs( valueAfter - injValue )
      if deltaAfter < deltaBefore:
        colour = "#00ff00"
      elif deltaAfter > deltaBefore:
        colour = "#ff0000"
      else:
        colour = "#50ebec"
      
      line = '  <td align=right bgcolor="' + colour + '">' 
      line = line + '%.4f' % ( valueAfter ) + '</td> \n'
      fout.write( line )

  line = '</tr> \n'
  fout.write( line )




##############################################################################
def write_html_line():
  line = '\n <hr /> \n\n'
  fout.write(line)



##############################################################################
def write_html_tail(opts):
  """
  Finalize  the output web page
  """
  if opts.vocal:
    print "Finalising the output web page..."

  # End html
  line = '</body> \n'
  fout.write(line)
  line = '</html> \n'
  fout.write(line)


#
# =============================================================================
#
#                    Main
#
# =============================================================================
#

# Begin summary page
if opts.enable_output:
  htmlfile = opts.output_path + "/" + opts.prefix + opts.suffix + ".html"
  fout = open( htmlfile,"w" )
  write_html_head( opts, injPatterns, htmlfile )

  if opts.do_followup:
    followup = followup_missed.FollowupMissed( cache, opts )

for injPattern in injPatterns:

  if opts.vocal:
    print "Checking", injPattern, "triggers."

  # Get triggers and injections
  injections = lsctables.New( lsctables.SimInspiralTable )
  injTimes = []

  trigList = [get_all_triggers( opts, ifo, injPattern ) for ifo in ifos]

  for (ifo,trigs) in zip(ifos,trigList):
    
    for inj in trigs.injections:
      if inj.geocent_end_time not in injTimes:
        injections.append( inj )
        injTimes.append( inj.geocent_end_time )

  # ==========================================================================
  # -- sirefirst to coirefirst
  if opts.vocal:
    print "Checking snr changes between sire first and coire first."

  if opts.enable_output:
    # Inset Anchor
    line = '<a name="sireFirst_coireFirst'  + injPattern + '" \n'
    fout.write(line)
    line = 'id="sireFirst_coireFirst' + injPattern + '"></a> \n'
    fout.write(line)
    line = '<h1> Sire first to Coire first, ' + injPattern + '</h1> \n'
    fout.write(line)



  # Find triggers whose SNRs change and index the injections.
  injIndex = []
  injFound = []

  for x in xrange( len( injections ) ):
    inj = injections[x]
     
    for (ifo, trigs) in zip(ifos, trigList):
      time = getattr(inj, ifo[0].lower() + "_end_time")
      flagInj, foundInj = check_snr_coirefirst( opts, trigs, time )
      if flagInj:
        if x not in injIndex:
          injIndex.append( x )
      if foundInj and x not in injFound:
        injFound.append( x )

  if opts.enable_output:
    write_inj_numbers( opts, len( injFound ), len( injIndex ) )
  if opts.vocal:
    print len( injIndex ), "/", len( injFound ), \
       "found injections with loss in SNR between sire first and coire first!"


  for index in injIndex:
    
    if opts.enable_output:
      write_html_line()
      write_inj_table( opts, injections[index] )
      write_trig_table_head( opts, check )

    for (ifo, trigs) in zip(ifos, trigList):
      time = getattr(injections[index], ifo[0].lower() + "_end_time")
      i = search_trigger_times( trigs.coirefirstTimes, time )
      if i != -1:
        j = search_trigger_times( trigs.sirefirstTimes, time )
        if j != -1:
          trigBefore = trigs.sirefirst[j]
          trigAfter  = trigs.coirefirst[i]
          if opts.enable_output:
            write_trigger_row( opts, ifo, injPattern, time, trigBefore, \
                               trigAfter, injections[index], check )



    if opts.enable_output:
      line = '</table> \n'
      fout.write( line )

      if opts.do_followup:
        followup.setTag( "TEST" )
        followuphtml = followup.followup( injections[index], "H1", injPattern )
        line = '<a href=\"' + followuphtml + '\" target=\"_blank\">'
        line += 'details here</a>'
        fout.write( line )




  # ========================================================================
  # -- coirefirst to coiresecond
  if opts.vocal:
    print "Checking snr changes between coire first and coire second."

  if opts.enable_output:
    # Insert Anchor
    line = '<a name="coireFirst_coireSecond'  + injPattern + '" \n'
    fout.write( line )
    line = 'id="coireFirst_coireSecond' + injPattern + '"></a> \n'
    fout.write( line )
    line = '<h1> Coire first to Coire second, ' + injPattern + '</h1> \n'
    fout.write( line )

  if opts.check_chisq:
    check.append( "chisq" )
  if opts.check_eff_snr:
    check.append( "effective_snr" )
      
  # Find triggers whose SNRs change and index the injections.
  injIndex = []
  injFound = []

  for x in xrange( len( injections ) ):
    inj = injections[x]

    for (ifo, trigs) in zip(ifos, trigList):
      time = getattr(inj, ifo[0].lower() + "_end_time")
      flagInj, foundInj = check_snr_coiresecond( opts, trigs, time )
      if flagInj:
        if x not in injIndex:
          injIndex.append( x )
      if foundInj:
        if x not in injFound:
          injFound.append( x )

  if opts.enable_output:
    write_inj_numbers( opts, len( injFound ), len( injIndex ) )
  if opts.vocal:
    print len( injIndex ), "/", len( injFound ), \
      "found injections with loss in SNR between coire first and coire second!"


  for index in injIndex:

    if opts.enable_output:
      write_html_line()  
      write_inj_table( opts, injections[index] )
      write_trig_table_head( opts, check )
      
    for (ifo, trigs) in zip(ifos, trigList):
      time = getattr(injections[index], ifo[0].lower() + "_end_time")
      i = search_trigger_times( trigs.coiresecondTimes, time)
      if i != -1:
        j = search_trigger_times( trigs.coirefirstTimes, time )
        if j != -1:
          trigBefore = trigs.coirefirst[j]
          trigAfter  = trigs.coiresecond[i]
          if opts.enable_output:
            write_trigger_row( opts, ifo, injPattern, time, trigBefore, \
                               trigAfter, injections[index], check )

    if opts.enable_output:
      line = '</table> \n'
      fout.write( line )

      if opts.do_followup:
        followup.setTag( "TEST")
        followuphtml = followup.followup( injections[index], "H1", injPattern )
        line = '<a href=\"' + followuphtml + '\" target=\"_blank\">'
        line += 'details here</a>'
        fout.write( line )
 

  if opts.check_eff_snr:
    check.pop()
  if opts.check_chisq:
    check.pop()



if opts.enable_output:
  # End summary page
  write_html_tail( opts )
  fout.close()
  
  if opts.do_followup:
    fnameList =  followup.fnameList 
    InspiralUtils.write_cache_output( opts, htmlfile, fnameList )



