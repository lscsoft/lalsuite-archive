#!/usr/bin/python

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import os,matplotlib
matplotlib.use('Agg' )
import pylab
from datetime import datetime
from math import pi,sqrt
import scipy.stats
from optparse import OptionParser
from pylal import date
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from glue.ligolw import table,lsctables,utils
from pylal.coh_PTF_pyutils import *

# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():

  usage = """usage: %prog [options] 
  
coh_PTF_sbv_plotter will calculate all signal based vetoes and the final detection statistics, whilst plotting a whole bunch of stuff. Required arguments

--trig-file
--grb-name
"""

  parser = OptionParser( usage )

  parser.add_option( "-v", "--verbose", action="store_true", default=False,\
                     help="verbose output, default: %default" )

  parser.add_option( "-t", "--trig-file", action="store", type="string",\
                     default=None, help="The location of the trigger file" )

  parser.add_option( "-I", "--inj-file", action="store", type="string",\
                     default=None, help="The location of the injection file" )

  parser.add_option( "-n", "--grb-name", action="store", type="string",\
                     default=None, help="Name of the GRB such as 090802" )

  parser.add_option( "-o", "--output-path", action="store", type="string",\
                     default=os.getcwd(), help="output directory, "+\
                                               "default: %default" )

  parser.add_option( "-Q", "--chisq-index", action="store", type="float",\
                     default=4.0, help="chisq_index for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-N", "--chisq-nhigh", action="store", type="float",\
                     default=3.0, help="nhigh for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-A", "--null-snr-threshold", action="store",\
                     type="string", default="3.5,5.25",\
                     help="comma separated lower,higher null SNR thresholds, "+\
                          " for null SNR cut, default: \"%default\"" )

  (opts,args) = parser.parse_args()

  if not opts.trig_file:
    parser.error( "must provide trig file" )

  if not opts.grb_name:
    parser.error( "must provide --grb-name" )

  return opts, args

# =============================================================================
# Main function
# =============================================================================

def main( trigFile, injFile, tag, outdir, chisq_index=4.0, chisq_nhigh=3.0,\
          null_thresh=[3.5,5.25], verbose=False ):
  
  # set output directory
  if not os.path.isdir(outdir):
    os.makedirs(outdir)
  
  # get rcParams
  makePaperPlots()
  
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading triggers...'
 
  # load triggers
  xmldoc = utils.load_filename( trigFile, gz=trigFile.endswith("gz" ) )
  trigs  = table.get_table( xmldoc, lsctables.MultiInspiralTable.tableName )
  searchSumm = table.get_table( xmldoc, lsctables.SearchSummaryTable.tableName )

  # extract variables
  ifos = sorted( map( str, searchSumm[0].get_ifos() ) )
  ifoAtt = { 'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t' }

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading injections...'

  # load injections
  if injFile:
    xmldoc = utils.load_filename( injFile, gz=injFile.endswith("gz" ))
    injs = table.get_table( xmldoc, lsctables.MultiInspiralTable.tableName )

  if len(trigs)<1:
    print >>sys.stderr, 'WARNING: No triggers found.'

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Extracting and calculating parameters...'

  # initiate trigger lists
  trigTime      = []
  trigSNR       = []
  trigBestNR    = []
  trigNullstat  = []
  trigTraceSNR  = []
  trigChiSquare = []
  trigBankVeto  = []
  trigAutoVeto  = []
  trigCoincSNR  = []
  trigFirstSNR  = []
  trigSecondSNR = []
  trigThirdSNR  = []
  # initiate injection lists
  injTime       = []
  injSNR        = []
  injBestNR     = []
  injNullstat   = []
  injTraceSNR   = []
  injChiSquare  = []
  injBankVeto   = []
  injAutoVeto   = []
  injCoincSNR   = []
  injFirstSNR   = []
  injSecondSNR  = []
  injThirdSNR   = []
  # initiate amplitude lists for 4 amplitudes
  numAmp  = 4
  amplitudes = xrange(1,numAmp+1)
  trigAmp = {}
  injAmp  = {}
  for amp in amplitudes:
    trigAmp[amp] = []
    injAmp[amp]  = []

  # initiate single IFO lists
  trigIfoSNR = {}
  trigSigma  = {}
  injIfoSNR  = {}
  injSigma   = {}
  for ifo in ifos:
    trigIfoSNR[ifo] = []
    trigSigma[ifo] = []
    injIfoSNR[ifo] = []
    injSigma[ifo] = []
  trigSigmaTot = []

  null_grad_snr = 30
 
  aPat  = {}
  fResp = {}
  for ifo in ifos:
    fResp[ifo] = [] 

  # get trigger parameters
  for trig in trigs:

    # calculate fResp for each IFO is we haven't done so already
    trigPos = (trig.ra,trig.dec)
    if trigPos not in aPat.keys():
      ra  = trig.ra*180/pi
      dec = trig.dec*180/pi
      fPlus,fCross  = get_det_response( ra, dec, trig.get_end() )
      aPat[trigPos] = {}
      for ifo in ifos:
        aPat[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]
    
    for ifo in ifos:
      fResp[ifo].append( aPat[trigPos][ifo] )

    # extract basic parameters
    trigTime.append(     trig.get_end() )
    trigSNR.append(      trig.snr )
    trigNullstat.append( trig.null_statistic )
    trigTraceSNR.append( trig.null_stat_degen )

    # extract single IFO SNRs and trig sigma
    sigmaTot = 0
    compsList = []
    for ifo in ifos:
      ifoSNR = getattr(trig,'snr_%s' % ifoAtt[ifo])
      trigIfoSNR[ifo].append( ifoSNR )
      compsList.append( ifoSNR )
      sig = getattr(trig,'sigmasq_%s' % ifoAtt[ifo])
      trigSigma[ifo].append( sig )
      sigmaTot += sig * aPat[trigPos][ifo]
    trigSigmaTot.append(sigmaTot)

    compsList.sort(reverse=True)
    trigFirstSNR.append( (compsList[0] ) )
    if len(ifos)>1:
      trigSecondSNR.append( (compsList[1]) )
    if len(ifos)>2:
      trigThirdSNR.append( (compsList[2])) 
    # calculate coinc SNR
    trigCoincSNR.append( sqrt(sum([ e**2 for e in compsList ])) )
  
    # get signal based tests
    if trig.chisq == 0:
      trigChiSquare.append( 0.0001 )
    else:
      trigChiSquare.append( trig.chisq )
    trigBankVeto.append( trig.bank_chisq )
    trigAutoVeto.append( trig.cont_chisq )

    for amp in amplitudes:
      a = getattr(trig,'amp_term_%d' % amp)
      if a == 0:
        a = 0.0001
      trigAmp[amp].append(a)

    bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                         null_thresh=null_thresh, fResp=aPat[trigPos])
    trigBestNR.append( bestNR )

  # get injection parameters 
  if injFile:
    for trig in injs:

      # calculate fResp for each IFO is we haven't done so already
      trigPos = (trig.ra,trig.dec)
      if trigPos not in aPat.keys():
        ra  = trig.ra*180/pi
        dec = trig.dec*180/pi
        fPlus,fCross   = get_det_response( ra, dec, segs['on'][-1]-1 )
        aPat[trigPos] = {}
        for ifo in ifos:
          aPat[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]

      # extract basic parameters
      injTime.append(     trig.get_end() )
      injSNR.append(      trig.snr )
      injNullstat.append( trig.null_statistic )
      injTraceSNR.append( trig.null_stat_degen )

      # extract single IFO SNRs
      compsList = []
      for ifo in ifos:
        ifoSNR = getattr(trig,'snr_%s' % ifoAtt[ifo])
        injIfoSNR[ifo].append( ifoSNR )
        compsList.append( ifoSNR )

      compsList.sort(reverse=True)
      injFirstSNR.append( (compsList[0] ) )
      if len(ifos)>1:
        injSecondSNR.append( (compsList[1]) )
      if len(ifos)>2:
        injThirdSNR.append( (compsList[2]))
      injCoincSNR.append( sqrt(sum([ e**2 for e in compsList ])) )

      if trig.chisq == 0:  
        injChiSquare.append( 0.0001 )
      else:
        injChiSquare.append( trig.chisq )
      injBankVeto.append( trig.bank_chisq )
      injAutoVeto.append( trig.cont_chisq )
      for amp in amplitudes:
        a = getattr(trig,'amp_term_%d' % amp)
        if a == 0:
          a = 0.0001
        injAmp[amp].append(a)

      bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                           null_thresh=null_thresh, fResp=aPat[trigPos])

      injBestNR.append( bestNR )

  # set arrays
  trigSNR       = pylab.asarray( trigSNR )
  trigBestNR = pylab.asarray( trigBestNR )
  trigChiSquare = pylab.asarray( trigChiSquare )
  trigNullstat  = pylab.asarray( trigNullstat )
  trigTraceSNR  = pylab.asarray( trigTraceSNR )
  trigCoincSNR  = pylab.asarray( trigCoincSNR )
  trigNullSNR = ( trigCoincSNR**2 - trigSNR**2)**0.5
  for amp in amplitudes:
    trigAmp[amp]   = pylab.asarray( trigAmp[amp] )
  trigRelAmp1    = pylab.sqrt( ( trigAmp[1]**2 + trigAmp[2]**2)/\
                               ( trigAmp[3]**2 + trigAmp[4]**2) )
  trigGammaR     = trigAmp[1] - trigAmp[4]
  trigGammaI     = trigAmp[2] + trigAmp[3]
  trigDeltaR     = trigAmp[1] + trigAmp[4]
  trigDeltaI     = trigAmp[3] - trigAmp[2]
  trigNorm1      = trigDeltaR*trigDeltaR + trigDeltaI*trigDeltaI
  trigNorm2      = trigGammaR*trigGammaR + trigGammaI*trigGammaI
  trigNorm3      = (( trigNorm1**0.25) + (trigNorm2**0.25))**2
  trigAmpPlus    = ( trigNorm1)**0.5 + (trigNorm2)**0.5
  trigAmpCross   = (( trigNorm1)**0.5 - (trigNorm2)**0.5).__abs__()
  trigRelAmp2    = trigAmpPlus/trigAmpCross
  trigInclination = trigAmpCross/trigNorm3
  for ifo in ifos:
    fResp[ifo] = pylab.asarray(fResp[ifo]).mean()

  # normalise trigSigma
  for ifo in ifos:
    trigSigma[ifo] = pylab.asarray( trigSigma[ifo] )
  trigSigmaTot = numpy.array(trigSigmaTot)
  for ifo in ifos:
    trigSigma[ifo] /= trigSigmaTot

  if injFile:
    injSNR         = pylab.asarray( injSNR )
    injBestNR      = pylab.asarray( injBestNR )
    injChiSquare   = pylab.asarray( injChiSquare )
    injNullstat    = pylab.asarray( injNullstat )
    injTraceSNR    = pylab.asarray( injTraceSNR )
    injCoincSNR    = pylab.asarray( injCoincSNR )
    injNullSNR   = ( injCoincSNR**2 - injSNR**2)**0.5
    for amp in amplitudes:
      injAmp[amp]  = pylab.asarray( injAmp[amp] )
    injRelAmp1     = pylab.sqrt( ( injAmp[1]**2 + injAmp[2]**2)/\
                                 ( injAmp[3]**2 + injAmp[4]**2) )
    injGammaR      = injAmp[1] - injAmp[4]
    injGammaI      = injAmp[2] + injAmp[3]
    injDeltaR      = injAmp[1] + injAmp[4]
    injDeltaI      = injAmp[3] - injAmp[2]
    injNorm1       = injDeltaR*injDeltaR + injDeltaI*injDeltaI
    injNorm2       = injGammaR*injGammaR + injGammaI*injGammaI
    injNorm3       = (( injNorm1**0.25) + (injNorm2**0.25))**2
    injAmpPlus     = ( injNorm1)**0.5 + (injNorm2)**0.5
    injAmpCross    = (( injNorm1)**0.5 - (injNorm2)**0.5).__abs__()
    injRelAmp2     = injAmpPlus/injAmpCross
    injInclination = injAmpCross/injNorm3
  
  trigSigmaMean = {}
  trigSigmaMax  = {}
  trigSigmaMin  = {}
  for ifo in ifos:
    try:
      trigSigmaMean[ifo] = trigSigma[ifo].mean()
      trigSigmaMax[ifo]  = trigSigma[ifo].max()
      trigSigmaMin[ifo]  = trigSigma[ifo].min()
    except ValueError:
      trigSigmaMean[ifo] = 0
      trigSigmaMax[ifo]  = 0
      trigSigmaMin[ifo]  = 0

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, "Loudest trigger by SNR: %f" % trigSNR.max()
    print >>sys.stdout, "Loudest trigger by BestNR: %f" % trigBestNR.max()
  
  bank_conts, auto_conts,chi_conts,null_cont,snr_vals, colors =\
      calculate_contours( q=chisq_index, n=chisq_nhigh,\
                          null_thresh=null_thresh[-1],\
                          null_grad_snr=null_grad_snr )
  
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Plotting...'

  ptfcolormap = pylab.cm.spring
  ptfcolormap.set_over('g' )
       
  # reset times
  start = int(min(trigTime))
  end   = int(max(trigTime)+1)-start
  trigTime = [ t-start for t in trigTime ]
  injTime  = [ t-start for t in injTime ]
  startString = datetime( *date.XLALGPSToUTC( LIGOTimeGPS( start ) )[:6] )\
                    .strftime( "%B %d %Y, %H:%M:%S %ZUTC" )
 
  # plot time versus SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigSNR, 'bx' )
  ax.set_xlabel( "Time since %s" % start )
  ax.set_xlim([ 0, end ])
  ax.set_ylabel( "Coherent SNR" )
  #ax.set_ylim( [6,18])
  fig.savefig( '%s/%s_triggers_vs_time_noinj.png' % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injTime, injSNR, 'rx' )
    ax.set_xlim([ 0, end ])
    fig.savefig( '%s/%s_triggers_vs_time.png' % ( outdir, tag ),\
               bbox_inches='tight' )

  # plot BestNR versus time
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigBestNR, 'bx' )
  ax.set_xlabel( "Time since %s" % start )
  ax.set_xlim([ 0, end ])
  ax.set_ylabel( "BestNR" )
  #ax.set_ylim( [6,18])
  fig.savefig( '%s/%s_bestnr_vs_time_noinj.png' % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injTime, injBestNR, 'rx' )
    ax.set_xlim([ 0, end ])
    fig.savefig( '%s/%s_bestnr_vs_time.png' % ( outdir, tag ),\
                 bbox_inches='tight' )
 
 
  # plot ifo time versus SNR
  for ifo in ifos:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigTime, trigIfoSNR[ifo], 'bx' )
    ax.set_xlabel( "Time since %s" % start )
    ax.set_xlim([ 0, end ])
    ax.set_ylabel( "%s SNR" % ifo )

    fig.savefig( '%s/%s_%s_triggers_vs_time_noinj.png'\
                 % ( outdir, tag, ifo ))
    if injFile:
      ax.plot( injTime, injIfoSNR[ifo], 'rx' )
      ax.set_xlim([ 0, end ])
      fig.savefig( '%s/%s_%s_triggers_vs_time.png'\
                   % ( outdir, tag, ifo ) )
  
  # plot coherent SNR versus null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigNullstat, 'bx' )
  if injFile:
    ax.plot( injSNR, injNullstat, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Null statistic" )
  ax.plot( snr_vals,null_cont, 'k-' )
  fig.savefig( "%s/%s_null_stat_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.plot( [0,30], [3.5,3.5], 'g-' )
  ax.plot( [0,30], [4.5,4.5], 'm-' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_null_stat_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot coherent SNR versus overwhitened null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigNullSNR, 'bx' )
  if injFile:
    ax.plot( injSNR, injNullSNR, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Overwhitened null statistic" )
  ax.plot( snr_vals,null_cont, 'k-' )
  fig.savefig( "%s/%s_null_stat2_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.plot( [0,30], [3.5,3.5], 'g-' )
  ax.plot( [0,30], [4.5,4.5], 'm-' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_null_stat2_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
 
  # plot coherent SNR versus coinc SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigCoincSNR, 'bx' )
  if injFile:
    ax.plot( injSNR, injCoincSNR, 'rx' )
  ax.plot( [4,30], [4,30], 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Coincidence SNR" )
  fig.savefig( "%s/%s_coinc_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [4,30] )
  fig.savefig( "%s/%s_coinc_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  aT = [6,30]
  bT = [6,27.5]
  
  maxSNR = trigSNR.max()
  if injFile:
    if injSNR.max() > maxSNR:
      maxSNR = injSNR.max()
  zoomSNR = pylab.arange(0.01,maxSNR,0.01)
 
  # plot SNR versus traceSNR 
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigTraceSNR, 'bx' )
  if injFile:
    ax.plot( injSNR, injTraceSNR, 'rx' )
  ax.plot( aT, bT, 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Trace SNR" )
  fig.savefig( "%s/%s_trace_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [4,30] )
  fig.savefig( "%s/%s_trace_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot coinc SNR versus trace SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigCoincSNR, trigTraceSNR, 'bx' )
  if injFile:
    ax.plot( injCoincSNR, injTraceSNR, 'rx' )
  ax.set_xlabel( "Coincidence SNR" )
  ax.set_ylabel( "Trace SNR" )
  fig.savefig( "%s/%s_trace_snr_vs_coinc_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [0,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_trace_snr_vs_coinc_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus bank veto
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigBankVeto, 'bx' )
  if injFile:
    ax.loglog( injSNR, injBankVeto, 'rx' )
  plot_contours( ax, snr_vals,bank_conts, colors )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Bank Veto" )
  ax.set_xlim( [6,1000] )
  fig.savefig( "%s/%s_bank_veto_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,50] )
  ax.set_ylim( [1,2000] )
  fig.savefig( "%s/%s_bank_veto_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus \chi^2
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigChiSquare, 'bx' )
  if injFile:
    ax.loglog( injSNR, injChiSquare, 'rx' )
  plot_contours( ax, snr_vals,chi_conts, colors )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Chi Square" )
  ax.set_xlim( [6,1000] )
  fig.savefig( "%s/%s_chi_square_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,50] )
  ax.set_ylim( [1,2000] )
  fig.savefig( "%s/%s_chi_square_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus chisq
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR[trigBestNR != 0], trigChiSquare[trigBestNR != 0],\
             'bx' )
  if injFile:
    ax.loglog( injSNR[injBestNR != 0], injChiSquare[injBestNR != 0],\
               'rx' )
  plot_contours( ax, snr_vals,chi_conts, colors )
  ax.set_xlabel( "SNR" )
  ax.set_ylabel( "Chi Square" )
  ax.set_xlim( [6,1000] )
  fig.savefig( "%s/%s_chi_square_vs_snr.png" % ( outdir, tag ) )
  ax.set_xlim( [0,50] )
  ax.set_ylim( [1,2000] )
  fig.savefig( "%s/%s_chi_square_vs_snr_zoom.png" % ( outdir, tag ) )
  
  # plot SNR versus loudest SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigFirstSNR, 'bx' )
  if injFile:
    ax.plot( injSNR, injFirstSNR, 'rx' )
  ax.plot( [0,50], [4,4], 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "First loudest sngl SNR" )
  fig.savefig( "%s/%s_first_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,50] )
  ax.set_ylim( [0,20] )
  fig.savefig( "%s/%s_first_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus second loudest
  if len(ifos)>1:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigSecondSNR, 'bx' )
    if injFile:
      ax.plot( injSNR, injSecondSNR, 'rx' )
    ax.plot( [6,10,50], [2.5,3.5,13.5], 'g-' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Second loudest sngl SNR" )
    fig.savefig( "%s/%s_second_snr_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_second_snr_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  
  # plot SNR versus third loudest SNR
  if len(ifos)>2:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigThirdSNR, 'bx' )
    if injFile:
      ax.plot( injSNR, injThirdSNR, 'rx' )
    ax.plot( [0,50], [4,4], 'g-' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Third loudest sngl SNR" )
    fig.savefig( "%s/%s_third_snr_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_third_snr_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  
  # plot SNR versus IFO SNR
  for ifo in ifos:

    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigIfoSNR[ifo], 'bx' )
    if injFile:
      ax.plot( injSNR, injIfoSNR[ifo], 'rx' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMean[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMin[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMax[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 0.0455/2., 2,\
                                            (fResp[ifo]*trigSigmaMin[ifo])*\
                                             zoomSNR**2)**0.5, 'm-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 1-0.0455/2., 2,\
                                            (fResp[ifo]*trigSigmaMax[ifo])*\
                                             zoomSNR**2)**0.5, 'm-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 0.00135/2., 2,\
                                            (fResp[ifo]*trigSigmaMin[ifo])*\
                                             zoomSNR**2)**0.5, 'c-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 1-0.00135/2., 2,\
                                            (fResp[ifo]*trigSigmaMax[ifo])*\
                                             zoomSNR**2)**0.5, 'c-' )
    ax.plot( [0,50], [4,4], 'k-' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "%s sngl SNR" % ifo )
    fig.savefig( "%s/%s_%s_snr_vs_snr.png" % ( outdir, tag, ifo ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_%s_snr_vs_snr_zoom.png" % ( outdir, tag, ifo ),\
                 bbox_inches='tight' )
  
  # plot SNR versus auto veto 
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigAutoVeto, 'bx' )
  if injFile:
    ax.loglog( injSNR, injAutoVeto, 'rx' )
  plot_contours( ax, snr_vals, auto_conts, colors )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Auto Veto" )
  fig.savefig( "%s/%s_auto_veto_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [10,20000] )
  fig.savefig( "%s/%s_auto_veto_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus SNR-traceSNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigSNR - trigTraceSNR, 'bx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "SNR - Trace SNR" )
  fig.savefig( "%s/%s_tracediff_noinj.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injSNR, injSNR - injTraceSNR, 'rx' )
    fig.savefig( "%s/%s_trace_diff_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
    ax.set_xlim( [6,20] )
    ax.set_ylim( [-5,10] )
    fig.savefig( "%s/%s_trace_diff_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot time versus null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigNullstat, 'bx' )
  if injFile:
    ax.plot( injTime, injNullstat, 'rx' )
  ax.set_xlabel( "Time since %s" % start )
  ax.set_xlim([ 0, end ])
  ax.set_ylabel( "Null SNR" )
  fig.savefig( "%s/%s_null_snr_vs_time.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus rel amp
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigRelAmp1, 'bx' )
  if injFile:
    ax.loglog( injSNR, injRelAmp1, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Relative amplitude" )
  fig.savefig( "%s/%s_rel_amp_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim([ 6, 30 ])
  fig.savefig( "%s/%s_rel_amp_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus rel amp 2
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigRelAmp2, 'bx' )
    if injFile:
      ax.loglog( injSNR, injRelAmp2, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Relative amplitude" )
    fig.savefig( "%s/%s_rel_amp2_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_rel_amp2_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: Relative amplitude versus coherent SNR '+\
                        'failed with zeros in a loglog plot'

  # plot SNR versus norm 3
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigNorm3, 'bx' )
    if injFile:
      ax.loglog( injSNR, injNorm3, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Amplitude factor" )
    fig.savefig( "%s/%s_norm3_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_norm3_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: Amplitude factor versus coherent SNR '+\
                        'failed with zeros in a loglog plot'
  
  # plot SNR versus inclination
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigInclination, 'bx' )
    if injFile:
      ax.loglog( injSNR, injInclination, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "|cos inclination|" )
    fig.savefig( "%s/%s_inclination_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_inclination_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: cos(inclination) versus coherent SNR '+\
                        'failed with zeros in a loglog plot'
 
  # DONE
if __name__=='__main__':

  opts, args = parse_command_line()

  outdir    = os.path.abspath( opts.output_path )
  verbose   = opts.verbose
  trigFile  = os.path.abspath( opts.trig_file )
  injFile   = None
  if opts.inj_file:
    injFile = os.path.abspath( opts.inj_file )
  GRBnum    = 'GRB%s' % opts.grb_name
  q         = opts.chisq_index
  n         = opts.chisq_nhigh
  nullt     = map( float, opts.null_snr_threshold.split(',') )
  main( trigFile, injFile, GRBnum, outdir, chisq_index=q, chisq_nhigh=n,\
        null_thresh = nullt, verbose=verbose )
 
