#!/usr/bin/env python
"""
Given a segment list, this program will return all data quality flags defined
within those segments, as well as the sub-segments over which each flag
is enabled.
"""
from __future__ import division

import glob
import optparse
import os
import sys

from glue.segments import segmentlistdict, segment, segmentlist
from glue import segmentsUtils
from glue import iterutils

from pylal import dqutils

__author__ = "Nickolas Fotopoulos (nvf@gravity.phys.uwm.edu)"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"

all_ifos = ('H1', 'H2', 'G1', 'L1', 'V1')

##############################################################################
# Utility functions
##############################################################################

def parse_args():
    parser = optparse.OptionParser(usage=__doc__,
      version="$Id$")
    parser.add_option("-i", "--ifo", dest="ifos", metavar="IFO",
        action="append", help="IFO whose DQ flags should be analyzed "\
        "(provide this option multiple times for multiple IFOs)")
    parser.add_option("-d", "--dq-segfile", dest="dq_segfiles",
        action="append", help="File containing data quality flags with "\
        "segments for an IFO; if it does not exist, it will be downloaded "\
        "from ldas-cit; if omitted, the file will be downloaded from CIT, "\
        "but not retained; --dq-segfile options must have the same order as "\
        "--ifo options")
    parser.add_option("-p", "--at-point", type="int",
        help="Discover what DQ flags were active at a point in time")
    parser.add_option("-s", "--segfile",
        help="File containing segments of interest")
    parser.add_option("-f", "--flagfile",
        help="File containing data quality flags of interest with expansion windows")
    parser.add_option("-o", "--outfile",
        help="Output file; if unspecified, print to stdout")
    parser.add_option("-n", "--keep-version", action="append",
        dest="keep_versions",
        help="Ignore flags of a particular version (repeat option to specify multiple versions)")
    parser.add_option("-v", "--verbose", action="count", default=0,
        help="Print extra information; specify twice for extra verbosity")
    opts, args = parser.parse_args()

    if opts.ifos is None:
        raise ValueError, "Must provide IFOs on which to operate."

    if not ((opts.segfile is None) ^ (opts.at_point is None)):
        raise ValueError, "Must specify either --segfile or --at-point"

    if (opts.segfile is not None) and (not os.path.exists(opts.segfile)):
        raise ValueError, "segfile does not exist"

    for ifo in opts.ifos:
        if ifo not in all_ifos:
          raise ValueError, "%s not in %s" % (ifo, all_ifos)
    
    if opts.dq_segfiles is None:
      opts.dq_segfiles = [None] * len(opts.ifos)

    return opts, args

##############################################################################
# Main
##############################################################################

opts, args = parse_args()

# download DQ flag segfiles if necessary -- time-consuming
dq_dict = segmentlistdict()
for dq_segfile, ifo in zip(opts.dq_segfiles, opts.ifos):
    dq_dict.update(dqutils.download_and_parse_dq_segs(dq_segfile, ifo,
                                                      verbose=opts.verbose))

# keep only flags in the flagfile, expand/contract according to windows
if opts.flagfile is not None:
    veto_windows = dqutils.from_veto_file(open(opts.flagfile))
    dq_dict = dqutils.apply_veto_windows(dq_dict, veto_windows)

# do math; remove everything not in the segfile segments
if opts.segfile is not None:
    analyzable = segmentsUtils.fromsegwizard(open(opts.segfile))
    mask = ~analyzable
    dq_dict = dqutils.subtract_segmentlist_from_segmentlistdict(mask, dq_dict)
elif opts.at_point is not None:
    dq_dict = dqutils.segmentlistdict_at_point(dq_dict, opts.at_point)

# separate into zero-length and non-zero-length piles
contrib_flags, nocontrib_flags = dqutils.separate_contributing_flags(dq_dict)
contrib_flags.sort()
nocontrib_flags.sort()

# construct new segdict of flags that contributed
contrib_flags_segdict = segmentlistdict([(key, dq_dict[key]) for key in contrib_flags])
contrib_flags_union = contrib_flags_segdict.union(contrib_flags)

# output information in a useful manner
if opts.verbose >= 2:
    print "These DQ flag versions were the only ones kept: %s" \
        % str(opts.keep_versions)
    print "These DQ flags were checked, but were not active in the "\
        "segment(s) of interest: %s" % ", ".join(nocontrib_flags)
if opts.verbose >= 1 or opts.at_point is not None:
    print "These DQ flags were raised:"
    for key in contrib_flags:
        print "%s: %s" % (key, contrib_flags_segdict[key])
    if len(contrib_flags) == 0:
        print "None"
    print "Total time flagged: %d" % abs(contrib_flags_union)

if opts.outfile is not None:
    outpipe = file(opts.outfile, "w")
else:
    outpipe = sys.stdout
segmentsUtils.tosegwizard(outpipe, contrib_flags_union)
