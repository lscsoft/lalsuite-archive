#!/usr/bin/python

# $Id$

__author__ = "Drew Keppel <drew.keppel@ligo.org>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__="plotifar"
__Id__ = "$Id$"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
import glue.iterutils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import InspiralUtils
from numpy import histogram

import itertools
import numpy
import operator

from glue.ligolw import ligolw, table as tab, lsctables, utils

from pylal import SnglInspiralUtils, SimInspiralUtils
from pylal.tools import XLALEThincaParameterForInjection as ethinca_param


##############################################################################
usage = """
"""


def parse_command_line():
  """
  Parser function dedicated
  """

  parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )

  # options related to input and output
  parser.add_option("-g","--glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB of thinca files to read" )
  parser.add_option("-I", "--cache-file", help="read thinca filenames from cache input file")  
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )
  parser.add_option("","--ifo-tag",action="store",type="string",\
      default=None, metavar=" IFOTAG",\
      help="The ifo tag used in the name of the figures (e.g. SECOND_H1H2L1)")      
  parser.add_option("","--gps-start-time",action="store", type="int", metavar="GPSSTARTTIME",\
      help="gps start time used in the figure and output file names")
  parser.add_option("","--gps-end-time",action="store", type= "int", metavar="GPSENDTIME",\
      help="gps end time used in the figure and output file names")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("","--ifo-times",action="store",type="string",\
      default=None,metavar="IFOS",\
      help="sets ifo times for which plots will be made (e.g. H1H2L1)" )
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("-A","--g1-triggers",action="store_true",default=False,\
      help="input files contain triggers from G1" )
  parser.add_option("-B","--h1-triggers",action="store_true",default=False,\
      help="input files contain triggers from H1" )
  parser.add_option("-C","--h2-triggers",action="store_true",default=False,\
      help="input files contain triggers from H2" )
  parser.add_option("-D","--l1-triggers",action="store_true",default=False,\
      help="input files contain triggers from L1" )
  parser.add_option("-U","--v1-triggers",action="store_true",default=False,\
      help="input files contain triggers from V1" )


  # options used in sieving the cache file, in case it is given    
  parser.add_option("","--coinc-pattern",
      default="", metavar="COINCPATTERN",
      help="pattern for zerolag files the cache "\
           "input file  will be sieved with" )
  parser.add_option("","--match",action="store",type="string",\
      default=None,metavar="MATCH",\
      help="To sieve exactly according to a pattern, if its set True" )

  #options that set parameters specific to the plots 

  parser.add_option("","--num-categories",action="store",type= "int",
      default=1,metavar="NUM",help="number of categories plotted together")
  parser.add_option("","--combine-types",action="store_true",default=False,
      help="combine the different types together" )
  parser.add_option("--far-time-correction",action="store",type="float",\
      default=None,metavar=" T_COR",\
      help="zero-lag time correction for FAR: FAR -> T_COR*FAR " + \
          "(for use when FAR calculated with all_data and need " + \
          "exclude_play FAR)")
  parser.add_option("--t-correct-num",action="store",type="string",\
      default=None,metavar=" T_COR_NUM",\
      help="coire summary file that contains the amount of analyzed time " + \
          "for the data-type you need to generate a correction factor for. " + \
          "Requires denominator file; precludes far-time-correction option.")
  parser.add_option("--t-correct-denom",action="store",type="string",\
      default=None,metavar=" T_COR_DENOM",\
      help="coire summary file that contains the amount of all_data analyzed time. " + \
          "Dividing the value in the numerator file by this gives the " + \
          "far-time-correction as opposed to manually specifying. " + \
          "Requires numerator file; precludes far-time-correction option.")
  parser.add_option("","--min-ifar",action="store",type= "float",
      default=None,metavar="IFAR",help="the minimum IFAR to plot")
  parser.add_option("","--max-ifar",action="store",type= "float",
      default=None,metavar="IFAR",help="the maximum IFAR to plot")
  parser.add_option("-a","--snr-ifar",action="store_true",default=False,\
      help="plot the snr vs ifar of coinc triggers" )
  parser.add_option("-b","--ifar-dist",action="store_true",default=False,\
      help="make the cumulative distribution of IFAR" )
  parser.add_option("--add-ifar-errors",action="store_true",default=False,\
      help="add errors on IFAR to the cumulative distribution of IFAR plot" )

  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times (which ifos were analysed) must be provided"
  if options.t_correct_num and not options.t_correct_denom:
    raise ValueError, "--t-correct-num requires --t-correct-denom."
  if options.t_correct_denom and not options.t_correct_num:
    raise ValueError, "--t-correct-denom requires --t-correct-num."
  if options.t_correct_num and options.far_time_correction:
    raise ValueError, "If using --t-correct files, cannot use --far-time-correction."

  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()



if not opts.glob and not opts.cache_file:
  print >>sys.stderr, "Must specify a --glob of files or --cache-input file to read"
  print >>sys.stderr, "Enter 'plotifar --help' for usage"
  sys.exit(1)


#####################################################################
# -- some initialisation
opts = InspiralUtils.initialise(opts, __name__, __version__)
# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file


# Change to Agg back-end if show() will not be called thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
from numpy import histogram
rc('text', usetex=True)


## mangle the event-IDs in the case of the exttrig analysis
mangleEventID = False

####################################################################

statistic = CoincInspiralUtils.coincStatistic( 'effective_snr' )

plotsymbols = ['r+','bx','ko','g1']
hanfordsym = ['b+','bx','r1']
addsym = ['k+','kx','k1']

xlow = 20
xhigh = 0

#######################################################
# determine IFOs and IFO combos in play

ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1", "V1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]
ifo_non_h = [ifo for ifo in ifo_list if ifo[0] != "H"]

ifo_coincs = []
for num_ifos in range(2, len(ifo_list) + 1):
  ifo_coincs.extend(list(glue.iterutils.choices(ifo_list, num_ifos)))
combos = ["".join(ifos) for ifos in ifo_coincs]

###################################
# glob the list of files to read in
if opts.glob is not None or opts.cache_file is not None:
  if opts.glob is not None:
    allfiles = []
    for gl in opts.glob.split(" "):
      allfiles.extend(glob.glob(gl))
    if len(allfiles) < 1:
      print >>sys.stderr, "The glob for " + opts.glob + " returned no files" 
      sys.exit(1)

    coincfiles = []
    for file in allfiles:
      coincfiles.append(file)

  elif opts.cache_file is not None:
    allfilesCache = lal.Cache.fromfile(open(opts.cache_file))    

    coincfiles = []
    coincfiles = allfilesCache.sieve(description=opts.coinc_pattern,
        exact_match=opts.match).sieve(ifos=opts.ifo_times,exact_match=True).\
        checkfilesexist()[0].pfnlist()
        #sieve(description=opts.ifo_times, exact_match=False).\
  # check if the file lists are not empty
  if not (coincfiles):
    print >>sys.stdout, "No files match your description."
    sys.exit(0) 
         
########################
# read in coinc triggers
inspTriggers = None
coincTriggers = CoincInspiralUtils.coincInspiralTable()

if coincfiles:
  inspTriggers = SnglInspiralUtils.\
                 ReadSnglInspiralFromFiles(coincfiles,
                                           mangle_event_id = mangleEventID,
                                           verbose=opts.verbose)
  
  # construct the coincs
  coincTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)

stats = {}
stats['IFAR'] = {}
stats['stat'] = {}
FAR = {}
IFAR = {}
cumhist ={}

maxIFAR = -numpy.inf
minIFAR = numpy.inf

modifierFAR = 1.
if opts.num_categories:
  modifierFAR *= float(opts.num_categories)
if opts.far_time_correction:
  modifierFAR *= float(opts.far_time_correction)
#if specifying tcorrection files, calculate the time correction factor
if opts.t_correct_num:
  numfile = open(opts.t_correct_num,'r')
  for line in numfile:
    if line.startswith( 'amount of time analysed' ):
      t_cor_num = float( line.split()[6] )
  numfile.close()
  denomfile = open(opts.t_correct_denom,'r')
  for line in denomfile:
    if line.startswith( 'amount of time analysed' ):
      t_cor_denom = float( line.split()[6] )
  denomfile.close()
  modifierFAR *= t_cor_num / t_cor_denom
  if opts.verbose:
    print "modifierFAR = %f" %(modifierFAR)
for combo,ifos in zip(combos,ifo_coincs):
  coincs = coincTriggers.coinctype(ifos)
  FAR[combo] = []
  for row in coincs.getsngls(ifos[0]):
    FAR[combo].append((max(modifierFAR*row.alpha,0.01), modifierFAR*row.alpha1))

  stats['stat'][combo] = coincs.getstat()
  stats['IFAR'][combo] = []
  for row in FAR[combo]:
    stats['IFAR'][combo].append(1./row[0])

  IFAR[combo] = []
  for row in FAR[combo]:
    if row[1] >= row[0]:
      IFAR[combo].append((1./row[0], 1./(row[0] + row[1]), 1e4))
    else:
      IFAR[combo].append((1./row[0], 1./(row[0] + row[1]),
          1./(row[0] - row[1])))

  IFAR[combo].sort(key=operator.itemgetter(0))
  IFAR[combo].reverse()
  if len(coincs):
    maxIFAR = max(maxIFAR, IFAR[combo][0][0])
    minIFAR = min(minIFAR, IFAR[combo][-1][0])
  cumhist[combo] = array(range(len(IFAR[combo]))) + 1
  if opts.verbose:
    print "%s %d" % (combo,len(IFAR[combo]))

if opts.min_ifar:
  minIFAR = opts.min_ifar
if opts.max_ifar:
  maxIFAR = opts.max_ifar

bkgmin = 0.8*minIFAR
bkgmax = 1.2*maxIFAR
bkg = bkgmin*exp(array(range(10001))*log(bkgmax/bkgmin)/10000.)
ibkg = 1./bkg
ibkg = array(ibkg)
ibkg_p1 = ibkg + sqrt(ibkg)
ibkg_m1 = array([max(x - sqrt(x), 0.1) for x in ibkg])
bkg_x1,bkg_y1 = viz.makesteps(bkg, ibkg_p1, ibkg_m1)

colors = itertools.cycle(('b', 'g', 'r', 'c', 'm', 'k'))
symbols = itertools.cycle(('^', 'D', 'H', 'o', '1', '+', 'x'))

################################################
# make histogram of stat distribution
if opts.ifar_dist and not opts.combine_types:
  figure(figure_number)
  figure_number += 1

  for combo,color,symbol in zip(combos,colors,symbols):
    loglog(map(operator.itemgetter(0),IFAR[combo]), cumhist[combo],
        color+symbol, markerfacecolor=color, markeredgecolor=color,
        alpha=0.65, label=combo)
    hold(True)
    if opts.add_ifar_errors:
      for xmin, xmax, y in zip(map(operator.itemgetter(1), IFAR[combo]),
          map(operator.itemgetter(2), IFAR[combo]), cumhist[combo]):
        loglog([xmin,xmax], [y,y], color + '-|', markeredgewidth=4,
            markersize=15, linewidth=2, label='_nolegend_')
  loglog(bkg, ibkg, 'k--', linewidth=2, label='background')
  fill(bkg_x1, bkg_y1, facecolor='y', alpha=.2, label='$N^{1/2}$ errors')
  if opts.min_ifar:
    xlim(xmin=opts.min_ifar)
  else:
    xlim(xmin=0.9*minIFAR)
  if opts.max_ifar:
    xlim(xmax=opts.max_ifar)
  else:
    xlim(xmax=1.1*maxIFAR)
  ylim(ymin=0.6,ymax=3./minIFAR)
  legend()
  xlabel(r"IFAR (per analysis time)", size='x-large')
  ylabel(r"Cumulative \#", size='x-large')
  if opts.enable_output is True:
    name = "cumhist_ifar"
    text = "Cumulative Histogram of IFAR distribution"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)

if opts.combine_types and opts.ifar_dist:
  figure(figure_number)
  figure_number += 1
  combinedIFAR = {}
  combinedIFAR['IFAR'] = [IFAR[combo][idx][0] for combo in combos for idx in range(len(IFAR[combo]))]
  combinedIFAR['IFAR'].sort()
  combinedIFAR['IFAR'].reverse()
  combinedIFAR['cumhist'] = arange(len(combinedIFAR['IFAR'])) + 1.
  loglog(combinedIFAR['IFAR'], combinedIFAR['cumhist'], 'b^',
      markerfacecolor='b', markeredgecolor='b',
      alpha=0.65, label='zero-lag')
  hold(True)
  loglog(bkg, ibkg, 'k--', linewidth=2, label='background')
  fill(bkg_x1, bkg_y1, facecolor='y', alpha=.2, label='$N^{1/2}$ errors')
  if opts.min_ifar:
    xlim(xmin=opts.min_ifar)
  else:
    xlim(xmin=0.9*minIFAR)
  if opts.max_ifar:
    xlim(xmax=opts.max_ifar)
  else:
    xlim(xmax=1.1*maxIFAR)
  ylim(ymin=0.6,ymax=3./minIFAR)
  legend()
  xlabel(r"IFAR (per analysis time)", size='x-large')
  ylabel(r"Cumulative \#", size='x-large')
  if opts.enable_output is True:
    name = "cumhist_ifar_combined"
    text = "Cumulative Histogram of IFAR distribution"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)

if opts.snr_ifar:
  figure(figure_number)
  figure_number += 1
  for combo,color,symbol in zip(combos,colors,symbols):
    semilogx(stats['IFAR'][combo], stats['stat'][combo], color+symbol,
        markeredgecolor=color, alpha=0.1, label=combo)
    hold(True)
  grid(True)
  legend(loc='lower right')
  xlabel(r"IFAR (per analysis time)", size='x-large')
  ylabel(r"Combined Effective SNR", size='x-large')
  if opts.enable_output is True:
    name = "stat_vs_ifar"
    text = "Combined Effective SNR vs $1/\langle N \rangle$"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)


# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, tagList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

# ============================================================================


if opts.show_plot:
  show()
