#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import numpy
from optparse import OptionParser
import sys


from glue import segments
from pylal import ligolw_burca_tailor
from pylal import SnglBurstUtils


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$"
	)
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca2", help = "Set the prefix for output filenames (default = \"plotburca2\").")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "Set the output image format (default = \"png\").")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "lalapps_power", help = "Set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = \"lalapps_power\").")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                   Coincidence Parameter Distribution Plot
#
# =============================================================================
#


def add_to_plot(axes, red_rate, black_rate, plottype):
	if plottype == "P":
		axes.plot(numpy.compress(black_rate.array > 0, black_rate.xvals()), numpy.compress(black_rate.array > 0, black_rate.array), "k")
		axes.plot(numpy.compress(red_rate.array > 0, red_rate.xvals()), numpy.compress(red_rate.array > 0, red_rate.array), "r")
	elif plottype == "LR":
		axes.plot(numpy.compress((red_rate.array > 0) & (black_rate.array > 0), black_rate.xvals()), numpy.compress((red_rate.array > 0) & (black_rate.array > 0), red_rate.array / black_rate.array), "k")
	else:
		raise ValueError, plottype

	ymin, ymax = axes.get_ylim()
	if ymax / ymin > 1e6:
		ymin = ymax / 1e6
		axes.set_ylim((ymin, ymax))


#
# distributions is a ligolw_burca_tailor.CoincParamsDistributions instance
#


def plot_coinc_params(distributions, plottype):
	#
	# Create a figure.
	#

	fig = SnglBurstUtils.figure.Figure()
	SnglBurstUtils.FigureCanvas(fig)

	#
	# How many instrument pairs are there?
	#

	pairs = set(tuple(name.split("_")[:2]) for name in distributions.background_rates.keys() if "_" in name)

	#
	# How many plots in each row?
	#

	n_horiz = len(pairs)

	#
	# How many rows?
	#

	#n_vert = 6
	n_vert = 5

	#
	# Each of the first len(pairs) sub plot's aspect ratio is the golden
	# ratio.
	#

	size = 4.0
	fig.set_size_inches(n_horiz * size, n_vert / ((1 + math.sqrt(5)) / 2) * size)

	#
	# Plot layout.
	#

	vlabel_allowance = .05
	hlabel_allowance = .03
	border = .007
	width = 1.0 / n_horiz - hlabel_allowance - 2 * border
	height = 1.0 / n_vert

	#
	# Iterate over instrument pairs.
	#

	for i, pair in enumerate(pairs):
		#
		# Construct the axes for this instrument pair.
		#

		left = float(i) / n_horiz + hlabel_allowance + border

		dt_axes = fig.add_axes((left, 0 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		df_axes = fig.add_axes((left, 1 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		dh_axes = fig.add_axes((left, 2 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		dband_axes = fig.add_axes((left, 3 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		ddur_axes = fig.add_axes((left, 4 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))

		dt_axes.semilogy()
		df_axes.semilogy()
		dh_axes.semilogy()
		dband_axes.semilogy()
		ddur_axes.semilogy()

		dt_axes.set_xlabel(r"$t_{\mathrm{%s}} - t_{\mathrm{%s}}$ (s)" % pair)
		df_axes.set_xlabel(r"$(f_{\mathrm{%s}} - f_{\mathrm{%s}}) / \left< f \right>$" % pair)
		dh_axes.set_xlabel(r"$({h_{\mathrm{rss}}}_{\mathrm{%s}} - {h_{\mathrm{rss}}}_{\mathrm{%s}}) / \left< h_{\mathrm{rss}} \right>$" % pair)
		dband_axes.set_xlabel(r"$(\Delta f_{\mathrm{%s}} - \Delta f_{\mathrm{%s}}) / \left< \Delta f \right>$" % pair)
		ddur_axes.set_xlabel(r"$(\Delta t_{\mathrm{%s}} - \Delta t_{\mathrm{%s}}) / \left< \Delta t \right>$" % pair)

		# this must match the mapping used in burca_tailor to bin
		# the \Delta t's.
		ticks = numpy.array((float("-inf"), -0.08, -0.04, -0.02, -0.01, 0, 0.01, 0.02, 0.04, 0.08, float("inf")), dtype = "double")
		dt_axes.set_xticks(numpy.arctan((ticks / 0.03) * (math.pi / 2)) / (math.pi / 2))
		dt_axes.set_xticklabels([r"$-\infty$"] + map(lambda x: "$%.2g$" % x, ticks[1:-1]) + [r"$\infty$"])

		#
		# Plot the data on them.
		#

		prefix = "%s_%s_" % pair
		for axes, suffix in zip((dt_axes, df_axes, dh_axes, dband_axes, ddur_axes), ("dt", "df", "dh", "dband", "ddur")):
			red_rate = distributions.injection_rates[prefix + suffix]
			black_rate = distributions.background_rates[prefix + suffix]
			add_to_plot(axes, red_rate, black_rate, plottype)

		#
		# Force ranges
		#

		dt_axes.set_xlim((-1.0, +1.0))

	#
	# GMST
	#

	#gmst_axes = fig.add_axes((hlabel_allowance + border, 5 * height + vlabel_allowance + border, 1.0 - hlabel_allowance - 2 * border, height - vlabel_allowance - 2 * border))
	#red_rate = distributions.injection_rates["gmst"]
	#black_rate = distributions.background_rates["gmst"]
	#add_to_plot(gmst_axes, red_rate, black_rate, plottype)

	#
	# Done.
	#

	return fig


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, filenames = parse_command_line()
filenames.sort()


distributions = ligolw_burca_tailor.CoincParamsDistributions()
seglists = segments.segmentlistdict()
for filename in filenames:
	c, s = ligolw_burca_tailor.coinc_params_distributions_from_filename(filename, "ligolw_burca_tailor", verbose = options.verbose)
	distributions += c
	seglists |= s
distributions.finish()


filename = "%s-%%s-%d-%d.%s" % (options.base, int(seglists.extent_all()[0]), int(abs(seglists.extent_all())), options.format)
if options.verbose:
	print >>sys.stderr, "writing %s ..." % (filename % "P")
plot_coinc_params(distributions, "P").savefig(filename % "P")
if options.verbose:
	print >>sys.stderr, "writing %s ..." % (filename % "LR")
plot_coinc_params(distributions, "LR").savefig(filename % "LR")

sys.exit()


if options.verbose:
	print >>sys.stderr, "done."
