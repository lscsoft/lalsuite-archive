#!/usr/bin/python

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.segments import segment, segmentlist
from glue.segmentsUtils import fromsegwizard, fromfilenames

from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from pylal import CoincInspiralUtils
from pylal.viz import square_axis

##############################################################################
def disterr(coinc_table, ifo_list, use_avg, statistic):

  ifoa_dist = coinc_table.getsngls(ifo_list[0]).get_column('eff_distance')
  ifob_dist = coinc_table.getsngls(ifo_list[1]).get_column('eff_distance')
  ifoa_snr = coinc_table.getsngls(ifo_list[0]).get_column(statistic)
  ifob_snr = coinc_table.getsngls(ifo_list[1]).get_column(statistic)

  ifoa_sigma = coinc_table.getsngls(ifo_list[0]).get_column('sigmasq')
  ifob_sigma = coinc_table.getsngls(ifo_list[1]).get_column('sigmasq')

  if use_avg:
    denoma = (ifoa_dist + ifob_dist) / 2.0
    denomb = (ifoa_dist + ifob_dist) / 2.0
  else:
    denoma = ifob_dist
    denomb = ifoa_dist
 
  ifoa_error = abs(ifoa_dist - ifob_dist) / denoma
  ifob_error = abs(ifob_dist - ifoa_dist) / denomb

  dist_error = ifoa_error
  small_snr = ifoa_snr
  
  for j in range(len(dist_error)):
    if ifoa_sigma[j] > ifob_sigma[j]:
      dist_error[j] = ifob_error[j]
      small_snr[j] = ifob_snr[j]

  return([small_snr,dist_error])
                                                

##############################################################################
usage = """
Function to test the efficiency of an effective distance cut.  The
function reads in triggers from injections and time slides.  It clusters
the injection triggers (so as to have only one trigger coincident with
each injection).  Then, we calculate the symmetric fractional distance
error.  The proposed distance cut is specified using the values kappa and
epsilon.  We require:

   |D_IFOA - D_IFOB|     epsilon
2 * ---------------  =   -------  + kappa.
   |D_IFOA + D_IFOB|     rho_obs
"""

parser = OptionParser( usage )

parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )

parser.add_option("-g","--inj-glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB of thinca files to read" )

parser.add_option("-G","--slide-glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB of thinca files to read" )

parser.add_option("-V", "--veto-file", metavar=" VETO_FILE",
    help="file of segments in which to veto triggers (segwizard format)")

parser.add_option("-T", "--quantization-time", type="int",
    help="quantize live time on this time period")

parser.add_option("-L","--cluster-window",action="store",type="int",default=0,\
    metavar=" SEC", help="length of time over which to cluster triggers" )

parser.add_option("-K","--statistic",action="store",type="string",\
    default="snr",metavar=" STAT",\
    help="coincident statistic (default = snr)")

parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None, metavar=" FNAME",\
    help="generate png figures with name FNAME-fig.png" )

parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )

parser.add_option("-A","--ifoa",action="store",default=None,\
    metavar=" IFOA",help="first ifo for which we have triggers" )

parser.add_option("-B","--ifob",action="store",default=None,\
    metavar=" IFOB",help="second ifo for which we have triggers" )

parser.add_option("-a","--dist-cut",action="store_true",default=False,\
    help="perform distance cut on inj and slide trigs" )

parser.add_option("-u","--use-avg-distance",action="store_true",default=False,\
    help="use average of the two distances to normalize the error" )

parser.add_option("-b","--dist-snr",action="store_true",default=False,\
    help="plot of distance accuracy vs snr" )

parser.add_option("-c","--dist-hist",action="store_true",default=False,\
    help="histogram of distance accuracy" )

parser.add_option("-C","--snr-hist",action="store_true",default=False,\
    help="histogram of snr" )

parser.add_option("-d", "--dist-dist", action="store_true", default=False,
    help="plot IFOB effective distance vs IFOA effective distance")

parser.add_option("-N","--num-slides",action="store",type="int",\
    metavar=" NUM_SLIDES",help="number of time slides performed (0 for zero-lag)" )

parser.add_option("-t","--plot-type",action="store",type="string",\
    default="linear",metavar=" PLOT_TYPE", \
    help="make either linear or log or plots" )

parser.add_option("-F","--font-size",action="store",type="int",\
    default="12",metavar=" FONT_SIZE", \
    help="font size for axis labels" )
    
parser.add_option("-k","--kappa",action="store",type="float",default=0,\
    metavar=" KAPPA",help="value of kappa in dist cut" )

parser.add_option("-e","--epsilon",action="store",type="float",default=0,\
    metavar=" EPSILON",help="value of epsilon in dist cut" )

(opts,args) = parser.parse_args()

##############################################################################
# sanity check on arguments
##############################################################################

if not opts.inj_glob:
  print >>sys.stderr, "Must specify a GLOB of inj files to read"
  print >>sys.stderr, "Enter 'ploteffdistcut --help' for usage"
  sys.exit(1)

if not opts.kappa and not opts.epsilon:
  print >> sys.stderr, "Must specify a value of KAPPA and EPSILON"
  print >>sys.stderr, "Enter 'ploteffdistcut --help' for usage"
  sys.exit(1)

if not opts.ifoa or not opts.ifob:
  print >> sys.stderr, "Must specify two ifos, --ifoa and --ifob"
  print >> sys.stderr, "Enter 'ploteffdistcut --help' for usage"
  sys.exit(1)

if opts.slide_glob and (opts.num_slides is None or not opts.num_slides > 0):
  print >> sys.stderr, "--num-slides must be set if --slide-glob is specified"
  print >> sys.stderr, "Enter 'ploteffdistcut --help' for usage"
  sys.exit(1)
  
stat = CoincInspiralUtils.coincStatistic(opts.statistic)

# if we're not displaying a plot, don't require an X server
if not opts.show_plot:
  import matplotlib
  matplotlib.use("Agg")
from pylab import *
rc("font", size=opts.font_size)
rc("line", markersize=12, markeredgewidth=1)
from pylal import viz

#####################################
# glob the input files
injFiles = glob.glob(opts.inj_glob)
injTriggers = CoincInspiralUtils.coincInspiralTable(stat=stat)

# decide vetoes beforehand
if opts.veto_file is not None:
  veto_segs = fromsegwizard(open(opts.veto_file))
else:
  veto_segs = segmentlist()

# quantize live time; treat discards as an effective veto
if opts.quantization_time is not None:
  full_segs = fromfilenames(injFiles)
  T = opts.quantization_time
  naive_live_time = full_segs - veto_segs
  live_time = [segment(s[0], s[0] + (abs(s)//T)*T) for s in naive_live_time]
  veto_segs = full_segs - live_time

for file in injFiles:
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles([file])

  if (opts.veto_file is not None) or (opts.quantization_time is not None):
      inspTriggers = inspTriggers.veto(veto_segs)

  injTrig = CoincInspiralUtils.coincInspiralTable(inspTriggers,stat)
  injTrig = injTrig.coincinclude([opts.ifoa,opts.ifob])
  if opts.cluster_window:
    injTrig = injTrig.cluster(opts.cluster_window)
  injTriggers.extend(injTrig)

if opts.slide_glob:
  slideFiles = glob.glob(opts.slide_glob)
  inspSlide = SnglInspiralUtils.ReadSnglInspiralFromFiles(slideFiles)
  
  if (opts.veto_file is not None) or (opts.quantization_time is not None):
    inspSlide = inspSlide.veto(veto_segs)

  if opts.num_slides > 0:
    slide_num = range(1 , opts.num_slides + 1)
    slide_num.extend(range(-opts.num_slides, 0))
  else:
    slide_num = [0]

  slideTriggers = CoincInspiralUtils.coincInspiralTable(stat=stat)
  for slide in slide_num:
    this_slide = {}
    this_slide["slide_num"] = slide
    this_slide["sngl_trigs"] = inspSlide.getslide(slide)

    # make coincs
    this_slide["coinc_trigs"] = \
        CoincInspiralUtils.coincInspiralTable(this_slide["sngl_trigs"],stat)
    this_slide["coinc_trigs"] = \
        this_slide["coinc_trigs"].coincinclude([opts.ifoa,opts.ifob])

    # cluster triggers
    if opts.cluster_window:
      this_slide["coinc_trigs"] = \
        this_slide["coinc_trigs"].cluster(opts.cluster_window)  
    
    # add slide to list
    slideTriggers.extend(this_slide["coinc_trigs"])

#######################################################################
# extract the information from the tables
[inj_snr,inj_error] = disterr(injTriggers,[opts.ifoa,opts.ifob], \
    opts.use_avg_distance, opts.statistic)

if opts.slide_glob:
  [slide_snr,slide_error] = disterr(slideTriggers,[opts.ifoa,opts.ifob], \
      opts.use_avg_distance, opts.statistic)

figNum = 0
#######################################################################
# plot of distance accuracy vs snr
if opts.dist_snr:
  figNum += 1
  figure(figNum)
  leg = []
  # plot the slides
  if opts.slide_glob:
    semilogx(slide_snr, slide_error, 'b+')
    if opts.num_slides > 0:
      leg.append('slide')
    else: # opts.num_slides == 0
      leg.append('background')
  # plot the injections
  semilogx(inj_snr, inj_error, 'rx')
  leg.append('inj')

  x = arange(int(min(inj_snr)), int(max(inj_snr)) + 2)
  fit_y = 2.0*abs(16.0/5.5 - 32.0/x)/(16.0/5.5 + 32.0/x)
  semilogx(x,fit_y,'k',linewidth=2)
  leg.append('fit')
  if opts.kappa or opts.epsilon:
    semilogx(x, opts.kappa + opts.epsilon/x,'k',linewidth=1)
    leg.append('cut')
  xlim(min(x),max(x))
  xlabel('%s of trigger' % opts.statistic.replace("_", r"\_"))
  ylabel('fractional difference in eff. distance')
  legend(leg, loc='best')
  grid(True)
  if opts.figure_name:  
    savefig(opts.figure_name + "_eff_dist_cut.png")

#######################################################################
# histogram of distance accuracy
if opts.dist_hist:
  figNum += 1
  figure(figNum)
  if opts.slide_glob:
    [slide_num,slide_bin,junk] = hist(slide_error,bins=20)
    slide_num = slide_num/float(sum(slide_num))
  [inj_num,inj_bin,junk] = hist(inj_error,bins=20)
  inj_num = inj_num/float(sum(inj_num))
  clf()
  if opts.slide_glob:
    bar(slide_bin,slide_num,slide_bin[1]-slide_bin[0],color='b')
  bar(inj_bin,inj_num,inj_bin[1]-inj_bin[0],color='r')
  if not opts.epsilon and opts.kappa:
    axvline(opts.kappa,linewidth=2,color='k')
  xticks(fontsize=opts.font_size)
  yticks(fontsize=opts.font_size)
  xlabel('fractional difference in eff. distance')
  ylabel(r'normalized \#')
  ylim(ymin=0)
  if opts.figure_name:
    savefig(opts.figure_name + "_eff_dist_hist.png")

#######################################################################
# histogram of snr
if opts.snr_hist:
  figNum += 1
  figure(figNum)
  if opts.slide_glob:
    [slide_num,slide_bin,junk] = hist(log(slide_snr)/log(10.),bins=20)
    slide_num = slide_num/float(sum(slide_num))
  [inj_num,inj_bin,junk] = hist(log(inj_snr)/log(10.),bins=20)
  inj_num = inj_num/float(sum(inj_num))
  clf()
  if opts.slide_glob:
    bar(slide_bin,slide_num,slide_bin[1]-slide_bin[0],color='b')
  bar(inj_bin,inj_num,inj_bin[1]-inj_bin[0],color='r')
  xticks(fontsize=opts.font_size)
  yticks(fontsize=opts.font_size)
  xlabel('log(snr,base=10)')
  ylabel(r'normalized \#')
  snr_max = int(max(log(inj_snr)/log(10.))) + 2
  snr_min = int(min(log(inj_snr)/log(10.)))
  if opts.slide_glob:
    snr_max = max(int(max(log(slide_snr)/log(10.))) + 2,snr_max)
    snr_min = min(int(min(log(slide_snr)/log(10.))),snr_min)
  ylim(ymin=0)
  xlim(snr_min,snr_max)
  if opts.figure_name:
    savefig(opts.figure_name + "_snr_hist.png")

  figNum += 1
  figure(figNum)
  bar(inj_bin,inj_num,inj_bin[1]-inj_bin[0],color='r')
  if opts.slide_glob:
    bar(slide_bin,slide_num,slide_bin[1]-slide_bin[0],color='b')
  xticks(fontsize=opts.font_size)
  yticks(fontsize=opts.font_size)
  xlabel('log(snr,base=10)')
  ylabel(r'normalized \#')
  ylim(ymin=0)
  xlim(snr_min,snr_max)
  if opts.figure_name:
    savefig(opts.figure_name + "_hist_snr.png")


#######################################################################
# effective distance vs effective distance plot
if opts.dist_dist:
  figNum += 1
  fig = figure(figNum)
  fig.clear()
  ax = fig.add_subplot(111)
  ax.grid(True)
  ax.set_xscale("log")
  ax.set_yscale("log")

  leg = []
  if opts.slide_glob is not None:
    x = [getattr(coinc, opts.ifoa).eff_distance for coinc in slideTriggers]
    y = [getattr(coinc, opts.ifob).eff_distance for coinc in slideTriggers]
    ax.plot(x, y, 'b+')
    if opts.num_slides > 0:
      leg.append('slide')
    else: # opts.num_slides == 0
      leg.append('background')
  x = [getattr(coinc, opts.ifoa).eff_distance for coinc in injTriggers]
  y = [getattr(coinc, opts.ifob).eff_distance for coinc in injTriggers]
  ax.plot(x, y, 'rx')
  leg.append('injections')

  ax.axis("tight")
  square_axis(ax)
  ax.set_xlabel('%s effective distance' % opts.ifoa)
  ax.set_ylabel('%s effective distance' % opts.ifob)
  ax.legend(leg, loc='upper left')
  if opts.figure_name:
    fig.savefig("%s_dist-dist.png" % opts.figure_name)

#######################################################################
# calculate triggers surviving cut
if (opts.kappa or opts.epsilon) and opts.dist_cut:
  if opts.slide_glob:
    slide_trigs = len(slide_error)
    slide_cut = sum(asarray(slide_error > opts.kappa + opts.epsilon/slide_snr))
    print 'Number of time slide triggers ' + str(slide_trigs)
    print 'Number surviving distance cut ' + str(slide_trigs - slide_cut)
  inj_trigs = len(inj_error)
  inj_cut = sum( asarray(inj_error > opts.kappa + opts.epsilon/inj_snr) )
  print 'Number of injection triggers  ' + str(inj_trigs)
  print 'Number surviving distance cut ' + str(inj_trigs - inj_cut)

if opts.show_plot:
  show()



