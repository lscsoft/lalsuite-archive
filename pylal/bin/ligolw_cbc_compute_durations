#!/usr/bin/env python

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3
try:
    any
    all
except NameError:
    # Python < 2.5
    from glue.iterutils import any, all
import sys
import os
import copy

from pylal import ligolw_sqlutils as sqlutils
from pylal import ligolw_compute_durations as compute_dur

from glue import git_version
from glue import segments
from glue import segmentsUtils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from glue.ligolw import utils
from glue.ligolw.utils import process

from pylal import db_thinca_rings

__prog__ = "ligolw_cbc_compute_durations"
__author__ = "Collin Capano <cdcapano@physics.syr.edu>"

description = \
"Computes durations for every row in the experiment_summary table in a " + \
"database and stores them."

# =============================================================================
#
#                                   Set Options
#
# =============================================================================


def parse_command_line():
    """
    Parse the command line, return options and check for consistency among the
    options.
    """
    parser = OptionParser(
        version = git_version.verbose_msg,
        usage   = "%prog [options]",
        description = description
        )

    parser.add_option( "-d", "--database", action = "store", type = "string", default = None,
        help = 
            "Input database to read. Can only input one at a time."
        )
    parser.add_option( "", "--filter-program", action = "store", type = "string", default = None,
        help = 
            "Required; Set the name of the program whose entries in the " +
            "search summary table will set the live time. Ex. inspiral, ringdown"
        )
    parser.add_option( "-t", "--tmp-space", action = "store", type = "string", default = None,
        metavar = "PATH",
        help = 
            "Location of local disk on which to do work. This is optional; " +
            "it is only used to enhance performance in a networked " +
            "environment. "
        )
    parser.add_option( "-v", "--verbose", action = "store_true", default = False,
        help =
            "Be verbose."
        )

    (options, args) = parser.parse_args()

    # check for required options and for self-consistency
    if not options.database:
        raise ValueError, "No database specified."

    if not options.filter_program:
        raise ValueError, "No filter program specified."

    return options, sys.argv[1:]

# =============================================================================
#
#                              Function Definitions
#
# =============================================================================


def get_playground_sets_from_fulldata(full_data_dict):
    """
    Calculates playground segment sets using full_data single-ifo segments.
    Returns a dictionary of segments (which is of form {instrument:segmentlist})
    with just playground segments in them.
    
    @param full_data_dict: the full_data single-ifo analyzed segments dictionary
    """
    playground_listdict = segments.segmentlistdict()
    playground_seglist = segmentsUtils.S2playground(full_data_dict.extent_all())
    for instruments, seglist in full_data_dict.items():
        coalesced_seglist = copy.copy(seglist)
        playground_listdict[instruments] = coalesced_seglist.coalesce() & playground 

    return playground_listdict


class Durations:
    """
    Class to store and retrieve durations.
    self.durations has the structure:
    self.durations[(on_instruments, veto_def_name, datatype, time_slide_id)]
    """
    def __init__( self ):
        self.durations = {}

    def map_slides_to_durations( self, veto_def_name, datatype, livetime_dict ):
        for key, duration in livetime_dict.items():
            # the dictionary key is of the form (time_slide_id, on_instruments)
            self.durations[(key[1], veto_def_name, datatype, key[0])] = duration

    def retrieve_duration( self, on_instruments, veto_def_name, datatype, time_slide_id ):
        # when both simulations & full_data are in the same database, use full_data livetime
        if datatype == "simulation":
            datatype = "full_data"
        # when tuple from the experiment tables is a key of the durations dict, return duration
        if (on_instruments, veto_def_name, datatype, str(time_slide_id)) in self.durations.keys():
            return self.durations[( on_instruments, veto_def_name, datatype, str(time_slide_id) )]


# =============================================================================
#
#                                     Main
#
# =============================================================================

#
#       Generic Initilization
#

options, args = parse_command_line()

# get input database filename
filename = options.database
if not os.path.isfile( filename ):
    raise ValueError, "The input database, %s, cannot be found." % filename

# Setup working databases and connections
if options.verbose: 
    print >> sys.stderr, "Opening database..."

working_filename = dbtables.get_connection_filename( 
    filename, tmp_path = options.tmp_space, verbose = options.verbose )
connection = sqlite3.connect( working_filename )
if options.tmp_space:
    dbtables.set_temp_store_directory(connection, options.tmp_space, verbose = options.verbose)
dbtables.DBTable_set_connection( connection )
xmldoc = dbtables.get_xml(connection)

live_time_program = sqlutils.validate_option( options.live_time_program )

# Add program to process and process params table

# FIXME: remove the following two lines once boolean type
# has been properly handled
from glue.ligolw import types as ligolwtypes
ligolwtypes.FromPyType[type(True)] = ligolwtypes.FromPyType[type(8)]

proc_id = process.register_to_xmldoc(xmldoc, __prog__, options.__dict__, version = git_version.id)

#
#       Compute Durations
#

# find the tables we'll need
time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
expr_table = table.get_table(xmldoc, lsctables.ExperimentTable.tableName)
expr_summ_table = table.get_table(xmldoc, lsctables.ExperimentSummaryTable.tableName)

# turn the time slide table into a dictionary
time_slide_dict = time_slide_table.as_dict()

# initialize duration bank
dur_bank = Durations()

# get the ring_sets
ring_sets = db_thinca_rings.get_thinca_rings_by_available_instruments(connection, program_name = live_time_program)

# find out if there is playground or exclude_play in the database
sqlquery = """
    SELECT DISTINCT
        datatype
    FROM
        experiment_summary
   """
datatypes = [datatype[0] for datatype in connection.cursor().execute(sqlquery)]
if "playground" in datatypes or "exclude_play" in datatypes:
    playground_segs = get_playground_sets_from_all_data(ring_sets)
    exclude_play_segs = ring_sets - playground_segs
    zero_lag_offsets = dict([[slide_id, offset_vector] for slide_id, offset_vector in time_slide_dict.items() if not any(time_slide_dict[slide_id].values())])

if options.verbose:
    print >> sys.stderr, "Getting all veto categories in the experiment_summary table..."

# get veto_segments
sqlquery = """
    SELECT DISTINCT
        veto_def_name
    FROM
        experiment_summary
    """
for veto_def_name in connection.cursor().execute(sqlquery).fetchall():
    veto_def_name = veto_def_name[0]
    if options.verbose:
        print >>sys.stderr, "Retrieving veto segments for %s..." % veto_def_name
    try:
        veto_segments = db_thinca_rings.get_veto_segments(connection, veto_def_name)
    except AttributeError:
        # will get an AttributeError if using newer format veto segment file because
        # the new format does not include _ns; if so, remove the _ns columns from the
        # segment table and reset the definitions of lsctables.Segment.get and lsctables.Segment.set
        from glue.lal import LIGOTimeGPS

        del lsctables.SegmentTable.validcolumns['start_time_ns']
        del lsctables.SegmentTable.validcolumns['end_time_ns']

        def get_segment(self):
            """
            Return the segment described by this row.
            """
            return segments.segment(LIGOTimeGPS(self.start_time, 0), LIGOTimeGPS(self.end_time, 0))

        def set_segment(self, segment):
            """
            Set the segment described by this row.
            """
            self.start_time = segment[0].seconds
            self.end_time = segment[1].seconds

        lsctables.Segment.get = get_segment
        lsctables.Segment.set = set_segment

        veto_segments = db_thinca_rings.get_veto_segments(connection, veto_def_name)

    # compute the durations (or livetimes) for every possible instrument combo for every
    # slide in the time-slide table; the resulting durations dictionary has the following form:
    # durations[(on_instruments, veto_def_name, datatype, time_slide_id)] = livetime (in seconds)
    if options.verbose:
       print >> sys.stderr, "\tcalculating durations for:"

    livetime_dict = db_thinca_rings.get_thinca_livetimes(ring_sets, veto_segments, time_slide_dict.values(), verbose = options.verbose)
    dur_bank.map_slides_to_durations(veto_def_name, "full_data", time_slide_dict, livetime_dict)

    if "playground" in datatypes:
        if options.verbose:
            print >> sys.stderr, "\n\tcalculating playground durations for:"

        livetime_dict = db_thinca_rings.get_thinca_livetimes(playground_segs, veto_segments, zero_lag_offsets.values(), verbose = options.verbose)
        dur_bank.map_slides_to_durations(veto_def_name, "playground", zero_lag_offsets, livetime_dict)

    if "exclude_play" in datatypes:
        if options.verbose:
            print >> sys.stderr, "\n\tcalculating exclude_play durations for:"

        livetime_dict = db_thinca_rings.get_thinca_livetimes(exclude_play_segs, veto_segments, zero_lag_offsets.values(), verbose = options.verbose)
        dur_bank.map_slides_to_durations(veto_def_name, "exclude_play", zero_lag_offsets, livetime_dict)

#
# finished getting all durations, now populate the experiment_summary table
# with them
#
if options.verbose:
    print >> sys.stderr, "\nPopulating the experiment_summary table with results..."

connection.create_function("retrieve_duration", 4, dur_bank.retrieve_duration)

# populate the experiment_summary table with the appropiate duration
sqlquery = """
    UPDATE experiment_summary
    SET duration = (
        SELECT retrieve_duration(
            experiment.instruments,
            experiment_summary.veto_def_name,
            experiment_summary.datatype,
            experiment_summary.time_slide_id
            )
        FROM
            experiment
        WHERE
            experiment.experiment_id == experiment_summary.experiment_id
        )"""
connection.cursor().execute( sqlquery )

#
#       Close database and exit
#

connection.commit()
connection.cursor().close()
dbtables.put_connection_filename(filename, working_filename, verbose = options.verbose)

if options.verbose:
    print >> sys.stderr, "Finished!"

# set process end time
process.set_process_end_time(proc_id)
sys.exit(0)


