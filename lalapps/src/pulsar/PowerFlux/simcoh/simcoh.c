
/*-----------------------------------------------------------------------
 *
 * File Name: simcoh.c
 *
 * Authors: Junyi Zhang(jyzhang@umich.edu) Keith Riles (kriles@umich.edu)
 *
 *
 * History:   Created by Junyi Zhang 2008
 *
 *-----------------------------------------------------------------------
 */



#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <lal/TimeDelay.h>
#include <lal/Velocity.h>
#include <lal/DetResponse.h>

/* Locations of the earth and sun ephemeris data */
#define EARTHDATA "earth00-04.dat"
#define SUNDATA "sun00-04.dat"




/* the maximum number of grid vertices to be searched on the sky map */
const int sizeofline=30000;
const int sizeofspectrum=40000;


double Abs(double x);
double mean(double* array,int n);
int maxind(double* array,int n);
double stdev(double* array,int n);

/* wrtfile would write the computation results of simcoh to .txt files, which in turn would be read by a matlab program "readfile.m" to make SNR maps */
void wrtfile(int k,char* filename,double* RAsourcevector,double* Decsourcevector,double meanofnoise,double SNR,double stdofnoise,double maximum,double rightascension_of_source,double declination_of_source,double snrvec[sizeofline],double newfreq,double sizeofsearch,int sourceindex);



int main(int argc, const char *argv[]) {
  double pi=3.14159265358979;

  double freq=1000.4,   /* the frequecy of the signal to be searched */
         ff=1000, /*  first SFT frequency in Hz,this is set in makefakedata */ 
         fb=10.0, /*SFT freq band in Hz,this is also set in makefakedata */
         T=1800.0,     /* the length of a single sft */
         psi=0.8,
         RAsource=0.7854,  
         Decsource=0.7854; /* the true sky location of the source, in celestial coordinate system. They are not essential because searching process actually does not depend on this */

  int    iterations=1440,   /* the total number of time segments considered */ 
         startbin=1800000,   /* the index of the starting frequecy bin which makefakedata generate Fourier coefficient */  
         sizeofmatrix=96,
       	 starttime=693326229;   /* the GPS starting time of the first SFT */ 
      

  int    doppleroption=1,   /* this is basicly a debugging option. In real caculation we should always correct for doppler effect, so this should be set to 1 */
         timedelayoption=0,   /* timedelayoption=0->incoherent summing; timedelayoption=1->coherent summing */
         matched=1;    /* matched=0->do not use matched filter; matched=1-> use matched filter */

  const char* optarg="/home/rarmen/opt/lscsoft/lal/share/lal";  /* the directory of earth and sun ephemeris data files */
  const char* fdir="../makefakedata/fdata/";  /* the directory of Fourier coefficients files generated by makefakedata*/  
  double fbin=1.0/T;  
  
  int i,j,ii,jj;

  /* read command line arguments */
  for ( i=1 ; i<argc; i++) {
    const char* argi = argv[i];
    if (!strcmp(argi, "-t")) {
      timedelayoption=1;
    } else if (!strcmp(argi, "-iter")) {
      iterations =  strtol(argv[++i],0,0);
    } else if (!strcmp(argi, "-freq")) {
      freq = strtod(argv[++i],0);
    } else if (!strcmp(argi, "-mf0")) {
      matched=0;
    } else if (!strcmp(argi, "-edir")) {
      optarg=argv[++i];
    }  else if (!strcmp(argi, "-ff")) {
      ff= strtod(argv[++i],0);
    } else if (!strcmp(argi, "-psi")) {
      psi= strtod(argv[++i],0);
    } else if (!strcmp(argi, "-fb")) {
      fb= strtod(argv[++i],0);
    } else if (!strcmp(argi, "-fdir")) {
      fdir=argv[++i];
    } else if (!strcmp(argi, "-s")) {
      starttime= strtod(argv[++i],0);
    } else if (!strcmp(argi, "-g")) {
     sizeofmatrix= strtod(argv[++i],0);
    } 



    else if (!strcmp(argi, "-h")) {
      printf("Recognized arguments [defaults] are:\n"
	     "-iter num       set the total number of non-overlapping time segments                 [1440(one month)]\n"
	     "-t              use coherent summinguse                                               [incoherent summing]\n"
	     "-mf0            do not use matched filter                                             [use matched filter]\n"
	     "-freq num       the signal frequency is set to num                                    [1000.4Hz]\n"
	     "-ff num         set the first frequency in Hz to num,same as in makefakedata_v2       [1000Hz]\n"
	     "-fb num         set the width of frequency band to num,same as in makefakedata_v2     [10Hz]\n"
	     "-psi num        polarization angle,same as in makefakedata_v2                         [0.8]\n"
	     "-fdir string    set the directory of the SFT files to string                          [../makefakedata/fdata/]\n"
	     "-edir string    set the directory of ephemeris data files to string                   [/home/rarmen/opt/lscsoft/lal/share/lal/]\n"
	     "-s num          set the GPS starttime to num(same as non-overlapping SFT starttime)   [693326229]\n"
	     "-g num          The searching grid on SNR map is set to num*num                       [96]\n"
	     );
      return 1;
    }

  }

  
  startbin=(int)(T*ff+0.5);   /* the index of the starting frequecy bin which makefakedata generate Fourier coefficient */
  int totalbin=(int)(T*fb+0.5); /* the total number of frequency bins we are interested in */

  static LALStatus status;
  EphemerisData *edat=NULL;
  LALDetector DetectorH,DetectorL;
  SkyPosition SourcePos;
  LALGPSandAcc gpsandacc;
  LALDetAndSource DetandSrc;
  LALSource sourceF;
  sourceF.orientation=1.0;
  SourcePos.system=COORDINATESYSTEM_EQUATORIAL;
  REAL8 vel[3];
  DetectorH=lalCachedDetectors[LALDetectorIndexLHODIFF];
  DetectorL=lalCachedDetectors[LALDetectorIndexLLODIFF];
  edat=(EphemerisData *)LALMalloc(sizeof(EphemerisData));
  char* earthdata;
  char* sundata;
  earthdata=(char *)LALMalloc((strlen(optarg)+strlen(EARTHDATA)+2));
  sundata=  (char *)LALMalloc((strlen(optarg)+strlen(SUNDATA)+2));
  char* slash1="";
  if (!(optarg[strlen(optarg)]=='/')) slash1="/";
  sprintf(earthdata,"%s%s%s", optarg, slash1,EARTHDATA);
  sprintf(sundata,  "%s%s%s", optarg, slash1,SUNDATA);

  (*edat).ephiles.earthEphemeris = earthdata;
  (*edat).ephiles.sunEphemeris =   sundata;
  LALInitBarycenter(&status, edat);
 
  double  frequencies[3]={freq-fbin,freq,freq+fbin},
          RAsourcevector[sizeofline],
          Decsourcevector[sizeofline], 
          powermatrix[4][sizeofline],
	  total_w[4][sizeofline],totalnoisemean[4][sizeofline],totalnoisevar[4][sizeofline];
          
  int sourceindex,sizeofsearch;


  /* generate the grid vertices to be searched on the sky map */
  int ct=0,mct;

  double mdistance=100.0;
  for (i=0;i<sizeofmatrix+1;i++) {
    int linelim=sizeofmatrix+1;
    for (j=0;j<linelim;j++) { 
      RAsourcevector[ct]=(i-sizeofmatrix/2)*2*pi/sizeofmatrix;
      Decsourcevector[ct]=pi/sizeofmatrix*(j-sizeofmatrix/2);
      double distance=(RAsource-RAsourcevector[ct])*(RAsource-RAsourcevector[ct])+(Decsource-Decsourcevector[ct])*(Decsource-Decsourcevector[ct]);
      if (distance<mdistance) {mdistance=distance;mct=ct;}
      ct++;
    }
  }
  sizeofsearch=ct;
  sourceindex=mct;
 
 
  printf("RA Dec%f %f\n",RAsourcevector[sourceindex],Decsourcevector[sourceindex]);
 
  /* initialization */
  for (j=0;j<sizeofline;j++) {
    int k; 
    for (k=0;k<4;k++) {
      powermatrix[k][j]=0.0;
      total_w[k][j]=totalnoisemean[k][j]=totalnoisevar[k][j]=0.0;
    }
  }
       
  double Hanfbin,Livbin,Hanfbin1,Livbin1,
    RA,Dec,
    freqHanf,freqLiv,oldfreqHanf,oldfreqLiv,
    pdet_bar,pdet_bar1,bar1,bar2,var1,var2,w_1,w_2,noisespec[500],noisespec1[500],
    phaseD,phaseD1;

    
  int maxindex,maxindex1;  
 
  REAL4  liv_old[sizeofspectrum][2],liv_old1[sizeofspectrum][2], hanf_old[sizeofspectrum][2],hanf_old1[sizeofspectrum][2]; /* to store the raw Fourier coefficients generated by makefakedata */ 
  double alphaH[7],alphaH1[7],alphaL[7],alphaL1[7];  /* the alpha vector in matched filter */
  double R[7][7]={ {336, 504, 540, 480, 360, 216, 84},{504, 1071, 1260, 1170, 900, 549, 216},{540, 1260, 1800, 1800, 1440, 900, 360},{480, 1170, 1800, 2100, 1800, 1170, 480},{360, 900, 1440, 1800, 1800, 1260, 540},{216, 549, 900, 1170, 1260, 1071, 504},{84, 216, 360, 480, 540, 504, 336}}; /* the R^(-1) matrix in matched filter */
		  
  for (i=0;i<7;i++) for (j=0;j<7;j++) R[i][j]=R[i][j]/135.0;
  
  int m;  /* the index for the current iteration */
 
  /* here begins the biggest loop */
  for (m=0;m<iterations;m++) {
    
    double header[8];     
    int errorcode;
    char filename[100];
    FILE* frfile;
    char* slash;
    if (!(fdir[strlen(fdir)]=='/')) slash="/"; else slash="";
     
    /* begin to read SFT files generated by makefakedata,both overlapping and non-overlapping segments */
    sprintf(filename,"%s%sFourierH.%.5i",fdir,slash,m);
    frfile=fopen(filename,"r"); 
    errorcode=fread((void*)header,32,1,frfile);   
    if (errorcode!=1){
      printf( "Error in reading SFT files!\n");
      return 1;
    }
    for (i=0;i<totalbin;i++) {
      fread((void*)&hanf_old[i][0],sizeof(hanf_old[i][0]),1,frfile);
      fread((void*)&hanf_old[i][1],sizeof(hanf_old[i][1]),1,frfile);
    }  
    fclose(frfile);
    
    sprintf(filename,"%s%sFourierL.%.5i",fdir,slash,m);
    frfile=fopen(filename,"r");
    errorcode=fread((void*)header,32,1,frfile);
    if (errorcode!=1){
      printf( "Error in reading SFT files!\n");
      return 1;
    }
    for (i=0;i<totalbin;i++) {
      fread((void*)&liv_old[i][0],sizeof(liv_old[i][0]),1,frfile);
      fread((void*)&liv_old[i][1],sizeof(liv_old[i][1]),1,frfile);
    }
    fclose(frfile);
    
    /* non-overlapping */
    if (m>0) {

      sprintf(filename,"%s%sFourierH1.%.5i",fdir,slash,m-1);
      frfile=fopen(filename,"r");
      errorcode=fread((void*)header,32,1,frfile);
      if (errorcode!=1){
	printf( "Error in reading SFT files!\n");
	return 1;
      }
      for (i=0;i<totalbin;i++) {
	fread((void*)&hanf_old1[i][0],sizeof(hanf_old1[i][0]),1,frfile);
	fread((void*)&hanf_old1[i][1],sizeof(hanf_old1[i][1]),1,frfile);
      }
      fclose(frfile);

      sprintf(filename,"%s%sFourierL1.%.5i",fdir,slash,m-1);
      frfile=fopen(filename,"r");
      errorcode=fread((void*)header,32,1,frfile);
      if (errorcode!=1){
	printf( "Error in reading SFT files!\n");
	return 1;
      }
      for (i=0;i<totalbin;i++) {
	fread((void*)&liv_old1[i][0],sizeof(liv_old1[i][0]),1,frfile);
	fread((void*)&liv_old1[i][1],sizeof(liv_old1[i][1]),1,frfile);
      }
      fclose(frfile);
    }
    /* finished reading the SFT data */    



    
    double F_LHO,F_LHO_OLD,F_LLO,F_LLO_OLD; /* these are detector amplitude response coefficients */
    double w,w1;  /* these are the weights for average*/

    int index; 

    /* begin to search over the three nearby frequecy bins for signal */

    for (index=0;index<3;index++) {
      double newfreq=frequencies[index];      
      int vertex;

      /* search over all the grid vertices on the sky map */
      for (vertex=0;vertex<sizeofsearch;vertex++) {

	REAL4  Liv_old[sizeofspectrum][2],Liv_old1[sizeofspectrum][2], Hanf_old[sizeofspectrum][2],Hanf_old1[sizeofspectrum][2], /* to store Fourier coefficients after considering amplitude response */
	       xs[sizeofspectrum][2],xs1[sizeofspectrum][2]; /* the store the power spectrum */		
	RA=RAsourcevector[vertex];       
	Dec=Decsourcevector[vertex];
        sourceF.equatorialCoords.longitude=RA;
	sourceF.equatorialCoords.latitude=Dec;
	DetandSrc.pSource=&sourceF;

        DetandSrc.pDetector=&DetectorH;
	double fpp,fcc;
	double fppsign,fppsign1,fppsign2,fppsign3,indi,indi1;

        /* here begins to calculate the amplitude reponse coefficients and determine their signs*/
	fppsign=0.0;
	gpsandacc.gps.gpsNanoSeconds=0;
        F_LHO=0.0;
        int tseg;
	/* due to changing amplitude response during a segment, we sample the coefficients 11 times during a single time segment and then do average */
        for (tseg=0;tseg<11;tseg++) {
	  gpsandacc.gps.gpsSeconds=starttime+tseg*180+m*1800;
	  XLALComputeDetAMResponse(&fpp,&fcc,DetandSrc.pDetector->response,RA,Dec,psi,XLALGreenwichMeanSiderealTime(&(gpsandacc.gps)));
	  F_LHO=F_LHO+fpp*fpp;
	  fppsign=fppsign+fpp;
	}
        F_LHO=sqrt(F_LHO/11.0);

	fppsign1=0.0;
	DetandSrc.pDetector=&DetectorL;
	gpsandacc.gps.gpsNanoSeconds=0;
	F_LLO=0.0;
	for (tseg=0;tseg<11;tseg++) {
	  gpsandacc.gps.gpsSeconds=starttime+tseg*180+m*1800;
	  XLALComputeDetAMResponse(&fpp,&fcc,DetandSrc.pDetector->response,RA,Dec,psi,XLALGreenwichMeanSiderealTime(&(gpsandacc.gps)));
	  F_LLO=fpp*fpp+F_LLO;
	  fppsign1=fppsign1+fpp;
	}
	F_LLO=sqrt(F_LLO/11.0);
	if ((fppsign*fppsign1)>0) indi=1.0;
	else indi=-1.0;

        if (m>0) {
	  fppsign2=0.0;
	  DetandSrc.pDetector=&DetectorH;
	  gpsandacc.gps.gpsNanoSeconds=0;
	  F_LHO_OLD=0.0;
	  for (tseg=0;tseg<11;tseg++) {
	    gpsandacc.gps.gpsSeconds=starttime+m*1800-900+tseg*180;
	    XLALComputeDetAMResponse(&fpp,&fcc,DetandSrc.pDetector->response,RA,Dec,psi,XLALGreenwichMeanSiderealTime(&(gpsandacc.gps)));
	    F_LHO_OLD=fpp*fpp+F_LHO_OLD;
	    fppsign2=fppsign2+fpp;
	  }
          F_LHO_OLD=sqrt(F_LHO_OLD/11.0);
 
	  fppsign3=0.0;
	  DetandSrc.pDetector=&DetectorL;
	  gpsandacc.gps.gpsNanoSeconds=0;
	  F_LLO_OLD=0.0;
	  for (tseg=0;tseg<11;tseg++) {
	    gpsandacc.gps.gpsSeconds=starttime+m*1800-900+tseg*180;
	    XLALComputeDetAMResponse(&fpp,&fcc,DetandSrc.pDetector->response,RA,Dec,psi,XLALGreenwichMeanSiderealTime(&(gpsandacc.gps)));
	    F_LLO_OLD=fpp*fpp+F_LLO_OLD;
	    fppsign3=fppsign3+fpp;
	  }
	  F_LLO_OLD=sqrt(F_LLO_OLD/11.0);
	  if ((fppsign2*fppsign3)>0) indi1=1.0;
	  else indi1=-1.0;
	}
	/* finished calculating amplitude response coefficients */

	if (doppleroption) {

          /* here simcoh begin to calculate the doppler effect for non-overlapping segments */
	    LIGOTimeGPS curtime;
	    curtime.gpsSeconds=starttime+900+m*1800; /* here the curtime set to be the mid of the segment, this is essential to get the right time delay phase correction */
	    curtime.gpsNanoSeconds=0;
	    LALPlaceAndGPS LHOandTime,LLOandTime;
	    LHOandTime.p_detector=&DetectorH;
	    LLOandTime.p_detector=&DetectorL;
	    LHOandTime.p_gps=&curtime;
	    LLOandTime.p_gps=&curtime;
	    TwoDetsTimeAndASource DetAndTime;
	    DetAndTime.p_det_and_time1=&LHOandTime;
	    DetAndTime.p_det_and_time2=&LLOandTime;
	    SourcePos.longitude=RA;
	    SourcePos.latitude=Dec;
	    DetAndTime.p_source=&SourcePos;
            REAL8 tdelay;
	    LALTimeDelay(&status,&tdelay,&DetAndTime); /* calculate the time delay */
	    LALDetectorVel(&status,vel,&curtime,DetectorH,edat);
	    freqHanf=(vel[0]*cos(Dec)*cos(RA)+vel[1]*cos(Dec)*sin(RA)+vel[2]*sin(Dec)+1.0)*newfreq;   /* the doppler modulated frequency */
	    LALDetectorVel(&status,vel,&curtime,DetectorL,edat);
	    freqLiv=(vel[0]*cos(Dec)*cos(RA)+vel[1]*cos(Dec)*sin(RA)+vel[2]*sin(Dec)+1.0)*newfreq;
	    phaseD=-(freqHanf+freqLiv)/2.0*tdelay*2.0*pi;  /* this the the phase matching created by time delay */
	    Hanfbin=(freqHanf)/fbin;
	    Livbin=(freqLiv)/fbin;
	    maxindex=(int)((Hanfbin+Livbin)/2.0+0.5);
   
            /* calulating the alpha coefficients for matched filter. All the if statements are needed to avoid the divergence(actually equivalent to a sinc function. */
            for (i=0;i<7;i++) {
	      double delta=Hanfbin-(maxindex-3+i);
	      if (Abs(delta)<0.00001) delta=0.00001;
	      if (Abs(delta-1.0)<0.00001) delta=1.00001;
	      if (Abs(delta+1.0)<0.00001) delta=-1.00001;
	      alphaH[i]=1/sqrt(2.0*pi)*sin(pi*delta)/pi/delta/(1-delta*delta)*(double)(2*(i%2)-1);
	    }
	    for (i=0;i<7;i++) {
              double delta=Livbin-((maxindex-3)+i);
              if (Abs(delta)<0.00001) delta=0.00001;
              if (Abs(delta-1.0)<0.00001) delta=1.00001;
	      if (Abs(delta+1.0)<0.00001) delta=-1.00001;
              alphaL[i]=1/sqrt(2.0*pi)*sin(pi*delta)/pi/delta/(1-delta*delta)*(double)(2*(i%2)-1);
            }
	   

            if (m>0) {
           
	      /* repeat the same procedure for overlapping segments */
	      LIGOTimeGPS oldtime;
	      oldtime.gpsSeconds=starttime+m*1800;
	      oldtime.gpsNanoSeconds=0;
	      LALPlaceAndGPS LHOandTime,LLOandTime;
	      LHOandTime.p_detector=&DetectorH;
	      LLOandTime.p_detector=&DetectorL;
	      LHOandTime.p_gps=&oldtime;
	      LLOandTime.p_gps=&oldtime;
	      TwoDetsTimeAndASource DetAndTime;
	      DetAndTime.p_det_and_time1=&LHOandTime;
	      DetAndTime.p_det_and_time2=&LLOandTime;
	      DetAndTime.p_source=&SourcePos;
	      REAL8 tdelay;
	      LALTimeDelay(&status,&tdelay,&DetAndTime);
	      LALDetectorVel(&status,vel,&oldtime,DetectorH,edat);
	      oldfreqHanf=(vel[0]*cos(Dec)*cos(RA)+vel[1]*cos(Dec)*sin(RA)+vel[2]*sin(Dec)+1.0)*newfreq;
	      LALDetectorVel(&status,vel,&oldtime,DetectorL,edat);
	      oldfreqLiv=(vel[0]*cos(Dec)*cos(RA)+vel[1]*cos(Dec)*sin(RA)+vel[2]*sin(Dec)+1.0)*newfreq;
	      phaseD1=-(oldfreqHanf+oldfreqLiv)/2.0*tdelay*2.0*pi;
	      Hanfbin1=oldfreqHanf/fbin;
	      Livbin1=oldfreqLiv/fbin;
	      maxindex1=(int)((Hanfbin1+Livbin1)/2.0+0.5);
	      for (i=0;i<7;i++) { 
		double delta=Hanfbin1-(maxindex1-3+i);
		if (Abs(delta)<0.00001) delta=0.00001;
		if (Abs(delta-1.0)<0.00001) delta=1.00001;
		if (Abs(delta+1.0)<0.00001) delta=-1.00001;
		alphaH1[i]=1/sqrt(2.0*pi)*sin(pi*delta)/pi/delta/(1-delta*delta)*(double)(2*(i%2)-1);
	      }
	      for (i=0;i<7;i++) {
		double delta=Livbin1-((maxindex1-3)+i);
		if (Abs(delta)<0.00001) delta=0.00001;
		if (Abs(delta-1.0)<0.00001) delta=1.00001;
		if (Abs(delta+1.0)<0.00001) delta=-1.00001;
		alphaL1[i]=1/sqrt(2.0*pi)*sin(pi*delta)/pi/delta/(1-delta*delta)*(double)(2*(i%2)-1);
	      } 
	    
	     
	    }
	  }
	  else {
	    freqHanf=newfreq;
	    freqLiv=newfreq;
            Hanfbin=(freqHanf)/fbin;
            Livbin=(freqLiv)/fbin;
	    maxindex=(int)(newfreq/fbin+0.5);
	    if (m>0) {
	      oldfreqHanf=newfreq;
	      oldfreqLiv=newfreq;   
	      Hanfbin1=oldfreqHanf/fbin;
              Livbin1=oldfreqLiv/fbin;
	      maxindex1=(int)(newfreq/fbin+0.5);
	    }
	  }
	 
	/* since the spectrum does not start with frequency 0, we have to offset the starting frequency bin */          
          maxindex=maxindex-startbin;
	  maxindex1=maxindex1-startbin;
	  Hanfbin=Hanfbin-startbin;
	  Hanfbin1=Hanfbin1-startbin;
	  Livbin=Livbin-startbin;
	  Livbin1=Livbin1-startbin;
	 
	  /* make account for the amplitude reponse coefficients, first for noise bins(totally 500 bins), then for signal bins */	  
	  for ( i=totalbin-500-10;i<totalbin;i++)
	    for (j=0;j<2;j++) {
	      (Hanf_old[i][j]=hanf_old[i][j]/F_LHO);
	      Liv_old[i][j]=liv_old[i][j]/F_LLO;
	      if (m>0) {
		Hanf_old1[i][j]=hanf_old1[i][j]/F_LHO_OLD;
		Liv_old1[i][j]=liv_old1[i][j]/F_LLO_OLD;
	      }
	    }
	  
	  for (j=0;j<2;j++) {
	    for ( i=maxindex-10;i<maxindex+10;i++) {
	      Hanf_old[i][j]=hanf_old[i][j]/F_LHO;
	      Liv_old[i][j]=liv_old[i][j]/F_LLO;
	    }
	    if (m>0) {
	      for (i=maxindex1-10;i<maxindex1+10;i++) {
		Hanf_old1[i][j]=hanf_old1[i][j]/F_LHO_OLD;
		Liv_old1[i][j]=liv_old1[i][j]/F_LLO_OLD;
	      }
	    }
	  }
	  
	  
	  double cs,si;
	  double a2,b,a1,b1;
	  double livold0,livold1,livold10,livold11;
	  double normalizeH,normalizeL,normalizeH1,normalizeL1;	
	  normalizeH=normalizeL=normalizeH1=normalizeL1=0.0;
	  cs=cos(phaseD);si=sin(phaseD);
	  
	  if (matched) {
	    /* calculating the normalization coefficients need for matched filter */
	    for ( i=0;i<7;i++) 
	      for (j=0;j<7;j++) {
		normalizeH=normalizeH+R[i][j]*alphaH[i]*alphaH[j];
		normalizeH1=normalizeH1+R[i][j]*alphaH1[i]*alphaH1[j];
		normalizeL=normalizeL+R[i][j]*alphaL[i]*alphaL[j];
		normalizeL1=normalizeL1+R[i][j]*alphaL1[i]*alphaL1[j];
	      }
	    
	    double locsumH[7],locsumH1[7],locsumL[7],locsumL1[7];	    
	    for ( ii=0;ii<7;ii++) {
	      locsumH[ii]=locsumH1[ii]=locsumL[ii]=locsumL1[ii]=0.0;
	      for (jj=0;jj<7;jj++) {
		locsumH[ii]=locsumH[ii]+R[ii][jj]*alphaH[jj];
		locsumH1[ii]=locsumH1[ii]+R[ii][jj]*alphaH1[jj];
		locsumL[ii]=locsumL[ii]+R[ii][jj]*alphaL[jj];
		locsumL1[ii]=locsumL1[ii]+R[ii][jj]*alphaL1[jj];
	      }
	    }

	    /* here we try to generate the noise spectrum far away from the signal bins as a reference in order to compute SNR later */
	    /* the matched filter algorithm should also be applied to the noise bins */
	    for (i=totalbin-500-3;i<totalbin-3;i++) {
	      a2=b=a1=b1=0.0;
	      livold0=livold1=livold10=livold11=0.0;
	      
	      for ( ii=0;ii<7;ii++) {
		a2=a2+locsumH[ii]*Hanf_old[i-3+ii][0];
		b=b+locsumH[ii]*Hanf_old[i-3+ii][1];
		a1=a1+locsumH1[ii]*Hanf_old1[i-3+ii][0];
                b1=b1+locsumH1[ii]*Hanf_old1[i-3+ii][1];
		livold0=livold0+locsumL[ii]*Liv_old[i-3+ii][0];
                livold1=livold1+locsumL[ii]*Liv_old[i-3+ii][1];
		livold10=livold10+locsumL1[ii]*Liv_old1[i-3+ii][0];
                livold11=livold11+locsumL1[ii]*Liv_old1[i-3+ii][1];
	      }
	      a2=a2/normalizeH;
	      b=b/normalizeH;
	      a1=a1/normalizeH1;
	      b1=b1/normalizeH1;
	      livold0=livold0/normalizeL;
	      livold1=livold1/normalizeL;
	      livold10=livold10/normalizeL1;
	      livold11=livold11/normalizeL1;
	      
	      if (timedelayoption) {
		xs[i][0]=0.5*(indi*livold0+a2*cs-b*si);
		xs[i][1]=0.5*(indi*livold1+b*cs+a2*si);
		
		xs1[i][0]=0.5*(indi1*livold10+a1*cs-b1*si);
		xs1[i][1]=0.5*(indi1*livold11+b1*cs+a1*si);
	      }
	      else {
		xs[i][0]=0.5*(a2*a2+b*b+livold0*livold0+livold1*livold1);
		xs1[i][0]=0.5*(a1*a1+b1*b1+livold10*livold10+livold11*livold11);
	      }
	    }
	    
	    
           
	    cs=cos(phaseD);
	    si=sin(phaseD);
	    a2=0.0; b=0.0;
	    livold0=0.0;livold1=0.0;
	    
	    /*below is the matched filter algorithm, combining 7 bins to reconstruct complex ampitude (a2,b) for LHO and (livold0,livold1) for LLO*/
	    for ( i=0;i<7;i++) {
	      a2=a2+locsumH[i]*Hanf_old[maxindex-3+i][0];
	      b=b+locsumH[i]*Hanf_old[maxindex-3+i][1];
	      livold0=livold0+locsumL[i]*Liv_old[maxindex-3+i][0];
              livold1=livold1+locsumL[i]*Liv_old[maxindex-3+i][1];
	    }
	    a2=a2/normalizeH;b=b/normalizeH;
	    livold0=livold0/normalizeL;livold1=livold1/normalizeL;

          	    
	    if (timedelayoption) {
	      /* do the phase correction */
	      xs[maxindex][0]=0.5*(indi*livold0+a2*cs-b*si);
	      xs[maxindex][1]=0.5*(indi*livold1+b*cs+a2*si);
	      if ((vertex==sourceindex)&&(index==1)) printf("phase error(non-overlapping): a(%i)=angle((%20.15f+%20.15fi)/(%20.15f+%20.15fi))\n",m+1,indi*livold0,indi*livold1,a2*cs-b*si,b*cs+a2*si);
	
	    }
	    else
	      xs[maxindex][0]=0.5*(a2*a2+b*b+livold0*livold0+livold1*livold1);
	    
	    
	    
	    /* repeating the same procedure for overlapping segments */
	    if (m>0) {
	      double cs=cos(phaseD1);
	      double si=sin(phaseD1);
	      
	      a1=0.0;b1=0.0;
	      livold10=0.0;livold11=0.0;
	      for ( i=0;i<7;i++) {
		a1=a1+locsumH1[i]*Hanf_old1[maxindex1-3+i][0];
		b1=b1+locsumH1[i]*Hanf_old1[maxindex1-3+i][1];
		livold10=livold10+locsumL1[i]*Liv_old1[maxindex1-3+i][0];
                livold11=livold11+locsumL1[i]*Liv_old1[maxindex1-3+i][1];
	      }
	      a1=a1/normalizeH1;
	      b1=b1/normalizeH1;
	      livold10=livold10/normalizeL1;
	      livold11=livold11/normalizeL1;
	      
	      if (timedelayoption) {
		xs1[maxindex1][0]=0.5*(indi1*livold10+a1*cs-b1*si);
		xs1[maxindex1][1]=0.5*(indi1*livold11+b1*cs+a1*si);
		if ((vertex==sourceindex)&&(index==1))  printf("phase error(overrlapping): b(%i)=angle((%20.15f+%20.15fi)/(%20.15f+%20.15fi))\n",m+1,indi1*livold10,indi1*livold11,a1*cs-b1*si,b1*cs+a1*si);

	      }
	      else 
		xs1[maxindex1][0]=0.5*(a1*a1+b1*b1+livold10*livold10+livold11*livold11);
	      
	    }
	  }
	  else {
	    
	    /* if no matched filter is used, we still doing phase correction, but the matrix multiplication required for matched filter is neglected */
	    if (timedelayoption)
	      for ( i=totalbin-500-3;i<totalbin-3;i++) {
		a2=Hanf_old[i][0];
		b=Hanf_old[i][1];
		a1=Hanf_old1[i][0];
		b1=Hanf_old1[i][1];
		xs[i][0]=0.5*(-Liv_old[i][0]+a2*cs-b*si);
		xs[i][1]=0.5*(-Liv_old[i][1]+b*cs+a2*si);
		
		xs1[i][0]=0.5*(-Liv_old1[i][0]+a1*cs-b1*si);
		xs1[i][1]=0.5*(-Liv_old1[i][1]+b1*cs+a1*si);
	      }
	    else
	      for ( i=totalbin-500-3;i<totalbin-3;i++) {
		xs[i][0]=0.5*(Hanf_old[i][0]*Hanf_old[i][0]+Hanf_old[i][1]*Hanf_old[i][1]+Liv_old[i][0]*Liv_old[i][0]+Liv_old[i][1]*Liv_old[i][1]);
		xs1[i][0]=0.5*(Hanf_old1[i][0]*Hanf_old1[i][0]+Hanf_old1[i][1]*Hanf_old1[i][1]+Liv_old1[i][0]*Liv_old1[i][0]+Liv_old1[i][1]*Liv_old1[i][1]);
	      }
	    
	    cs=cos(phaseD);
	    si=sin(phaseD);
	    a2=Hanf_old[maxindex][0];
	    b=Hanf_old[maxindex][1];
	    if (timedelayoption) {
	      xs[maxindex][0]=0.5*(indi*Liv_old[maxindex][0]+a2*cs-b*si);
	      xs[maxindex][1]=0.5*(indi*Liv_old[maxindex][1]+b*cs+a2*si);
	      if ((vertex==sourceindex)&&(index==1))  if ((vertex==sourceindex)&&(index==1)) printf("a(%i)=angle((%20.15f+%20.15fi)/(%20.15f+%20.15fi))\n",m+1,indi*Liv_old[maxindex][0],indi*Liv_old[maxindex][1],a2*cs-b*si,b*cs+a2*si);
	
	      }
	    else
	      /* for incoherent summing */
	      xs[maxindex][0]=0.5*(Hanf_old[(int)(Hanfbin+0.5)][0]*Hanf_old[(int)(Hanfbin+0.5)][0]+Hanf_old[(int)(Hanfbin+0.5)][1]*Hanf_old[(int)(Hanfbin+0.5)][1]+Liv_old[(int)(Livbin+0.5)][0]*Liv_old[(int)(Livbin+0.5)][0]+Liv_old[(int)(Livbin+0.5)][1]*Liv_old[(int)(Livbin+0.5)][1]);
	    /* or alternatively we can use  xs[maxindex][0]=0.5*(Hanf_old[maxindex][0]*Hanf_old[maxindex][0]+Hanf_old[maxindex][1]*Hanf_old[maxindex][1]+Liv_old[maxindex][0]*Liv_old[maxindex][0]+Liv_old[maxindex][1]*Liv_old[maxindex][1]); this would provide better comparison with coherent summing, but usually gets a smaller SNR than the above expression */

		
	    /* repeating the same procedure for overlapping segments */
	    if (m>0) {
	      double cs=cos(phaseD1);
	      double si=sin(phaseD1);
	      a1=Hanf_old1[maxindex1][0];
	      b1=Hanf_old1[maxindex1][1];
	      if (timedelayoption) {
		xs1[maxindex1][0]=0.5*(indi1*Liv_old1[maxindex1][0]+a1*cs-b1*si);
		xs1[maxindex1][1]=0.5*(indi1*Liv_old1[maxindex1][1]+b1*cs+a1*si);
		if ((vertex==sourceindex)&&(index==1))  if ((vertex==sourceindex)&&(index==1))  if ((vertex==sourceindex)&&(index==1)) printf("a(%i)=angle((%20.15f+%20.15fi)/(%20.15f+%20.15fi))\n",m+1,indi1*Liv_old1[maxindex1][0],indi1*Liv_old1[maxindex1][1],a1*cs-b1*si,b1*cs+a1*si);

	      }
	      else {
		xs1[maxindex1][0]=0.5*(Hanf_old1[(int)(Hanfbin1+0.5)][0]*Hanf_old1[(int)(Hanfbin1+0.5)][0]+Hanf_old1[(int)(Hanfbin1+0.5)][1]*Hanf_old1[(int)(Hanfbin1+0.5)][1]+Liv_old1[(int)(Livbin1+0.5)][0]*Liv_old1[(int)(Livbin1+0.5)][0]+Liv_old1[(int)(Livbin1+0.5)][1]*Liv_old1[(int)(Livbin1+0.5)][1]);
		//	xs1[maxindex1][0]=0.5*(Hanf_old1[maxindex1][0]*Hanf_old1[maxindex1][0]+Hanf_old1[maxindex1][1]*Hanf_old1[maxindex1][1]+Liv_old1[maxindex1][0]*Liv_old1[maxindex1][0]+Liv_old1[maxindex1][1]*Liv_old1[maxindex1][1]);
		}
	    }
	    	     
	  }
	  	  
	  /* calculating the power spectrum for frequency spectrum */
	  if (timedelayoption) { 
	    for ( i=totalbin-500-3;i<totalbin-3;i++) xs[i][0]=2.0*(xs[i][0]*xs[i][0]+xs[i][1]*xs[i][1]);
	    xs[maxindex][0]=2.0*(xs[maxindex][0]*xs[maxindex][0]+xs[maxindex][1]*xs[maxindex][1]);
	  }
		 
	  /* calculating the noise level and stdev, which determines the weights for weighted-average required later */ 
	  for ( i=0;i<500;i++) noisespec[i]=xs[totalbin-500-3+i][0];
	  pdet_bar=mean(noisespec,500);
	  double sigma=stdev(noisespec,500);
	  w=(1.0/sigma)*(1.0/sigma);

     
          double  maxpower1,maxpower2,Averagepower;

          if (m>0) {
                        
	    if (timedelayoption) { 
	      for ( i=totalbin-500-3;i<totalbin-3;i++) xs1[i][0]=2.0*(xs1[i][0]*xs1[i][0]+xs1[i][1]*xs1[i][1]);
	      xs1[maxindex1][0]=2.0*(xs1[maxindex1][0]*xs1[maxindex1][0]+xs1[maxindex1][1]*xs1[maxindex1][1]);
	    }
            	
	    for ( i=0;i<500;i++) noisespec1[i]=xs1[totalbin-500-3+i][0];
	    pdet_bar1=mean(noisespec1,500);
	    double sigma1=stdev(noisespec1,500);
	    w1=(1.0/sigma1)*(1.0/sigma1);   

	    maxpower1=xs[maxindex][0]*w;
	    maxpower2=xs1[maxindex1][0]*w1;
	    Averagepower=0.5*(maxpower1+maxpower2);
            bar1=pdet_bar*w*0.5;
            bar2=pdet_bar1*w1*0.5;
	    var1=1.0/w*w*0.5;
	    var2=1.0/w1*w1*0.5;
            w_1=w*0.5;
	    w_2=w1*0.5;

	  }
	  else {
	    /* the first segment is a little special, therefore this "else" statement */
	    maxpower1=xs[maxindex][0]*w;
            maxpower2=0.0;
	    Averagepower=maxpower1*0.75;
	    bar1=pdet_bar*w*0.75;
            bar2=0.0;
	    var1=1.0/w*w*0.75;
	    var2=0.0;
            w_1=w*0.75;
            w_2=0.0;
	  }
  
	  powermatrix[index+1][vertex]=powermatrix[index+1][vertex]+Averagepower;
	  total_w[index+1][vertex]=total_w[index+1][vertex]+w_1+w_2;
          totalnoisemean[index+1][vertex]=totalnoisemean[index+1][vertex]+bar1+bar2;
          totalnoisevar[index+1][vertex]=totalnoisevar[index+1][vertex]+var1+var2;
	 
	  /* the last segment is also a little special, therefore this "if" statement */
	  if (m==(iterations-1)){
	    powermatrix[index+1][vertex]=powermatrix[index+1][vertex]+xs[maxindex][0]*0.25*w;
	    totalnoisemean[index+1][vertex]=totalnoisemean[index+1][vertex]+0.25*pdet_bar*w;
            total_w[index+1][vertex]=total_w[index+1][vertex]+0.25*w;
            totalnoisevar[index+1][vertex]=totalnoisevar[index+1][vertex]+0.25*1.0/w*w;
	  }
	
      }
      
      
    }
      
    printf("m:%i\n",m);
   
  }

 
  int mindex;
  double maxv;
  
  for ( i=0;i<4;i++) for (j=0;j<sizeofsearch;j++) powermatrix[i][j]=(powermatrix[i][j])/total_w[i][j];  
  
  /* make a summary of the results for all three frequency bins searched by simcoh */
  int filei;
  for (filei=1;filei<4;filei++) {
    double snrvec[100000];
    maxv=(powermatrix[filei][0]-totalnoisemean[filei][0]/total_w[2][0])/sqrt(1.0/total_w[filei][0]);
    /* find the sky position with the maximum SNR */
    for ( i=0;i<sizeofsearch;i++) {
      snrvec[i]= (powermatrix[filei][i]-totalnoisemean[filei][i]/total_w[filei][i])/sqrt(1.0/total_w[filei][i]);
      if ( snrvec[i] >=maxv) {maxv=snrvec[i];mindex=i;}
    }
    
    double rightascension_of_source=RAsourcevector[mindex];
    double declination_of_source=Decsourcevector[mindex];
    printf("rihgtascension_of_source declination_of_source %20.15f %20.15f \n",rightascension_of_source,declination_of_source);
    double meanofnoise=totalnoisemean[filei][mindex]/total_w[filei][mindex];
    double stdofnoise=sqrt(1.0/total_w[filei][mindex]);
    double realmaximum=powermatrix[filei][mindex];
    double SNR=(realmaximum-meanofnoise)/stdofnoise;
    printf("meanofnoise stdofnoise realmaximum SNR: %20.15f %20.15f %20.15f %20.15f \n",meanofnoise,stdofnoise,realmaximum,SNR);
    char filename[100],buffer[50];
    if (filei==1) sprintf(buffer,"1.txt");
    else if (filei==2) sprintf(buffer,"2.txt");
    else sprintf(buffer,"3.txt");
    if (timedelayoption) sprintf(filename,"t%s",buffer);
    else sprintf(filename,"%s",buffer);
    wrtfile(filei,filename,RAsourcevector,Decsourcevector,meanofnoise,SNR,stdofnoise, realmaximum, rightascension_of_source, declination_of_source, snrvec,frequencies[filei-1],sizeofsearch,sourceindex);
  }
  return 0;

}



double mean(double* array,int n) {
  double sum=0.0;
  int i;
  for ( i=0;i<n;i++) sum=sum+array[i];
  return(sum/(double)(n));
}

int maxind(double* array,int n) {
  int i,maxi;
  double maxv;
  maxv=array[0];
  for (i=0;i<n;i++) if (array[i]>maxv) {maxv=array[i];maxi=i;}
  return(maxi);
}

double stdev(double* array,int n) {
  double sqrsum=0.0;
  int i;
  double meanofarr=mean(array,n);
  for (i=0;i<n;i++) sqrsum=sqrsum+(array[i]-meanofarr)*(array[i]-meanofarr);
  return(sqrt(sqrsum/(n-1)));
}

void wrtfile(int k,char* filename,double* RAsourcevector,double* Decsourcevector,double meanofnoise,double SNR,double stdofnoise,double maximum,double rightascension_of_source,double declination_of_source,double snrvec[sizeofline],double newfreq,double sizeofsearch,int sourceindex) {
  FILE* fileout;
  double pi=3.14159265358979;
  fileout=fopen(filename,"w");
  fprintf(fileout,"%18.12e ",sizeofsearch);

  int i;
  for (i=0;i<sizeofsearch;i++) fprintf(fileout,"%18.12e %18.12e %18.12e ",RAsourcevector[i],Decsourcevector[i],snrvec[i]);
  fprintf(fileout,"%18.12e %18.12e %18.12e %18.12e %18.12e %18.12e %18.12e %18.12e %18.12e ",newfreq,meanofnoise,SNR,stdofnoise,maximum,rightascension_of_source*360/2/pi,declination_of_source*360/2/pi,RAsourcevector[sourceindex],Decsourcevector[sourceindex]);
  fclose(fileout);
}


double Abs(double x) {
  if (x>0.0) return(x);
  else return(-x);
}
