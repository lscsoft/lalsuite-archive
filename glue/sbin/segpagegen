#!/ldcg/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

This program is part of the Grid LSC User Environment (GLUE)

GLUE is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import gpstime
from glue.__segments import *
from glue.segments import segmentlist

#####################################################################
#assumes that on and off are sorted from highest to lowest version
def current_version(on, off):
  n1=len(on)
  n2=len(off)
  ALL_VALID=segmentlist([])
  print "n1="+repr(n1)+" n2="+repr(n2)
  valid=range(0,n1)
  VALID=range(0,n1)
  ON=segmentlist([])
  for i in range(0,n1):
    on_dq=on[i][0]
    on_version=on[i][1]
    on_list=on[i][2]
    off_dq=off[i][0]
    off_version=off[i][1]
    off_list=off[i][2]    
    print "on_dq="+on_dq+" on_version="+repr(on_version)+" off_dq="+off_dq+" off_version="+repr(off_version)
    valid[i]= on_list | off_list
    if(i==0):
	VALID[i]=valid[i]
	ALL_VALID=VALID[i]
    else:
	VALID[i]=valid[i]-ALL_VALID
	ALL_VALID |= VALID[i]
    ON |= (on_list & VALID[i])
  OFF=ALL_VALID-ON
  return [ON,OFF]
#####################################################################
def correct4injections(inj,on,off):
  on=on+[['Injection',0,inj]]
  try:
    off=off+[['Injection',0,segmentlist([inj.extent()])-inj]]
  except:
    return [segmentlist([]),segmentlist([])]
  return [on,off]
#####################################################################
# Parse command line options.
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# Connect to the database.
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# Create the base name of the output files.
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up 1600 GMT
midnight = list(time.gmtime())
midnight[3:] = [16,0,0,0,0,0]
midnight = time.mktime(tuple(midnight)) - time.timezone
midnight_gps = gpstime.GpsSecondsFromPyUTC(midnight)
time_str = str(midnight_gps)

#####################################################################
# SQL used to join the segment_definer table to the segment table.
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

#####################################################################
# Loop over interferometers to get the various segments.
if configuration['run']=='A5':
  IFO = ['H1','H2','G1','L1']
if configuration['run']=='S5':
  IFO = ['H1','H2','G1','V1','L1']  

for ifo in IFO:
  output_dir = os.path.join( seg_path, ifo )
  print output_dir
  dirname = output_dir
  if not os.path.isdir(output_dir+"/"):
    os.mkdir(output_dir+"/")	
 
  # create the names of the segment files
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection', 'STATEVEC.5.12']:
    if(ifo=='V1' or ifo=='G1'):
      injections=segmentlist([])
    if(segtype=='STATEVEC.5.12' and ifo!='V1'):
      continue
    segtype1=segtype
    if(segtype=='STATEVEC.5.12'):
      segtype='Science'
    # open the output files
    seg_fh = open(seg_file[segtype] + '.' + time_str + '.txt', 'w')

    # construct the sql to perform the query
    if verbose: print "querying database for ifo %s, state %s" % (ifo, segtype)
    if(segtype is 'Science'):
      sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    else:
      sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    if(ifo!='V1'):
      sql += "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype1
    sql += "AND segment_definer.version = 0 " ####
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    print sql
    curs.execute(sql)
    result = curs.fetchall()

    # coalesce the result and write to file
    if verbose: 
      print "coalescing %d segments for ifo %s, state %s and writing to file" \
        % (len(result), ifo, segtype)

    # put each segment number into a different segment list
    ret_segs_dict = {}
    for r in result:
      if(ifo=='V1'):
        segnum_key=0
      else:
        segnum_key=r[2]
      try:
        ret_segs_dict[segnum_key].append(segment(r[0],r[1]))
      except KeyError:
        ret_segs_dict[segnum_key] = segmentlist()
        ret_segs_dict[segnum_key].append(segment(r[0],r[1]))
    print ret_segs_dict
    # print the header to the file
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %d" % midnight_gps
    print >> seg_fh, "# number gps_start_time gps_end_time duration"

    # coalesce the segments and print them out in order of seg number
    segnums = ret_segs_dict.keys()
    segnums.sort()
    for r in segnums:
      ret_segs_dict[r].coalesce()
      for s in ret_segs_dict[r]:
        print >> seg_fh, str(r) + ' ' + str(s[0]) + ' ' + str(s[1]) + \
          ' ' + str(s[1] - s[0])
    if segtype is 'Injection' and ifo!='V1' and ifo!='G1':
     try:
       injections=ret_segs_dict[0]
     except KeyError:
       injections=segmentlist()

    # close the file
    seg_fh.flush()
    seg_fh.close()

  if(ifo=='V1' or ifo=='G1'):
    # update the symbolic links
    if verbose: print "creating symbolic links"
    for k in seg_file.keys():
      symlink_name = seg_file[k] + '.txt'
      try:
        os.unlink(symlink_name)
      except:
        pass
      os.symlink(seg_file[k] + '.' + time_str + '.txt', symlink_name)
    seg_fh = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %d" % midnight_gps
    print >> seg_fh, "# name version gps_start_time gps_end_time active"  
    seg_fh.flush()
    sys.stdout.flush()
    continue

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')

#  print "injections="
#  print injections

  # get the a list of non-statevec data quality quality segments
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT name, version FROM segment_definer WHERE "
  sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
    % (configuration['run'], ifo)
  sql += "order by name, version desc "
  sql += "FOR READ ONLY"

  print sql

  curs.execute(sql)
  dq_types = curs.fetchall()
  if verbose: print "got %d data quality segments" % len(dq_types)

  print dq_types

  # get each data quality flag, coalesce the list and write to a file
  print >> seg_fh, "# %s" % configuration['dbname']
  print >> seg_fh, "# %d" % midnight_gps
  print >> seg_fh, "# name version gps_start_time gps_end_time active"
  try:
    prev_type=dq_types[0][0] 
  except IndexError:
    prev_type=None

  ON_SEGS=[]	
  OFF_SEGS=[]
  for dq in dq_types:
    if verbose:
      print "querying database for %s,%s,%d" % (ifo, dq[0], dq[1])
    if(dq[0]!=prev_type):
      print "prev_type="+prev_type
      if(prev_type == 'Injection'):
        [ON_SEGS,OFF_SEGS]=correct4injections(injections,ON_SEGS, OFF_SEGS)
        sys.stdout.flush()
      [ON,OFF]=current_version(ON_SEGS,OFF_SEGS)
      for s in ON:
      	print >> seg_fh, "%s 99 %d %d 1" % (prev_type, s[0], s[1])
      for s in OFF:
      	print >> seg_fh, "%s 99 %d %d 0" % (prev_type, s[0], s[1])         
      ON_SEGS=[]
      OFF_SEGS=[]
    prev_type=dq[0]

    sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' AND " % configuration['run']
    sql += "segment_definer.ifos = '%s' AND " % ifo
    sql += "segment_definer.name = '%s' AND  " % dq[0]
    sql += "segment_definer.version = %d " % dq[1]
    sql += "ORDER BY segment.start_time asc FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    on_segs = segmentlist()
    off_segs = segmentlist()

    if verbose: 
      print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(result), ifo, dq[0], dq[1])
    for r in result:
      if r[2] == 0:
        off_segs.append(segment(r[0],r[1]))
      elif r[2] == 1:
        on_segs.append(segment(r[0],r[1]))

    on_segs.coalesce()
    off_segs.coalesce()
  
    ON_SEGS.append([dq[0],dq[1],on_segs])
    OFF_SEGS.append([dq[0],dq[1],off_segs])

    for s in on_segs:
      print >> seg_fh, "%s %d %d %d 1" % (dq[0], dq[1], s[0], s[1])

    for s in off_segs:
      print >> seg_fh, "%s %d %d %d 0" % (dq[0], dq[1], s[0], s[1])

    seg_fh.flush()
    sys.stdout.flush()

  try:
    if(dq[0] is 'Injection'):
      [ON_SEGS,OFF_SEGS]=correct4injections(injections,ON_SEGS, OFF_SEGS)
      sys.stdout.flush()
    [ON,OFF]=current_version(ON_SEGS,OFF_SEGS)
    for s in ON:
      print >> seg_fh, "%s 99 %d %d 1" % (dq[0], s[0], s[1]) 
    for s in OFF:
      print >> seg_fh, "%s 99 %d %d 0" % (prev_type, s[0], s[1])         
    ON_SEGS=[]	
    OFF_SEGS=[]
  except NameError:
    pass

  seg_fh.flush()
  seg_fh.close()

  # update the symbolic links
  if verbose: print "creating symbolic links"
  for k in seg_file.keys():
    symlink_name = seg_file[k] + '.txt'
    try:
      os.unlink(symlink_name)
    except:
      pass
    os.symlink(seg_file[k] + '.' + time_str + '.txt', symlink_name)

#####################################################################
# Close the connection to the database and exit.
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
