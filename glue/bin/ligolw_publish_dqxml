#!/usr/bin/python
#
# xml dq publishing script for virgo (or other) dq xml files
#
# $Id$
#
# Copyright (C) 2009 Duncan Brown
# 
# This is part of the Grid LSC User Environment (GLUE)
# 
# GLUE is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
# 
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import re
import exceptions
import signal
import re
import time
import glob
import logging
import logging.handlers

from optparse import OptionParser

from glue import LDBDClient
from glue import gsiserverutils
from glue import lal
from glue import segments
from glue import gpstime

from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils as ligolw_utils
from glue.ligolw.utils import segments as ligolw_segments
from glue.ligolw.utils import process as ligolw_process

from glue.segmentdb import segmentdb_utils

# try and exit gracefully on a term signal
die_now = False

def SIGTERMhandler(signum, frame):
  global die_now
  try:
    logger.info("caught SIGTERM")
  except:
    pass
  die_now = True

signal.signal(signal.SIGTERM, SIGTERMhandler)

PROGRAM_NAME = sys.argv[0].replace('./','')
PROGRAM_PID  = os.getpid()

try:
  USER_NAME = os.getlogin()
except:
  USER_NAME = pwd.getpwuid(os.getuid())[0]

__author__  = "Duncan Brown <dabrown@physics.syr.edu>"
__date__    = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]

parser = OptionParser(
  version = "%prog CVS $Header$",
  usage   = "%prog [OPTIONS]",
  description = "Publishes XML files into the segment database")

parser.add_option("-r", "--server", metavar = "HOST:PORT", help = "connect to ldbd on HOST:PORT (default port 30020)")
parser.add_option("-d", "--spool-directory", metavar = "DIR", help = "use DIR as spool directory")
parser.add_option("-D", "--input-directory", metavar = "DIR", help = "look for input files in DIR")
parser.add_option("-l", "--log-file", metavar = "FILE", help = "use FILE as log file")
parser.add_option("-L", "--log-level", metavar = "LEVEL", default = "INFO", help = "set logging level to LEVEL")
parser.add_option("-p", "--ping", action = "store_true")

options, filenames = parser.parse_args()

if not options.server:
  raise ValueError, "missing argument --server"

if options.server.find(':') < 0:
  # no port specified
  host = options.server
else:
  # server and port specified
  host, portString = options.server.split(':')
  port = int(portString)
identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

if options.ping:
  myClient = LDBDClient.LDBDClient(host, port, identity)
  msg = myClient.ping()
  print msg
  sys.exit(0)

if not options.spool_directory:
  raise ValueError, "missing argument --spool-directory"
if not options.input_directory:
  raise ValueError, "missing argument --input-directory"
if not options.log_file:
  raise ValueError, "missing argument --log-file"

lock_file = os.path.join(options.spool_directory,'publish_dqxml.lock')
if os.access(lock_file,os.F_OK):
  raise RuntimeError, "lock file exists: %s" % lock_file
else:
  fp = open(lock_file, "w")
  fp.write("lock")
  fp.close()

try:
  # setup the output file
  outdoc = ligolw.Document()
  outdoc.appendChild(ligolw.LIGO_LW())
  proc_id = ligolw_process.register_to_xmldoc(outdoc, PROGRAM_NAME, options.__dict__).process_id

  # set up logging
  logger = logging.getLogger('ligolw_publish_dqxml')
  handler = logging.handlers.RotatingFileHandler(options.log_file, 'a', 1024 * 1048576, 5)
  formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
  handler.setFormatter(formatter)
  logger.addHandler(handler)
  logger.setLevel(eval("logging." + options.log_level))
  logger.info("ligolw_publish_dqxml starting")
  logger.debug("server = " + options.server)
  logger.debug("spool directory = " + options.spool_directory)
  logger.debug("input directory = " + options.input_directory)
  logger.debug("log file = " + options.log_file)
  logger.debug("log level = " + options.log_level)

  # read in the published file and get the published segment list
  state_file = os.path.join(options.spool_directory,"published.xml")
  logger.debug("reading state from %s" % state_file)
  indoc = ligolw_utils.load_url(state_file, gz = (state_file or "stdin").endswith(".gz"))
  published_segments = segmentdb_utils.find_segments(indoc,"P1:PUBLISHED:0")

  # FIXME this will break Sep 14 2011 01:46:24 UTC
  all_time = segments.segmentlist([segments.segment(0,999999999)])

  # make a list of the files that need to be inserted
  pending_segments = all_time - published_segments
  pending_files = lal.Cache()
  for s in pending_segments:
    pending_files += lal.Cache.from_urls(segmentdb_utils.get_all_files_in_range(options.input_directory,s[0],s[1]),coltype=int).sieve(segment=s)
  pending_files.sort()

  # publish the files and add them to the list of published segments
  for f in pending_files:
    if die_now:
      break
    infile = f.path()
    try:
      logger.debug("reading %s" % infile)
      fh = open(infile,'r')
      xmltext = fh.read()
      fh.close()
      logger.debug("inserting %s" % infile)
      myClient = LDBDClient.LDBDClient(host, port, identity)
      myClient.insertdmt(xmltext)
      del xmltext
    except KeyboardInterrupt:
      logger.info("caught keyboard interrupt")
      published_segments |= segments.segmentlist([f.segment])
      die_now = True
    except Exception, e:
      logger.error("failed to publish %s (%s)" % (infile, str(e)))
    else:
      published_segments |= segments.segmentlist([f.segment])

  segment_def_id = segmentdb_utils.add_to_segment_definer(outdoc,proc_id,"P1","PUBLISHED",0)
  segmentdb_utils.add_to_segment(outdoc,proc_id,segment_def_id,published_segments)

  # write the new segment state file on top of the old one
  logger.debug("writing state to %s" % state_file)
  ligolw_utils.write_filename(outdoc, state_file)

except Exception, e:
  try:
    logger.error(str(e))
  except:
    pass
  print >>sys.stderr, "runtime error (%s)" % str(e)
  os.unlink(lock_file)
  sys.exit(1)

logger.info("exiting")
os.unlink(lock_file)
sys.exit(0)
