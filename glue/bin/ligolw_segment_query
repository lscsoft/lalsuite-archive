#!/usr/bin/env python
#
# $Id$
#
# Copyright (C) 2009  Larne Pekowsky, Ping Wei
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
This provides the means to answer several questions posed against either the
segment database or a collection of DMT XML files:

  * What DQ flags exist in the database? ligolw_segment_query --show-types
  * When was a given DQ flag defined? ligolw_segment_query --query-types 
  * When was a given flag active? ligolw_segment_query --query-segments
"""


from optparse import OptionParser

try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3

import sys
import os
import pwd
import glob
import time
import socket
import tempfile
import urllib

from glue import LDBDClient
from glue import gsiserverutils

import glue.segments

from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils

from glue.ligolw.utils import ligolw_add
from glue.ligolw.utils import process
from glue.segmentdb import query_engine
from glue.segmentdb import segmentdb_utils

from glue.ligolw.utils import ligolw_sqlite
from glue.ligolw import dbtables


PROGRAM_NAME = sys.argv[0].replace('./','')
PROGRAM_PID  = os.getpid()
try:
        USER_NAME = os.getlogin()
except:
        USER_NAME = pwd.getpwuid(os.getuid())[0]


__author__  = "Larne Pekowsky <lppekows@physics.syr.edu>, Ping Wei <piwei@syr.edu>"
__date__    = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
    """
    Parse the command line, return an options object
    """

    parser = OptionParser(
        version     = "%prog CVS $Header$",
        usage       = "%prog [ --version | --ping | --show-types | --query-types | --query-segments ]  [ --segment | --database | --dmt-files ] options ",
        description = "Performs a number of queries against either a set of DMT files or a segment database"
	)


    # Major modes
    parser.add_option("-p", "--ping",           action = "store_true", help = "Ping the target server")
    parser.add_option("-y", "--show-types",     action = "store_true", help = "Returns a xml table containing segment type information: ifos, name, version, segment_definer.comment, segment_summary.start_time, segment_summary.end_time, segment_summary.comment")
    parser.add_option("-u", "--query-types",    action = "store_true", help = "Returns a ligolw document whose segment_definer table includes all segment types defined in the given period and included by include-segments, and whose segment table includes all active segments matching the same criteria.")
    parser.add_option("-q", "--query-segments", action = "store_true", help = "Returns a ligolw document whose segment table contains the times included by the include-segments flag and excluded by exclude-segments")

    # Time options
    parser.add_option("-s", "--gps-start-time", metavar = "gps_start_time", help = "Start of GPS time range")
    parser.add_option("-e", "--gps-end-time",   metavar = "gps_end_time", help = "End of GPS time range")


    # Data location options
    parser.add_option("-t", "--segment-url",    metavar = "segment_url", help = "Segment URL. Users have to specify a prefix 'ldbd://' in front of the actual url where the segment database locates. For example, '--segment-url=ldbd://nldas.ligo-wa.caltech.edu:30015'. Port number is optional, if not present, the default port 30015 will be used. ")
    parser.add_option("-d", "--database",   metavar = "use_database", action = "store_true", help = "use database specified by environment variable S6_SEGMENT_SERVER. For example, 'S6_SEGMENT_SERVER=ldbd://nldas.ligo-wa.caltech.edu'")
    parser.add_option("-f", "--dmt-files",   metavar = "use_files", action = "store_true", help = "use files in directory specified by environment variable DMT_SEGMENT_LOCATION, for example, 'DMT_SEGMENT_LOCATION=file:///path_to_dmt'. 'file://' is the prefix, the acutal directory to DMT xml files starts with '/'.")


    # Other options
    parser.add_option("-a", "--include-segments", metavar = "include_segments", help = "This option expects a comma separated list of a colon separated sublist of interferometer, segment type, and version. The union of segments from all types and versions specified is returned. Use --show-types to see what types are available.   For example: --include-segment-types H1:DMT-SCIENCE:1,H1:DMT-INJECTION:2 will return the segments for which H1 is in either SCIENCE version 1 or INJECTION version 2 mode. If version information is not provided, the union of the segments of the latest version of requested segment type(s) will be returned.")

    parser.add_option("-b", "--exclude-segments", metavar = "exclude_segments", help = "This option has to be used in conjunction with --include-segment-types --exclude-segment-types subtracts the union of unwanted segments from the specified types from the results of --include-segment-types. If version information is not provided, --exclude-segment-types subtracts the union of segments from the latest version of the specified segment types. For example, --include-segment-types H1:DMT-SCIENCE:1,H1:DMT-INJECTION:2 --exclude-segment-types H1:DMT-WIND:1,H1:DMT-NOT_LOCKED:2,H2:DMT-NOT_LOCKED:2 will subtract the union of segments which H1 is in version 1 WIND and H1,H2 is version 2 NOT_LOCKED from the result of --include-segment-types H1:DMT-SCIENCE:1,H1:DMT-INJECTION:2")


    parser.add_option("-S", "--strict-off", metavar = "use_strict", action = "store_true", help = "The default behavior is to truncate segments so that returned segments are entirely in the interval [gps-start-time, gps-end-time).  However if this option is given, the entire non-truncated segment is returned if any part of it overlaps the interval.")

    parser.add_option("-o", "--output-file",   metavar = "output_file", help = "File to which output should be written.  Defaults to stdout.")
    
    options, others = parser.parse_args()

    # Make sure we have exactly one thing to do
    count = 0
    for arg in [options.ping, options.query_types, options.show_types, options.query_segments]:
        if arg:
            count += 1
            
    if count != 1:
        raise ValueError("Exactly one of [ --ping | --show-types | --query-types | --query-segments ] must be provided")
    
    
    # Make sure we have required arguments
    database_location = None
    file_location     = None

    # Make sure we know who to contact for data
    if options.segment_url:
        if options.segment_url.startswith('ldbd:'):
            database_location = options.segment_url[len('ldbd://'):]
        elif options.segment_url.startswith('file:'):
            file_location = options.segment_url[len('file://'):]
        else:
            tmp_dir = tempfile.mkdtemp()
        
            # Grab the part of the name after the last slash
            pos     = options.segment_url[::-1].find('/')
            fname   = (pos > -1) and options.segment_url[ -1 * pos:] or "dmt.xml" 

            inurl   = urllib.urlopen(options.segment_url)
            outfile = open(tmp_dir + "/" + fname, 'w')
            for l in inurl:
                print >>outfile, l,

            inurl.close()
            outfile.close()
            file_location = tmp_dir
    elif options.database:
        if 'S6_SEGMENT_SERVER' not in os.environ:
            raise ValueError( "--database specified but S6_SEGMENT_SERVER not set" )
        database_location = os.environ['S6_SEGMENT_SERVER'][len('ldbd://'):]
    elif options.dmt_files:
        if 'DMT_SEGMENT_LOCATION' not in os.environ:
            raise ValueError( "--dmt-files specified but DMT_SEGMENT_LOCATION not set" )
        file_location = os.environ['DMT_SEGMENT_LOCATION'][len('file://'):]
    else:
        raise ValueError( "One of [ --segment-url | --database | --dmt-files ] must be provided" )
        

    # Unless we're pinging, make sure we have start and end times
    if options.ping:
        if not database_location:
            raise ValueError("--ping requires [ --segment-url ldbd:... | --database ]")
    else:
        if not options.gps_start_time:
            raise ValueError( "missing required argument --gps-start-time" )
    
        if not options.gps_end_time:
            raise ValueError( "missing required argument --gps-end-time" )

        if not options.show_types and not options.include_segments:
            raise ValueError( "missing required argument --include-segments")
    
    return options, database_location, file_location




#
# =============================================================================
#
#                                 General utilities
#
# =============================================================================
#
def split_segment_ids(segment_ids):
    """Given an array of strings of the form ifo:name and
    ifo:name:version, returns an array of tuples of the form (ifo,
    name, version) where version may be None"""
    
    def split_segment_id(segment_id):
        temp = segment_id.split(':')
        if len(temp) == 2:
            temp.append(None)
        elif temp[2] == '*':
            temp[2] = None
        else:
            temp[2] = int(temp[2])
            
        return temp

    return map(split_segment_id, segment_ids)



def seg_spec_to_sql(spec):
    """Given a string of the form ifo:name:version, ifo:name:* or ifo:name
    constructs a SQL caluse to restrict a search to that segment definer"""

    parts = spec.split(':')
    sql   = "(segment_definer.ifos = '%s'" % parts[0]

    if len(parts) > 1 and parts[1] != '*':
        sql += " AND segment_definer.name = '%s'" % parts[1]
        if len(parts) > 2 and parts[2] != '*':
            sql += " AND segment_definer.version = %s" % parts[2]

    sql += ')'

    return sql



def build_segment_list_old(connection, engine, gps_start_time, gps_end_time, ifo, segment_name, version = None):
    """
    Resolves an ifo, segment_name, version number (which may be *) into segments.  If version number is
    provided the query is straightforward, if not we do the following:

    1. Retrieve the max version of the requested segment type 
    2. Select all the segments of the max version for the given segment type
    3. Retreive the max summary end time of the max version for the given segment type
    4. Select all version 1 segments after the max summary end_time of the max version for the given segment type
    5. Combine the segments of the max version and the ongoing vesion 1

    """
    result = glue.segments.segmentlist([])

    # Do we have a version number?
    if version is not None:
        # We can't use queries paramaterized with ? since the ldbd protocol doesn't support it...
        # AND segment.segment_def_cdb = segment_definer.creator_db
        sql = "SELECT segment.start_time, segment.end_time, segment_definer.version "
        sql += "FROM segment, segment_definer "
        sql += "WHERE segment.segment_def_id = segment_definer.segment_def_id "
        if (options.segment_url and options.segment_url.startswith('ldbd://')) or options.database:
           sql += "AND segment.segment_def_cdb = segment_definer.creator_db "
        sql += "AND   segment_definer.ifos = '%s' " % ifo
        sql += "AND   segment_definer.name = '%s' " % segment_name
        sql += "AND   segment_definer.version = %s " % version
        sql += "AND NOT (%s > segment.end_time OR segment.start_time > %s)" % (gps_start_time, gps_end_time)

        rows = engine.query(sql)

        for start_time, end_time, version in rows:
            result |= glue.segments.segmentlist([glue.segments.segment(start_time, end_time)])

        engine.close()
    else:
        # retrieve a union of the max version and the ongoing version 1
        # 1. retrieve the max version of the requested segment type, and its segments
        max_ver = int(engine.query("""SELECT max(version) FROM segment_definer 
          WHERE segment_definer.ifos = '%s'
          AND segment_definer.name = '%s' 
        """ % (ifo, segment_name))[0][0])


        sql = "SELECT segment.start_time, segment.end_time, segment_definer.version "
        sql += " FROM segment, segment_definer "
        sql += "WHERE segment.segment_def_id = segment_definer.segment_def_id "
        if (options.segment_url and options.segment_url.startswith('ldbd://')) or options.database:
           sql += "AND segment.segment_def_cdb = segment_definer.creator_db "
        sql += "AND   segment_definer.ifos = '%s' " % ifo
        sql += "AND   segment_definer.name = '%s' " % segment_name
        sql += "AND   segment_definer.version = %d " % max_ver
        sql += "AND NOT (%s > segment.end_time OR segment.start_time > %s)" % (gps_start_time, gps_end_time)
        
        rows = engine.query(sql)
     

        # 2. retreive the max summary end time of the max version of the requested segment type

        sql = "SELECT max(segment_summary.end_time) "
        sql += "FROM segment_summary, segment_definer "
        sql += "WHERE segment_summary.segment_def_id = segment_definer.segment_def_id "
        if (options.segment_url and options.segment_url.startswith('ldbd://')) or options.database:
           sql += "AND segment_summary.segment_def_cdb = segment_definer.creator_db "
        sql += "AND segment_definer.name= '%s' " % segment_name
        sql += "AND segment_definer.ifos = '%s' " % ifo
        sql += "AND segment_definer.version = %d " % max_ver


        max_ver_endtime = int(engine.query(sql)[0][0]) 

        # retreive version 1 segments after the max_ver_endtime
        sql = "SELECT segment.start_time, segment.end_time, 1 "
        sql += "FROM segment, segment_definer, segment_summary "
        sql += "WHERE segment.segment_def_id = segment_definer.segment_def_id "
        if (options.segment_url and options.segment_url.startswith('ldbd://')) or options.database:
           sql += "AND segment.segment_def_cdb = segment_definer.creator_db "
        sql += "AND segment_summary.segment_def_id = segment_definer.segment_def_id "
        if (options.segment_url and options.segment_url.startswith('ldbd://')) or options.database:
           sql += "AND segment_summary.segment_def_cdb = segment_definer.creator_db "
        sql += "AND segment_definer.version = 1 "
        sql += "AND segment_definer.ifos = '%s' " % ifo
        sql += "AND segment_definer.name = '%s' " % segment_name
        sql += "AND segment_summary.start_time >= %d " % max_ver_endtime
        sql += "AND NOT (%s > segment.end_time OR segment.start_time > %s) " % (gps_start_time, gps_end_time)

        rows += engine.query(sql)

        for start_time, end_time, version in rows:
            result |= glue.segments.segmentlist([glue.segments.segment(start_time, end_time)])
        engine.close()

    result.coalesce()
    return result


#
# The results of show-types is a join against segment_definer and segment
# summary, and so does not fit into an existing table type.  So here we
# define a new type so that the ligolw routines can generate the XML
#
class ShowTypesResultTable(table.Table):
    tableName = "show_types_result:table"

    validcolumns = {
        "ifos": "lstring",
        "name": "lstring",
        "version": "int_4s",
        "segment_definer_comment": "lstring",
        "segment_summary_start_time": "int_4s",
        "segment_summary_end_time": "int_4s",
        "segment_summary_comment": "lstring"
        }
    


class ShowTypesResult(object):
    __slots__ = ShowTypesResultTable.validcolumns.keys()

    def get_pyvalue(self):
        if self.value is None:
            return None
        return ligolwtypes.ToPyType[self.type or "lstring"](self.value)


ShowTypesResultTable.RowType = ShowTypesResult



#
# =============================================================================
#
#                          Methods that implement major modes
#
# =============================================================================
#
def run_show_types(doc, connection, engine, gps_start_time, gps_end_time, included_segments_string, excluded_segments_string):
    resulttable = lsctables.New(ShowTypesResultTable)
    doc.childNodes[0].appendChild(resulttable)
    
    sql = """SELECT segment_definer.ifos, segment_definer.name, segment_definer.version,
                 (CASE WHEN segment_definer.comment IS NULL THEN '-' WHEN segment_definer.comment IS NOT NULL THEN segment_definer.comment END),
                 segment_summary.start_time, segment_summary.end_time,
                 (CASE WHEN segment_summary.comment IS NULL THEN '-' WHEN segment_summary.comment IS NOT NULL THEN segment_summary.comment END)
          FROM  segment_definer, segment_summary
          WHERE segment_definer.segment_def_id = segment_summary.segment_def_id
          AND   NOT (segment_summary.start_time > %d OR %d > segment_summary.end_time)
          """ % (gps_end_time, gps_start_time)

    rows = engine.query(sql)

    seg_dict = {}

    for row in rows:
        ifos, name, version, segment_definer_comment, segment_summary_start_time, segment_summary_end_time, segment_summary_comment = row
        key = (ifos, name, version, segment_definer_comment, segment_summary_comment)
        if key not in seg_dict:
            seg_dict[key] = []

        seg_dict[key].append(glue.segments.segment(segment_summary_start_time, segment_summary_end_time))

    for key, value in seg_dict.iteritems():
        segmentlist = glue.segments.segmentlist(value)
        segmentlist.coalesce()

        for segment in segmentlist:
            result = ShowTypesResult()
            result.ifos, result.name, result.version, result.segment_definer_comment, result.segment_summary_comment = key
            result.segment_summary_start_time, result.segment_summary_end_time = segment
            result.ifos = result.ifos.strip()
        
            resulttable.append(result)

    engine.close()


    




def run_query_types(doc, proc_id, connection, engine, gps_start_time, gps_end_time, included_segments):
    query_segment = glue.segments.segmentlist([glue.segments.segment(gps_start_time, gps_end_time)])

    sql = """SELECT segment_definer.ifos, segment_definer.name,segment_definer.version,
           (CASE WHEN segment_definer.comment IS NULL THEN '-' WHEN segment_definer.comment IS NOT NULL THEN segment_definer.comment END),
           segment_summary.start_time, segment_summary.end_time,
           (CASE WHEN segment_summary.comment IS NULL THEN '-' WHEN segment_summary.comment IS NOT NULL THEN segment_summary.comment END)
    FROM segment_definer, segment_summary
    WHERE segment_definer.segment_def_id = segment_summary.segment_def_id
    AND NOT(%d > segment_summary.end_time OR segment_summary.start_time > %d)
    """ % (gps_start_time, gps_end_time)

    type_clauses = map(seg_spec_to_sql, included_segments.split(','))

    if type_clauses != []:
        sql += " AND (" + "OR ".join(type_clauses) + ")"


    segment_types = {}

    for row in engine.query(sql):
        sd_ifo, sd_name, sd_vers, sd_comment, ss_start, ss_end, ss_comment = row
        key = (sd_ifo, sd_name, sd_vers, sd_comment, ss_comment)
        if key not in segment_types:
            segment_types[key] = glue.segments.segmentlist([])
        segment_types[key] |= glue.segments.segmentlist([glue.segments.segment(ss_start, ss_end)])

    engine.close()

    # Create segment definer and segment_summary tables
    seg_def_table = lsctables.New(lsctables.SegmentDefTable, columns = ["process_id", "segment_def_id", "ifos", "name", "version", "comment"])
    doc.childNodes[0].appendChild(seg_def_table)

    seg_sum_table = lsctables.New(lsctables.SegmentSumTable, columns = ["process_id", "segment_sum_id", "start_time", "end_time", "comment", "segment_def_id"])

    doc.childNodes[0].appendChild(seg_sum_table)

    for key in segment_types:
        # Make sure the intervals fall within the query window and coalesce
        segment_types[key] &= query_segment
        segment_types[key].coalesce()

        seg_def_id                     = seg_def_table.get_next_id()
        segment_definer                = lsctables.SegmentDef()
        segment_definer.process_id     = proc_id
        segment_definer.segment_def_id = seg_def_id
        segment_definer.ifos           = key[0]
        segment_definer.name           = key[1]
        segment_definer.version        = key[2]
        segment_definer.comment        = key[3]

        seg_def_table.append(segment_definer)

        # add each segment summary to the segment_summary_table

        for seg in segment_types[key]:
            segment_sum            = lsctables.SegmentSum()
            segment_sum.comment    = key[4]
            segment_sum.process_id = proc_id
            segment_sum.segment_def_id = seg_def_id
            segment_sum.segment_sum_id = seg_sum_table.get_next_id()
            segment_sum.start_time = seg[0]
            segment_sum.end_time   = seg[1]

            seg_sum_table.append(segment_sum)




#
# =============================================================================
#
#                                 Database/ldbd routines
#
# =============================================================================
#


def setup_database(host_and_port):
    port = 30015
    
    if host_and_port.find(':') < 0:
        host = host_and_port
    else:
        # server and port specified
        host, portString = host_and_port.split(':')
        port = int(portString)


    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

    # open connection to LDBD Server
    client = None

    try:
        client = LDBDClient.LDBDClient(host, port, identity)
    except Exception, e:
        print >>sys.stderr, \
              "Unable to connect to LDBD Server %s:%d" % (host, port)
        if gsiserverutils.checkCredentials():
            print >>sys.stderr, "Got the following error : " + str(e)
            print >>sys.stderr, "Enter '%s --help' for usage" % PROGRAM_NAME
        sys.exit(-1)

    return client


def ping_server(client):
    print client.ping()
    return 0


#
# =============================================================================
#
#                                 XML/File routines
#
# =============================================================================
#


def setup_files(dir_name, gps_start_time, gps_end_time):
    # Filter out the ones that are outside our time range
    xml_files = segmentdb_utils.get_all_files_in_range(dir_name, gps_start_time, gps_end_time)

    handle, temp_db  = tempfile.mkstemp(suffix='.sqlite')
    os.close(handle)

    target     = dbtables.get_connection_filename(temp_db, None, True, False)
    connection = ligolw_sqlite.setup(target)

    ligolw_sqlite.insert(connection, xml_files) # [temp_xml])

    return temp_db, connection
    



#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

if __name__ == '__main__':
    # Add boolean as a type to ligolwtypes, so that we can put boolean arguments
    # into the process_params table

    from glue.ligolw import types as ligolwtypes
    ligolwtypes.FromPyType[type(True)] = ligolwtypes.FromPyType[type(8)]


    # We don't accept nanosecond resolution
    del lsctables.SegmentTable.validcolumns['start_time_ns']
    del lsctables.SegmentTable.validcolumns['end_time_ns']

    options, database_location, file_location  = parse_command_line()    

    # Ping the database and exit if requested
    if options.ping:
        connection = setup_database(database_location)
        sys.exit( ping_server(connection) )

    gps_start_time = int(options.gps_start_time)
    gps_end_time   = int(options.gps_end_time)

    # set up the response
    doc = ligolw.Document()
    doc.appendChild(ligolw.LIGO_LW())
    process_id = process.register_to_xmldoc(doc, PROGRAM_NAME, options.__dict__, version = __version__, cvs_entry_time = __date__).process_id

    temp_files = False

    if database_location:
        connection = setup_database(database_location)
        engine     = query_engine.LdbdQueryEngine(connection)
    else:
        temp_db, connection = setup_files(file_location, gps_start_time, gps_end_time)
        engine     = query_engine.SqliteQueryEngine(connection)
        temp_files = True

    
    if options.show_types:
        run_show_types(doc, connection, engine, gps_start_time, gps_end_time,
                       options.include_segments,options.exclude_segments)
        

    if options.query_segments:
        segmentdb_utils.run_query_segments(doc, process_id, engine, gps_start_time, gps_end_time,
                           options.include_segments,options.exclude_segments)


    if options.query_types:
        run_query_types(doc, process_id, connection, engine, gps_start_time, gps_end_time, options.include_segments)


    utils.write_filename(doc, options.output_file)

    # Clean up
    if temp_files:
        os.remove(temp_db)


